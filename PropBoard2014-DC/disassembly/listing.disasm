Disassembly Listing for PropBoard2014-DC
Generated From:
D:/Robotique/codes/mainRobot/PropBoard2014-DC/dist/default/production/PropBoard2014-DC.production.elf
27-oct.-2014 16:50:40

---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/trajectoire.c  ---------------------------------------
1:                 #include "Globals.h"
2:                 #include "consigne.h"
3:                 #include <stdlib.h>
4:                 
5:                 
6:                 void trajAddTranslation(float acc, float vel, float length) {
003728  FA0014     LNK #0x14
00372A  980740     MOV W0, [W14+8]
00372C  980751     MOV W1, [W14+10]
00372E  980762     MOV W2, [W14+12]
003730  980773     MOV W3, [W14+14]
003732  980F04     MOV W4, [W14+16]
003734  980F15     MOV W5, [W14+18]
7:                 	relativeCoord tmp;
8:                 
9:                 	tmp.r = 0;
003736  B82260     MUL.UU W4, #0, W4
003738  980724     MOV W4, [W14+4]
00373A  980735     MOV W5, [W14+6]
10:                	tmp.l = acc;
00373C  90024E     MOV [W14+8], W4
00373E  9002DE     MOV [W14+10], W5
003740  BE8F04     MOV.D W4, [W14]
11:                	csgSetNomAcc(tmp);
003742  BE003E     MOV.D [W14++], W0
003744  BE012E     MOV.D [W14--], W2
003746  07EF24     RCALL csgSetNomAcc
12:                	tmp.l = vel;
003748  90026E     MOV [W14+12], W4
00374A  9002FE     MOV [W14+14], W5
00374C  BE8F04     MOV.D W4, [W14]
13:                	csgSetNomVel(tmp);
00374E  BE003E     MOV.D [W14++], W0
003750  BE012E     MOV.D [W14--], W2
003752  07EF3F     RCALL csgSetNomVel
14:                	tmp = csgGetPos();
003754  78000E     MOV W14, W0
003756  07EF58     RCALL csgGetPos
15:                	tmp.l += length;
003758  BE021E     MOV.D [W14], W4
00375A  90090E     MOV [W14+16], W2
00375C  90099E     MOV [W14+18], W3
00375E  BE0004     MOV.D W4, W0
003760  07E728     RCALL ___addsf3
003762  BE0200     MOV.D W0, W4
003764  BE8F04     MOV.D W4, [W14]
16:                	csgSetFinalPos(tmp);
003766  BE003E     MOV.D [W14++], W0
003768  BE012E     MOV.D [W14--], W2
00376A  07EF05     RCALL csgSetFinalPos
17:                }
00376C  FA8000     ULNK
00376E  060000     RETURN
18:                
19:                
20:                void trajAddRotation(float acc, float vel, float length) {
003770  FA0014     LNK #0x14
003772  980740     MOV W0, [W14+8]
003774  980751     MOV W1, [W14+10]
003776  980762     MOV W2, [W14+12]
003778  980773     MOV W3, [W14+14]
00377A  980F04     MOV W4, [W14+16]
00377C  980F15     MOV W5, [W14+18]
21:                	relativeCoord tmp;
22:                
23:                	tmp.l = 0;
00377E  B82260     MUL.UU W4, #0, W4
003780  BE8F04     MOV.D W4, [W14]
24:                	tmp.r = acc;
003782  90024E     MOV [W14+8], W4
003784  9002DE     MOV [W14+10], W5
003786  980724     MOV W4, [W14+4]
003788  980735     MOV W5, [W14+6]
25:                	csgSetNomAcc(tmp);
00378A  BE003E     MOV.D [W14++], W0
00378C  BE012E     MOV.D [W14--], W2
00378E  07EF00     RCALL csgSetNomAcc
26:                	tmp.r = vel;
003790  90026E     MOV [W14+12], W4
003792  9002FE     MOV [W14+14], W5
003794  980724     MOV W4, [W14+4]
003796  980735     MOV W5, [W14+6]
27:                	csgSetNomVel(tmp);
003798  BE003E     MOV.D [W14++], W0
00379A  BE012E     MOV.D [W14--], W2
00379C  07EF1A     RCALL csgSetNomVel
28:                	tmp = csgGetPos();
00379E  78000E     MOV W14, W0
0037A0  07EF33     RCALL csgGetPos
29:                	tmp.r += length;
0037A2  90022E     MOV [W14+4], W4
0037A4  9002BE     MOV [W14+6], W5
0037A6  90090E     MOV [W14+16], W2
0037A8  90099E     MOV [W14+18], W3
0037AA  BE0004     MOV.D W4, W0
0037AC  07E702     RCALL ___addsf3
0037AE  BE0200     MOV.D W0, W4
0037B0  980724     MOV W4, [W14+4]
0037B2  980735     MOV W5, [W14+6]
30:                	csgSetFinalPos(tmp);
0037B4  BE003E     MOV.D [W14++], W0
0037B6  BE012E     MOV.D [W14--], W2
0037B8  07EEDE     RCALL csgSetFinalPos
31:                }
0037BA  FA8000     ULNK
0037BC  060000     RETURN
32:                
33:                
34:                void trajStopNow(void) {
0037BE  FA0018     LNK #0x18
0037C0  BE9F88     MOV.D W8, [W15++]
0037C2  BE9F8A     MOV.D W10, [W15++]
35:                	relativeCoord vel, acc, pos;
36:                
37:                	vel = csgGetVel();
0037C4  78000E     MOV W14, W0
0037C6  07EF12     RCALL csgGetVel
38:                	acc = csgGetNomAcc();
0037C8  470268     ADD W14, #0x8, W4
0037CA  780004     MOV W4, W0
0037CC  07EF39     RCALL csgGetNomAcc
39:                	pos = csgGetPos();
0037CE  470270     ADD W14, #0x10, W4
0037D0  780004     MOV W4, W0
0037D2  07EF1A     RCALL csgGetPos
40:                	if (vel.l >0) {
0037D4  BE021E     MOV.D [W14], W4
0037D6  B3C018     MOV #0x1, W8
0037D8  B81160     MUL.UU W2, #0, W2
0037DA  BE0004     MOV.D W4, W0
0037DC  07E5C1     RCALL ___gtsf2
0037DE  780200     MOV W0, W4
0037E0  520FE0     SUB W4, #0x0, [W15]
0037E2  3C0001     BRA GT, 0x37E6
0037E4  EB4400     CLR.B W8
0037E6  544FE0     SUB.B W8, #0x0, [W15]
0037E8  32001A     BRA Z, 0x381E
41:                		pos.l += vel.l*vel.l/(2*acc.l);
0037EA  900C0E     MOV [W14+16], W8
0037EC  900C9E     MOV [W14+18], W9
0037EE  BE031E     MOV.D [W14], W6
0037F0  BE021E     MOV.D [W14], W4
0037F2  BE0104     MOV.D W4, W2
0037F4  BE0006     MOV.D W6, W0
0037F6  07E7C2     RCALL ___mulsf3
0037F8  BE0200     MOV.D W0, W4
0037FA  BE0504     MOV.D W4, W10
0037FC  90024E     MOV [W14+8], W4
0037FE  9002DE     MOV [W14+10], W5
003800  BE0104     MOV.D W4, W2
003802  BE0004     MOV.D W4, W0
003804  07E6D6     RCALL ___addsf3
003806  BE0200     MOV.D W0, W4
003808  BE0104     MOV.D W4, W2
00380A  BE000A     MOV.D W10, W0
00380C  07E8E7     RCALL ___divsf3x
00380E  BE0200     MOV.D W0, W4
003810  BE0104     MOV.D W4, W2
003812  BE0008     MOV.D W8, W0
003814  07E6CE     RCALL ___addsf3
003816  BE0200     MOV.D W0, W4
003818  980F04     MOV W4, [W14+16]
00381A  980F15     MOV W5, [W14+18]
00381C  370019     BRA 0x3850
42:                	} else{
43:                		pos.l -= vel.l*vel.l/(2*acc.l);
00381E  900C0E     MOV [W14+16], W8
003820  900C9E     MOV [W14+18], W9
003822  BE031E     MOV.D [W14], W6
003824  BE021E     MOV.D [W14], W4
003826  BE0104     MOV.D W4, W2
003828  BE0006     MOV.D W6, W0
00382A  07E7A8     RCALL ___mulsf3
00382C  BE0200     MOV.D W0, W4
00382E  BE0504     MOV.D W4, W10
003830  90024E     MOV [W14+8], W4
003832  9002DE     MOV [W14+10], W5
003834  BE0104     MOV.D W4, W2
003836  BE0004     MOV.D W4, W0
003838  07E6BC     RCALL ___addsf3
00383A  BE0200     MOV.D W0, W4
00383C  BE0104     MOV.D W4, W2
00383E  BE000A     MOV.D W10, W0
003840  07E8CD     RCALL ___divsf3x
003842  BE0200     MOV.D W0, W4
003844  BE0104     MOV.D W4, W2
003846  BE0008     MOV.D W8, W0
003848  07E6AB     RCALL ___subsf3
00384A  BE0200     MOV.D W0, W4
00384C  980F04     MOV W4, [W14+16]
00384E  980F15     MOV W5, [W14+18]
44:                	}
45:                	if (vel.r >0) {
003850  90022E     MOV [W14+4], W4
003852  9002BE     MOV [W14+6], W5
003854  B3C018     MOV #0x1, W8
003856  B81160     MUL.UU W2, #0, W2
003858  BE0004     MOV.D W4, W0
00385A  07E582     RCALL ___gtsf2
00385C  780200     MOV W0, W4
00385E  520FE0     SUB W4, #0x0, [W15]
003860  3C0001     BRA GT, 0x3864
003862  EB4400     CLR.B W8
003864  544FE0     SUB.B W8, #0x0, [W15]
003866  32001C     BRA Z, 0x38A0
46:                		pos.r += vel.r*vel.r/(2*acc.r);
003868  900C2E     MOV [W14+20], W8
00386A  900CBE     MOV [W14+22], W9
00386C  90032E     MOV [W14+4], W6
00386E  9003BE     MOV [W14+6], W7
003870  90022E     MOV [W14+4], W4
003872  9002BE     MOV [W14+6], W5
003874  BE0104     MOV.D W4, W2
003876  BE0006     MOV.D W6, W0
003878  07E781     RCALL ___mulsf3
00387A  BE0200     MOV.D W0, W4
00387C  BE0504     MOV.D W4, W10
00387E  90026E     MOV [W14+12], W4
003880  9002FE     MOV [W14+14], W5
003882  BE0104     MOV.D W4, W2
003884  BE0004     MOV.D W4, W0
003886  07E695     RCALL ___addsf3
003888  BE0200     MOV.D W0, W4
00388A  BE0104     MOV.D W4, W2
00388C  BE000A     MOV.D W10, W0
00388E  07E8A6     RCALL ___divsf3x
003890  BE0200     MOV.D W0, W4
003892  BE0104     MOV.D W4, W2
003894  BE0008     MOV.D W8, W0
003896  07E68D     RCALL ___addsf3
003898  BE0200     MOV.D W0, W4
00389A  980F24     MOV W4, [W14+20]
00389C  980F35     MOV W5, [W14+22]
00389E  37001B     BRA 0x38D6
47:                	} else{
48:                		pos.r -= vel.r*vel.r/(2*acc.r);
0038A0  900C2E     MOV [W14+20], W8
0038A2  900CBE     MOV [W14+22], W9
0038A4  90032E     MOV [W14+4], W6
0038A6  9003BE     MOV [W14+6], W7
0038A8  90022E     MOV [W14+4], W4
0038AA  9002BE     MOV [W14+6], W5
0038AC  BE0104     MOV.D W4, W2
0038AE  BE0006     MOV.D W6, W0
0038B0  07E765     RCALL ___mulsf3
0038B2  BE0200     MOV.D W0, W4
0038B4  BE0504     MOV.D W4, W10
0038B6  90026E     MOV [W14+12], W4
0038B8  9002FE     MOV [W14+14], W5
0038BA  BE0104     MOV.D W4, W2
0038BC  BE0004     MOV.D W4, W0
0038BE  07E679     RCALL ___addsf3
0038C0  BE0200     MOV.D W0, W4
0038C2  BE0104     MOV.D W4, W2
0038C4  BE000A     MOV.D W10, W0
0038C6  07E88A     RCALL ___divsf3x
0038C8  BE0200     MOV.D W0, W4
0038CA  BE0104     MOV.D W4, W2
0038CC  BE0008     MOV.D W8, W0
0038CE  07E668     RCALL ___subsf3
0038D0  BE0200     MOV.D W0, W4
0038D2  980F24     MOV W4, [W14+20]
0038D4  980F35     MOV W5, [W14+22]
49:                	}
50:                	csgSetFinalPos(pos);
0038D6  90080E     MOV [W14+16], W0
0038D8  90089E     MOV [W14+18], W1
0038DA  90092E     MOV [W14+20], W2
0038DC  9009BE     MOV [W14+22], W3
0038DE  07EE4B     RCALL csgSetFinalPos
51:                }
0038E0  BE054F     MOV.D [--W15], W10
0038E2  BE044F     MOV.D [--W15], W8
0038E4  FA8000     ULNK
0038E6  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/odoLibre.c  ------------------------------------------
1:                 #include "Configware.h"
2:                 #include "globals.h"
3:                 #include "constantes.h"
4:                 #include "odoLibre.h"
5:                 #include "../Peripherals/pps.h"
6:                 #include "../Peripherals/timers.h"
7:                 #include <math.h>
8:                 #include <xc.h>
9:                 
10:                
11:                
12:                #define ODO_POS_TICK_TO_M		(PI*ODO_WHEEL_DIAMETER/ODO_PULSES_PER_WHEEL_REVOLUTION/2)
13:                #define ODO_POS_TICK_TO_RAD		(PI*ODO_WHEEL_DIAMETER/ODO_PULSES_PER_WHEEL_REVOLUTION/ODO_AXLE_LENGTH)
14:                #define ODO_REG_R				(POS1CNT)
15:                #define ODO_REG_L				(POS2CNT)
16:                
17:                
18:                volatile position prOdoAbsPos;					// position calculée par odométrie libre
19:                volatile relativeCoord prOdoRelVel, prOdoRelPos;
20:                
21:                
22:                void odoInit(void) {
00309C  FA0000     LNK #0x0
23:                	// assignation des I/Os du QEI1 (encodeur de droite)
24:                	ppsInConfig(PPS_QEA1, 19);	// RP19 -> QEIA1 (ODO_RA)
00309E  200131     MOV #0x13, W1
0030A0  2000C0     MOV #0xC, W0
0030A2  07FC39     RCALL ppsInConfig
25:                	ppsInConfig(PPS_QEB1, 20);	// RP20 -> QEIB1 (ODO_RB)
0030A4  200141     MOV #0x14, W1
0030A6  2000D0     MOV #0xD, W0
0030A8  07FC36     RCALL ppsInConfig
26:                	// assignation des I/Os du QEI2 (encodeur de gauche)
27:                	ppsInConfig(PPS_QEA2, 6);	// RP6 -> QEIA2  (ODO_LA)
0030AA  200061     MOV #0x6, W1
0030AC  2000E0     MOV #0xE, W0
0030AE  07FC33     RCALL ppsInConfig
28:                	ppsInConfig(PPS_QEB2, 7);	// RP7 -> QEIB2  (ODO_LB)
0030B0  200071     MOV #0x7, W1
0030B2  2000F0     MOV #0xF, W0
0030B4  07FC30     RCALL ppsInConfig
29:                	prOdoRelVel.l = 0;
0030B6  208DA6     MOV #0x8DA, W6
0030B8  B82260     MUL.UU W4, #0, W4
0030BA  BE8B04     MOV.D W4, [W6]
30:                	prOdoRelVel.r = 0;
0030BC  208DA6     MOV #0x8DA, W6
0030BE  B82260     MUL.UU W4, #0, W4
0030C0  980324     MOV W4, [W6+4]
0030C2  980335     MOV W5, [W6+6]
31:                	prOdoRelPos.l = 0;
0030C4  208E26     MOV #0x8E2, W6
0030C6  B82260     MUL.UU W4, #0, W4
0030C8  BE8B04     MOV.D W4, [W6]
32:                	prOdoRelPos.r = 0;
0030CA  208E26     MOV #0x8E2, W6
0030CC  B82260     MUL.UU W4, #0, W4
0030CE  980324     MOV W4, [W6+4]
0030D0  980335     MOV W5, [W6+6]
33:                	// right
34:                	QEI1CONbits.CNTERR = 0;
0030D2  A9E1E1     BCLR 0x1E1, #7
35:                	QEI1CONbits.QEIM2 = 1;		// configure le module encodeur en mode 4x, interruption par l'entrée index
0030D4  A841E1     BSET 0x1E1, #2
36:                	QEI1CONbits.QEIM1 = 1;
0030D6  A821E1     BSET 0x1E1, #1
37:                	QEI1CONbits.QEIM0 = 0;
0030D8  A901E1     BCLR 0x1E1, #0
38:                	QEI1CONbits.POSRES = 0;		// reset par l'entrée index désactivée
0030DA  A941E0     BCLR QEI1CON, #2
39:                	QEI1CONbits.SWPAB = 1;		// définit le sens positif de comptage
0030DC  A8E1E0     BSET QEI1CON, #7
40:                	ODO_REG_R = 0;				// initialise le compteur du QEI
0030DE  EB0200     CLR W4
0030E0  880F24     MOV W4, POS1CNT
41:                	// left
42:                	QEI2CONbits.CNTERR = 0;
0030E2  A9E1F1     BCLR 0x1F1, #7
43:                	QEI2CONbits.QEIM2 = 1;		// configure le module encodeur en mode 4x, interruption par l'entrée index
0030E4  A841F1     BSET 0x1F1, #2
44:                	QEI2CONbits.QEIM1 = 1;
0030E6  A821F1     BSET 0x1F1, #1
45:                	QEI2CONbits.QEIM0 = 0;
0030E8  A901F1     BCLR 0x1F1, #0
46:                	QEI2CONbits.POSRES = 0;		// reset par l'entrée index désactivée
0030EA  A941F0     BCLR QEI2CON, #2
47:                	QEI2CONbits.SWPAB = 0;		// définit le sens positif de comptage
0030EC  A9E1F0     BCLR QEI2CON, #7
48:                	ODO_REG_L = 0;				// initialise le compteur du QEI
0030EE  EB0200     CLR W4
0030F0  880FA4     MOV W4, POS2CNT
49:                	prOdoAbsPos.x = 0;
0030F2  B82260     MUL.UU W4, #0, W4
0030F4  884674     MOV W4, prOdoAbsPos
0030F6  884685     MOV W5, 0x8D0
50:                	prOdoAbsPos.y = 0;
0030F8  B82260     MUL.UU W4, #0, W4
0030FA  884694     MOV W4, 0x8D2
0030FC  8846A5     MOV W5, 0x8D4
51:                	prOdoAbsPos.alpha = 0;
0030FE  B82260     MUL.UU W4, #0, W4
003100  8846B4     MOV W4, 0x8D6
003102  8846C5     MOV W5, 0x8D8
52:                }
003104  FA8000     ULNK
003106  060000     RETURN
53:                
54:                
55:                inline void calculeOdometrie(void) {
003108  FA0014     LNK #0x14
00310A  BE9F88     MOV.D W8, [W15++]
56:                	static int prOdoOldLeftCnt = 0, prOdoOldRightcnt = 0;
57:                	int leftVel, rightVel;
58:                	int tmpLeft, tmpRight;
59:                	float tmpFloat, dT, dR;
60:                
61:                	// on commence par lire les nouvelles valeurs des encodeurs, pour obtenir le meilleur
62:                	// synchronisme possible ; on fera les calculs après
63:                	tmpLeft = ODO_REG_L;
00310C  800FA4     MOV POS2CNT, W4
00310E  780F04     MOV W4, [W14]
64:                	tmpRight = ODO_REG_R;
003110  800F24     MOV POS1CNT, W4
003112  980714     MOV W4, [W14+2]
65:                	leftVel = tmpLeft - prOdoOldLeftCnt;
003114  804754     MOV prOdoOldLeftCnt, W4
003116  12021E     SUBR W4, [W14], W4
003118  980724     MOV W4, [W14+4]
66:                	rightVel = tmpRight - prOdoOldRightcnt;
00311A  804764     MOV prOdoOldRightcnt, W4
00311C  90029E     MOV [W14+2], W5
00311E  528204     SUB W5, W4, W4
003120  980734     MOV W4, [W14+6]
67:                	prOdoOldLeftCnt = tmpLeft;
003122  78021E     MOV [W14], W4
003124  884754     MOV W4, prOdoOldLeftCnt
68:                	prOdoOldRightcnt = tmpRight;
003126  90021E     MOV [W14+2], W4
003128  884764     MOV W4, prOdoOldRightcnt
69:                	//on mesure les delta d'avance et d'angle
70:                	dT = (ODO_CORRECTION_DROITE*rightVel + ODO_CORRECTION_GAUCHE*leftVel)*ODO_POS_TICK_TO_M;
00312A  90023E     MOV [W14+6], W4
00312C  DEA2CF     ASR W4, #15, W5
00312E  BE0004     MOV.D W4, W0
003130  07E955     RCALL ___floatsisf
003132  BE0200     MOV.D W0, W4
003134  2BE772     MOV #0xBE77, W2
003136  23F7F3     MOV #0x3F7F, W3
003138  BE0004     MOV.D W4, W0
00313A  07EB20     RCALL ___mulsf3
00313C  BE0200     MOV.D W0, W4
00313E  BE0404     MOV.D W4, W8
003140  90022E     MOV [W14+4], W4
003142  DEA2CF     ASR W4, #15, W5
003144  BE0004     MOV.D W4, W0
003146  07E94A     RCALL ___floatsisf
003148  BE0200     MOV.D W0, W4
00314A  220C52     MOV #0x20C5, W2
00314C  23F803     MOV #0x3F80, W3
00314E  BE0004     MOV.D W4, W0
003150  07EB15     RCALL ___mulsf3
003152  BE0200     MOV.D W0, W4
003154  BE0104     MOV.D W4, W2
003156  BE0008     MOV.D W8, W0
003158  07EA2C     RCALL ___addsf3
00315A  BE0200     MOV.D W0, W4
00315C  2C5A52     MOV #0xC5A5, W2
00315E  237993     MOV #0x3799, W3
003160  BE0004     MOV.D W4, W0
003162  07EB0C     RCALL ___mulsf3
003164  BE0200     MOV.D W0, W4
003166  980744     MOV W4, [W14+8]
003168  980755     MOV W5, [W14+10]
71:                	dR = (ODO_CORRECTION_DROITE*rightVel - ODO_CORRECTION_GAUCHE*leftVel)*ODO_POS_TICK_TO_RAD;
00316A  90023E     MOV [W14+6], W4
00316C  DEA2CF     ASR W4, #15, W5
00316E  BE0004     MOV.D W4, W0
003170  07E935     RCALL ___floatsisf
003172  BE0200     MOV.D W0, W4
003174  2BE772     MOV #0xBE77, W2
003176  23F7F3     MOV #0x3F7F, W3
003178  BE0004     MOV.D W4, W0
00317A  07EB00     RCALL ___mulsf3
00317C  BE0200     MOV.D W0, W4
00317E  BE0404     MOV.D W4, W8
003180  90022E     MOV [W14+4], W4
003182  DEA2CF     ASR W4, #15, W5
003184  BE0004     MOV.D W4, W0
003186  07E92A     RCALL ___floatsisf
003188  BE0200     MOV.D W0, W4
00318A  220C52     MOV #0x20C5, W2
00318C  23F803     MOV #0x3F80, W3
00318E  BE0004     MOV.D W4, W0
003190  07EAF5     RCALL ___mulsf3
003192  BE0200     MOV.D W0, W4
003194  BE0104     MOV.D W4, W2
003196  BE0008     MOV.D W8, W0
003198  07EA03     RCALL ___subsf3
00319A  BE0200     MOV.D W0, W4
00319C  2C4CC2     MOV #0xC4CC, W2
00319E  2396B3     MOV #0x396B, W3
0031A0  BE0004     MOV.D W4, W0
0031A2  07EAEC     RCALL ___mulsf3
0031A4  BE0200     MOV.D W0, W4
0031A6  980764     MOV W4, [W14+12]
0031A8  980775     MOV W5, [W14+14]
72:                	// Compute new position version 3 (corde de l'arc de cercle)
73:                	tmpFloat = (prOdoAbsPos.alpha + dR/2)*DEG2RAD;
0031AA  8046B8     MOV 0x8D6, W8
0031AC  8046C9     MOV 0x8D8, W9
0031AE  200002     MOV #0x0, W2
0031B0  240003     MOV #0x4000, W3
0031B2  90006E     MOV [W14+12], W0
0031B4  9000FE     MOV [W14+14], W1
0031B6  07EC12     RCALL ___divsf3x
0031B8  BE0200     MOV.D W0, W4
0031BA  BE0104     MOV.D W4, W2
0031BC  BE0008     MOV.D W8, W0
0031BE  07E9F9     RCALL ___addsf3
0031C0  BE0200     MOV.D W0, W4
0031C2  2FA2E2     MOV #0xFA2E, W2
0031C4  23C8E3     MOV #0x3C8E, W3
0031C6  BE0004     MOV.D W4, W0
0031C8  07EAD9     RCALL ___mulsf3
0031CA  BE0200     MOV.D W0, W4
0031CC  980F04     MOV W4, [W14+16]
0031CE  980F15     MOV W5, [W14+18]
74:                	prOdoAbsPos.x += dT*cos(tmpFloat);
0031D0  804678     MOV prOdoAbsPos, W8
0031D2  804689     MOV 0x8D0, W9
0031D4  90080E     MOV [W14+16], W0
0031D6  90089E     MOV [W14+18], W1
0031D8  07E97C     RCALL _cosfx
0031DA  BE0200     MOV.D W0, W4
0031DC  90014E     MOV [W14+8], W2
0031DE  9001DE     MOV [W14+10], W3
0031E0  BE0004     MOV.D W4, W0
0031E2  07EACC     RCALL ___mulsf3
0031E4  BE0200     MOV.D W0, W4
0031E6  BE0104     MOV.D W4, W2
0031E8  BE0008     MOV.D W8, W0
0031EA  07E9E3     RCALL ___addsf3
0031EC  BE0200     MOV.D W0, W4
0031EE  884674     MOV W4, prOdoAbsPos
0031F0  884685     MOV W5, 0x8D0
75:                	prOdoAbsPos.y += dT*sin(tmpFloat);
0031F2  804698     MOV 0x8D2, W8
0031F4  8046A9     MOV 0x8D4, W9
0031F6  90080E     MOV [W14+16], W0
0031F8  90089E     MOV [W14+18], W1
0031FA  07E90A     RCALL _sinfx
0031FC  BE0200     MOV.D W0, W4
0031FE  90014E     MOV [W14+8], W2
003200  9001DE     MOV [W14+10], W3
003202  BE0004     MOV.D W4, W0
003204  07EABB     RCALL ___mulsf3
003206  BE0200     MOV.D W0, W4
003208  BE0104     MOV.D W4, W2
00320A  BE0008     MOV.D W8, W0
00320C  07E9D2     RCALL ___addsf3
00320E  BE0200     MOV.D W0, W4
003210  884694     MOV W4, 0x8D2
003212  8846A5     MOV W5, 0x8D4
76:                	prOdoAbsPos.alpha = satureAngle(prOdoAbsPos.alpha + dR);
003214  8046B4     MOV 0x8D6, W4
003216  8046C5     MOV 0x8D8, W5
003218  90016E     MOV [W14+12], W2
00321A  9001FE     MOV [W14+14], W3
00321C  BE0004     MOV.D W4, W0
00321E  07E9C9     RCALL ___addsf3
003220  BE0200     MOV.D W0, W4
003222  BE0004     MOV.D W4, W0
003224  070448     RCALL satureAngle
003226  BE0200     MOV.D W0, W4
003228  8846B4     MOV W4, 0x8D6
00322A  8846C5     MOV W5, 0x8D8
77:                	prOdoRelPos.l += dT;
00322C  208E24     MOV #0x8E2, W4
00322E  BE0214     MOV.D [W4], W4
003230  90014E     MOV [W14+8], W2
003232  9001DE     MOV [W14+10], W3
003234  BE0004     MOV.D W4, W0
003236  07E9BD     RCALL ___addsf3
003238  BE0200     MOV.D W0, W4
00323A  208E26     MOV #0x8E2, W6
00323C  BE8B04     MOV.D W4, [W6]
78:                	prOdoRelPos.r += dR;
00323E  208E24     MOV #0x8E2, W4
003240  9002B4     MOV [W4+6], W5
003242  900224     MOV [W4+4], W4
003244  90016E     MOV [W14+12], W2
003246  9001FE     MOV [W14+14], W3
003248  BE0004     MOV.D W4, W0
00324A  07E9B3     RCALL ___addsf3
00324C  BE0200     MOV.D W0, W4
00324E  208E26     MOV #0x8E2, W6
003250  980324     MOV W4, [W6+4]
003252  980335     MOV W5, [W6+6]
79:                	prOdoRelVel.l = dT * SAMPLE_FREQ;
003254  200002     MOV #0x0, W2
003256  242C83     MOV #0x42C8, W3
003258  90004E     MOV [W14+8], W0
00325A  9000DE     MOV [W14+10], W1
00325C  07EA8F     RCALL ___mulsf3
00325E  BE0200     MOV.D W0, W4
003260  208DA6     MOV #0x8DA, W6
003262  BE8B04     MOV.D W4, [W6]
80:                	prOdoRelVel.r = dR * SAMPLE_FREQ;
003264  200002     MOV #0x0, W2
003266  242C83     MOV #0x42C8, W3
003268  90006E     MOV [W14+12], W0
00326A  9000FE     MOV [W14+14], W1
00326C  07EA87     RCALL ___mulsf3
00326E  BE0200     MOV.D W0, W4
003270  208DA6     MOV #0x8DA, W6
003272  980324     MOV W4, [W6+4]
003274  980335     MOV W5, [W6+6]
81:                }
003276  BE044F     MOV.D [--W15], W8
003278  FA8000     ULNK
00327A  060000     RETURN
82:                
83:                
84:                inline relativeCoord odoGetRelVel(void) {
00327C  FA0000     LNK #0x0
00327E  BE9F88     MOV.D W8, [W15++]
003280  BE9F8A     MOV.D W10, [W15++]
003282  780200     MOV W0, W4
85:                    return prOdoRelVel;
003284  208DA5     MOV #0x8DA, W5
003286  BE0435     MOV.D [W5++], W8
003288  BE0525     MOV.D [W5--], W10
00328A  BE9A08     MOV.D W8, [W4++]
00328C  BE920A     MOV.D W10, [W4--]
86:                }
00328E  780004     MOV W4, W0
003290  BE054F     MOV.D [--W15], W10
003292  BE044F     MOV.D [--W15], W8
003294  FA8000     ULNK
003296  060000     RETURN
87:                
88:                inline relativeCoord odoGetRelPos(void) {
003298  FA0000     LNK #0x0
00329A  BE9F88     MOV.D W8, [W15++]
00329C  BE9F8A     MOV.D W10, [W15++]
00329E  780200     MOV W0, W4
89:                    return prOdoRelPos;
0032A0  208E25     MOV #0x8E2, W5
0032A2  BE0435     MOV.D [W5++], W8
0032A4  BE0525     MOV.D [W5--], W10
0032A6  BE9A08     MOV.D W8, [W4++]
0032A8  BE920A     MOV.D W10, [W4--]
90:                }
0032AA  780004     MOV W4, W0
0032AC  BE054F     MOV.D [--W15], W10
0032AE  BE044F     MOV.D [--W15], W8
0032B0  FA8000     ULNK
0032B2  060000     RETURN
91:                
92:                inline position odoGetAbsPos(void) {
0032B4  FA0000     LNK #0x0
0032B6  780300     MOV W0, W6
93:                    return prOdoAbsPos;
0032B8  208CE4     MOV #0x8CE, W4
0032BA  780286     MOV W6, W5
0032BC  781AB4     MOV [W4++], [W5++]
0032BE  7812A4     MOV [W4--], [W5--]
0032C0  4282E4     ADD W5, #0x4, W5
0032C2  420264     ADD W4, #0x4, W4
0032C4  781AB4     MOV [W4++], [W5++]
0032C6  7812A4     MOV [W4--], [W5--]
0032C8  4282E4     ADD W5, #0x4, W5
0032CA  420264     ADD W4, #0x4, W4
0032CC  781AB4     MOV [W4++], [W5++]
0032CE  7812A4     MOV [W4--], [W5--]
0032D0  4282E4     ADD W5, #0x4, W5
0032D2  420264     ADD W4, #0x4, W4
94:                }
0032D4  780006     MOV W6, W0
0032D6  FA8000     ULNK
0032D8  060000     RETURN
95:                
96:                inline void odoSetAbsPos(position newPos) {
0032DA  FA000C     LNK #0xC
0032DC  780F00     MOV W0, [W14]
0032DE  980711     MOV W1, [W14+2]
0032E0  980722     MOV W2, [W14+4]
0032E2  980733     MOV W3, [W14+6]
0032E4  980744     MOV W4, [W14+8]
0032E6  980755     MOV W5, [W14+10]
97:                    prOdoAbsPos.x = newPos.x;
0032E8  BE021E     MOV.D [W14], W4
0032EA  884674     MOV W4, prOdoAbsPos
0032EC  884685     MOV W5, 0x8D0
98:                    prOdoAbsPos.y = newPos.y;
0032EE  90022E     MOV [W14+4], W4
0032F0  9002BE     MOV [W14+6], W5
0032F2  884694     MOV W4, 0x8D2
0032F4  8846A5     MOV W5, 0x8D4
99:                	prOdoAbsPos.alpha = satureAngle(newPos.alpha);
0032F6  90024E     MOV [W14+8], W4
0032F8  9002DE     MOV [W14+10], W5
0032FA  BE0004     MOV.D W4, W0
0032FC  0703DC     RCALL satureAngle
0032FE  BE0200     MOV.D W0, W4
003300  8846B4     MOV W4, 0x8D6
003302  8846C5     MOV W5, 0x8D8
100:               }
003304  FA8000     ULNK
003306  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/main.c  ----------------------------------------------
1:                 #include "Configware.h"				//<! Contient la configuration globale du PIC : clock, GPIO
2:                 #include "motors.h"
3:                 #include "Regulator.h"
4:                 #include "odoLibre.h"
5:                 #include "consigne.h"
6:                 #include "trajectoire.h"
7:                 #include "canCommand.h"
8:                 #include "../CanLib/CanDspic.h"
9:                 #include "../CanLib/CanNetwork.h"
10:                #include "../CanLib/CanProp.h"
11:                #include "../Peripherals/timers.h"
12:                
13:                
14:                //#define DEBUG_MODE		// Flag permettant de simuler le code en enlevant les parties liées au CAN
15:                
16:                
17:                positionInteger odoPhysPos;		//! position actuelle du robot, en mm et deg/10
18:                volatile int isrRegFlag, isrCsgFlag;
19:                
20:                void propInterrupt(void) {
00351C  FA0000     LNK #0x0
21:                	calculeOdometrie();		// on calcule la position absolue mesurée avec les encodeurs libres
00351E  07FDF4     RCALL calculeOdometrie
22:                	if (isrCsgFlag) {
003520  804804     MOV isrCsgFlag, W4
003522  520FE0     SUB W4, #0x0, [W15]
003524  320001     BRA Z, 0x3528
23:                		csgCompute();			// on calcule la nouvelle consigne
003526  07F0AD     RCALL csgCompute
24:                	}
25:                	if (isrRegFlag) {
003528  8047F4     MOV isrRegFlag, W4
00352A  520FE0     SUB W4, #0x0, [W15]
00352C  320001     BRA Z, 0x3530
26:                		regCompute();			// on exécute le régulateur de position+vitesse
00352E  07FEF5     RCALL regCompute
27:                	}
28:                }
003530  FA8000     ULNK
003532  060000     RETURN
29:                
30:                ///////////////////////////////////////////////////////////////////////////////////////////////////
31:                //	MAIN FUNCTION
32:                ///////////////////////////////////////////////////////////////////////////////////////////////////
33:                int main(void) {
003534  FA0028     LNK #0x28
34:                	propStateType state, newState;	//! Etat de la machine d'état de la propulsion
35:                	propStateType oldState;			//! dernière valeur de l'état envoyée sur le CAN
36:                	relativeCoord nomVel;			//! vitesse nominale initiale du robot
37:                	relativeCoord nomAcc;			//! Accélération nominale initiale du robot
38:                
39:                	
40:                	pllConfig();		// configure l'horloge de PIC
003536  0702EB     RCALL pllConfig
41:                	canPinAssign();		// assigne les pattes du CAN
003538  07030C     RCALL canPinAssign
42:                	motorsInit();		// initialise les périphériques PWM pour le contrôle des moteurs
00353A  0701D6     RCALL motorsInit
43:                	odoInit();			// initialise les périphériques QEI pour la mesure des encodeurs
00353C  07FDAF     RCALL odoInit
44:                	regInit();			// initialise les régulateurs de vitesses et positions
00353E  07FEE4     RCALL regInit
45:                	state = DISABLED;	// initialisation de la machine d'état
003540  EB0200     CLR W4
003542  980F04     MOV W4, [W14+16]
46:                	oldState = state;
003544  900A0E     MOV [W14+16], W4
003546  980714     MOV W4, [W14+2]
47:                	nomVel.l = 1;		// m/s
003548  200004     MOV #0x0, W4
00354A  23F805     MOV #0x3F80, W5
00354C  980F14     MOV W4, [W14+18]
00354E  980F25     MOV W5, [W14+20]
48:                	nomVel.r = 80;		// rad/s
003550  200004     MOV #0x0, W4
003552  242A05     MOV #0x42A0, W5
003554  980F34     MOV W4, [W14+22]
003556  980F45     MOV W5, [W14+24]
49:                	nomAcc.l = 1;		// m/s^2
003558  200004     MOV #0x0, W4
00355A  23F805     MOV #0x3F80, W5
00355C  980F54     MOV W4, [W14+26]
00355E  980F65     MOV W5, [W14+28]
50:                	nomAcc.r = 80;		// rad/s^2
003560  200004     MOV #0x0, W4
003562  242A05     MOV #0x42A0, W5
003564  980F74     MOV W4, [W14+30]
003566  981705     MOV W5, [W14+32]
51:                	csgInit(nomVel,nomAcc);
003568  900A5E     MOV [W14+26], W4
00356A  900AEE     MOV [W14+28], W5
00356C  900B7E     MOV [W14+30], W6
00356E  90138E     MOV [W14+32], W7
003570  90081E     MOV [W14+18], W0
003572  9008AE     MOV [W14+20], W1
003574  90093E     MOV [W14+22], W2
003576  9009CE     MOV [W14+24], W3
003578  07EFB7     RCALL csgInit
52:                #ifndef DEBUG_MODE
53:                	CanInitialisation(CN_PROPULSION);	// Initialise le périphérique CAN
00357A  B3C020     MOV #0x2, W0
00357C  07F448     RCALL CanInitialisation
54:                	ACTIVATE_CAN_INTERRUPTS = 1;	    // Enables CAN interrupts
00357E  A86098     BSET IEC2, #3
55:                	// Déclare les objets CAN produits par ce PIC
56:                	CanDeclarationProduction(CO_PROP_POS, &odoPhysPos, sizeof(odoPhysPos));
003580  B3C062     MOV #0x6, W2
003582  208F81     MOV #0x8F8, W1
003584  B3C220     MOV #0x22, W0
003586  07F34B     RCALL CanDeclarationProduction
57:                	CanDeclarationProduction(CO_PROP_STATUS, &state, sizeof(state));
003588  470270     ADD W14, #0x10, W4
00358A  B3C022     MOV #0x2, W2
00358C  780084     MOV W4, W1
00358E  B3C200     MOV #0x20, W0
003590  07F346     RCALL CanDeclarationProduction
58:                	CanEnvoiProduction(&state);
003592  470270     ADD W14, #0x10, W4
003594  780004     MOV W4, W0
003596  07F3D3     RCALL CanEnvoiProduction
59:                #endif
60:                	isrRegFlag = 0;
003598  EB0200     CLR W4
00359A  8847F4     MOV W4, isrRegFlag
61:                	isrCsgFlag = 0;
00359C  EB0200     CLR W4
00359E  884804     MOV W4, isrCsgFlag
62:                	timerSetup(TIMER_1, 10);		// Configuration du timer1 pour avoir une base de temps de 10ms
0035A0  200002     MOV #0x0, W2
0035A2  241203     MOV #0x4120, W3
0035A4  200010     MOV #0x1, W0
0035A6  07F61A     RCALL timerSetup
63:                	timerInterrupt(TIMER_1, &propInterrupt);
0035A8  2351C1     MOV #0x351C, W1
0035AA  200010     MOV #0x1, W0
0035AC  07F7A8     RCALL timerInterrupt
64:                	timerStart(TIMER_1);
0035AE  200010     MOV #0x1, W0
0035B0  07F746     RCALL timerStart
0035B2  370001     BRA 0x35B6
65:                	while(1) {
66:                		switch (state) {
0035B6  900A0E     MOV [W14+16], W4
0035B8  200005     MOV #0x0, W5
0035BA  200046     MOV #0x4, W6
0035BC  200007     MOV #0x0, W7
0035BE  520F86     SUB W4, W6, [W15]
0035C0  5A8F87     SUBB W5, W7, [W15]
0035C2  3E008C     BRA GTU, 0x36DC
0035C4  016004     BRA W4
0035C6  370004     BRA 0x35D0
0035C8  370023     BRA 0x3610
0035CA  37003B     BRA 0x3642
0035CC  370054     BRA 0x3676
0035CE  37006C     BRA 0x36A8
67:                			case DISABLED:
68:                				newState = canCommand(state);
0035D0  900A0E     MOV [W14+16], W4
0035D2  780004     MOV W4, W0
0035D4  07FC1F     RCALL canCommand
0035D6  780200     MOV W0, W4
0035D8  780F04     MOV W4, [W14]
69:                				switch(newState) {
0035DA  78021E     MOV [W14], W4
0035DC  520FE1     SUB W4, #0x1, [W15]
0035DE  320003     BRA Z, 0x35E6
0035E0  520FE3     SUB W4, #0x3, [W15]
0035E2  32000B     BRA Z, 0x35FA
70:                					case STANDING:
71:                						disableIsrTimer1();
0035E6  A96094     BCLR IEC0, #3
72:                						motorsEnable(); // on active les moteurs en entrant dans l'état STANDING
0035E8  0701AD     RCALL motorsEnable
73:                						isrRegFlag = 1;
0035EA  200014     MOV #0x1, W4
0035EC  8847F4     MOV W4, isrRegFlag
74:                						isrCsgFlag = 1;
0035EE  200014     MOV #0x1, W4
0035F0  884804     MOV W4, isrCsgFlag
75:                						enableIsrTimer1();
0035F2  A86094     BSET IEC0, #3
76:                						state = STANDING;
0035F4  200014     MOV #0x1, W4
0035F6  980F04     MOV W4, [W14+16]
77:                						break;
0035F8  37000A     BRA 0x360E
78:                					case TEST_STANDING:
79:                						disableIsrTimer1();
0035FA  A96094     BCLR IEC0, #3
80:                						motorsEnable(); // on active les moteurs en entrant dans l'état STANDING
0035FC  0701A3     RCALL motorsEnable
81:                						isrRegFlag = 0;
0035FE  EB0200     CLR W4
003600  8847F4     MOV W4, isrRegFlag
82:                						isrCsgFlag = 1;
003602  200014     MOV #0x1, W4
003604  884804     MOV W4, isrCsgFlag
83:                						enableIsrTimer1();
003606  A86094     BSET IEC0, #3
84:                						state = TEST_STANDING;
003608  200034     MOV #0x3, W4
00360A  980F04     MOV W4, [W14+16]
85:                						break;
00360C  000000     NOP
86:                					default:
87:                						break;
0035E4  370014     BRA 0x360E
88:                				}
89:                				break;
00360E  37006B     BRA 0x36E6
90:                			case STANDING:
91:                				newState = canCommand(state);	// on traite les ordres CAN
003610  900A0E     MOV [W14+16], W4
003612  780004     MOV W4, W0
003614  07FBFF     RCALL canCommand
003616  780200     MOV W0, W4
003618  780F04     MOV W4, [W14]
92:                				switch(newState) {
00361A  78021E     MOV [W14], W4
00361C  520FE0     SUB W4, #0x0, [W15]
00361E  320003     BRA Z, 0x3626
003620  520FE2     SUB W4, #0x2, [W15]
003622  32000B     BRA Z, 0x363A
93:                					case DISABLED:
94:                						disableIsrTimer1();
003626  A96094     BCLR IEC0, #3
95:                						motorsDisable();		// on désactive les moteurs en entrant dans l'état DISABLED
003628  0701A0     RCALL motorsDisable
96:                						isrRegFlag = 0;
00362A  EB0200     CLR W4
00362C  8847F4     MOV W4, isrRegFlag
97:                						isrCsgFlag = 0;
00362E  EB0200     CLR W4
003630  884804     MOV W4, isrCsgFlag
98:                						enableIsrTimer1();
003632  A86094     BSET IEC0, #3
99:                						state = DISABLED;
003634  EB0200     CLR W4
003636  980F04     MOV W4, [W14+16]
100:               						break;
003638  370003     BRA 0x3640
101:               					case MOVING:
102:               						state = MOVING;
00363A  200024     MOV #0x2, W4
00363C  980F04     MOV W4, [W14+16]
103:               						break;
00363E  000000     NOP
104:               					default:
105:               						break;
003624  37000D     BRA 0x3640
106:               				}
107:               				break;
003640  370052     BRA 0x36E6
108:               			case MOVING:
109:               				// TODO detection du patinage
110:               				newState = canCommand(state);			// on traite les ordres CAN
003642  900A0E     MOV [W14+16], W4
003644  780004     MOV W4, W0
003646  07FBE6     RCALL canCommand
003648  780200     MOV W0, W4
00364A  780F04     MOV W4, [W14]
111:               				switch(newState) {
00364C  78021E     MOV [W14], W4
00364E  520FE0     SUB W4, #0x0, [W15]
003650  3A000A     BRA NZ, 0x3666
112:               					case DISABLED:
113:               						disableIsrTimer1();
003652  A96094     BCLR IEC0, #3
114:               						motorsDisable();		// on désactive les moteurs en entrant dans l'état DISABLED
003654  07018A     RCALL motorsDisable
115:               						isrRegFlag = 0;
003656  EB0200     CLR W4
003658  8847F4     MOV W4, isrRegFlag
116:               						isrCsgFlag = 0;
00365A  EB0200     CLR W4
00365C  884804     MOV W4, isrCsgFlag
117:               						enableIsrTimer1();
00365E  A86094     BSET IEC0, #3
118:               						state = DISABLED;
003660  EB0200     CLR W4
003662  980F04     MOV W4, [W14+16]
119:               						break;
003664  370001     BRA 0x3668
120:               					default:
121:               						break;
003666  000000     NOP
122:               				}
123:               				if (csgGetState() == CSG_STANDING) {	// Si la consigne a atteint sa destination
003668  07F007     RCALL csgGetState
00366A  780200     MOV W0, W4
00366C  520FE0     SUB W4, #0x0, [W15]
00366E  3A0038     BRA NZ, 0x36E0
124:               					state = STANDING;					// on passe dans l'état STANDING
003670  200014     MOV #0x1, W4
003672  980F04     MOV W4, [W14+16]
125:               				}
126:               				break;
003674  370038     BRA 0x36E6
0036E0  000000     NOP
0036E2  370001     BRA 0x36E6
127:               			case TEST_STANDING:
128:               				state = canCommand(state);	// on traite les ordres CAN
003676  900A0E     MOV [W14+16], W4
003678  780004     MOV W4, W0
00367A  07FBCC     RCALL canCommand
00367C  780200     MOV W0, W4
00367E  980F04     MOV W4, [W14+16]
129:               				switch(newState) {
003680  78021E     MOV [W14], W4
003682  520FE0     SUB W4, #0x0, [W15]
003684  320003     BRA Z, 0x368C
003686  520FE2     SUB W4, #0x2, [W15]
003688  32000B     BRA Z, 0x36A0
130:               					case DISABLED:
131:               						disableIsrTimer1();
00368C  A96094     BCLR IEC0, #3
132:               						motorsDisable();		// on désactive les moteurs en entrant dans l'état DISABLED
00368E  07016D     RCALL motorsDisable
133:               						isrRegFlag = 0;
003690  EB0200     CLR W4
003692  8847F4     MOV W4, isrRegFlag
134:               						isrCsgFlag = 0;
003694  EB0200     CLR W4
003696  884804     MOV W4, isrCsgFlag
135:               						enableIsrTimer1();
003698  A86094     BSET IEC0, #3
136:               						state = DISABLED;
00369A  EB0200     CLR W4
00369C  980F04     MOV W4, [W14+16]
137:               						break;
00369E  370003     BRA 0x36A6
138:               					case MOVING:
139:               						state = TEST_MOVING;
0036A0  200044     MOV #0x4, W4
0036A2  980F04     MOV W4, [W14+16]
140:               						break;
0036A4  000000     NOP
141:               					default:
142:               						break;
00368A  37000D     BRA 0x36A6
143:               				}
144:               				break;
0036A6  37001F     BRA 0x36E6
145:               			case TEST_MOVING:
146:               				newState = canCommand(state);	// on traite les ordres CAN
0036A8  900A0E     MOV [W14+16], W4
0036AA  780004     MOV W4, W0
0036AC  07FBB3     RCALL canCommand
0036AE  780200     MOV W0, W4
0036B0  780F04     MOV W4, [W14]
147:               				//TRANSITIONS
148:               				switch(newState) {
0036B2  78021E     MOV [W14], W4
0036B4  520FE0     SUB W4, #0x0, [W15]
0036B6  3A000A     BRA NZ, 0x36CC
149:               					case DISABLED:
150:               						disableIsrTimer1();
0036B8  A96094     BCLR IEC0, #3
151:               						motorsDisable();		// on désactive les moteurs en entrant dans l'état DISABLED
0036BA  070157     RCALL motorsDisable
152:               						isrRegFlag = 0;
0036BC  EB0200     CLR W4
0036BE  8847F4     MOV W4, isrRegFlag
153:               						isrCsgFlag = 0;
0036C0  EB0200     CLR W4
0036C2  884804     MOV W4, isrCsgFlag
154:               						enableIsrTimer1();
0036C4  A86094     BSET IEC0, #3
155:               						state = DISABLED;
0036C6  EB0200     CLR W4
0036C8  980F04     MOV W4, [W14+16]
156:               						break;
0036CA  370001     BRA 0x36CE
157:               					default:
158:               						break;
0036CC  000000     NOP
159:               				}
160:               				if (csgGetState() == CSG_STANDING) {		// Si la consigne a atteint sa destination
0036CE  07EFD4     RCALL csgGetState
0036D0  780200     MOV W0, W4
0036D2  520FE0     SUB W4, #0x0, [W15]
0036D4  3A0007     BRA NZ, 0x36E4
161:               					state = TEST_STANDING;					// on passe dans l'état STANDING
0036D6  200034     MOV #0x3, W4
0036D8  980F04     MOV W4, [W14+16]
162:               				}
163:               				break;
0036DA  370005     BRA 0x36E6
0036E4  000000     NOP
164:               			default:
165:               				break;
0036DC  000000     NOP
0036DE  370003     BRA 0x36E6
166:               		}
167:               	#ifndef DEBUG_MODE
168:               		// on envoie les objets CAN périodiques
169:               		disableIsrTimer1();
0036E6  A96094     BCLR IEC0, #3
170:               		odoPhysPos = positionFloatToInteger(odoGetAbsPos());
0036E8  470264     ADD W14, #0x4, W4
0036EA  780004     MOV W4, W0
0036EC  07FDE3     RCALL odoGetAbsPos
0036EE  200227     MOV #0x22, W7
0036F0  43838E     ADD W7, W14, W7
0036F2  9000AE     MOV [W14+4], W1
0036F4  90013E     MOV [W14+6], W2
0036F6  9001CE     MOV [W14+8], W3
0036F8  90025E     MOV [W14+10], W4
0036FA  9002EE     MOV [W14+12], W5
0036FC  90037E     MOV [W14+14], W6
0036FE  780007     MOV W7, W0
003700  070180     RCALL positionFloatToInteger
003702  90121E     MOV [W14+34], W4
003704  9012AE     MOV [W14+36], W5
003706  8847C4     MOV W4, odoPhysPos
003708  8847D5     MOV W5, 0x8FA
00370A  9012BE     MOV [W14+38], W5
00370C  8847E5     MOV W5, 0x8FC
171:               		CanEnvoiProduction(&odoPhysPos);
00370E  208F80     MOV #0x8F8, W0
003710  07F316     RCALL CanEnvoiProduction
172:               		enableIsrTimer1();
003712  A86094     BSET IEC0, #3
173:               		if (state != oldState) {
003714  900A8E     MOV [W14+16], W5
003716  90021E     MOV [W14+2], W4
003718  528F84     SUB W5, W4, [W15]
00371A  32FF4C     BRA Z, 0x35B4
174:               			oldState = state;
00371C  900A0E     MOV [W14+16], W4
00371E  980714     MOV W4, [W14+2]
175:               			CanEnvoiProduction(&state);
003720  470270     ADD W14, #0x10, W4
003722  780004     MOV W4, W0
003724  07F30C     RCALL CanEnvoiProduction
176:               		}
177:               	#endif
178:               	}
0035B4  000000     NOP
003726  37FF47     BRA 0x35B6
179:               	return (1);
180:               }
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/globals.c  -------------------------------------------
1:                 #include "globals.h"
2:                 
3:                 #define RAD_TO_DEG10	(1800.0/3.14159265358979)
4:                 
5:                 inline positionInteger positionFloatToInteger(position posFl) {
003A02  FA0012     LNK #0x12
003A04  781F88     MOV W8, [W15++]
003A06  780400     MOV W0, W8
003A08  980731     MOV W1, [W14+6]
003A0A  980742     MOV W2, [W14+8]
003A0C  980753     MOV W3, [W14+10]
003A0E  980764     MOV W4, [W14+12]
003A10  980775     MOV W5, [W14+14]
003A12  980F06     MOV W6, [W14+16]
6:                     positionInteger pos;
7:                 
8:                     pos.x = (int)(1000*posFl.x);
003A14  90023E     MOV [W14+6], W4
003A16  9002CE     MOV [W14+8], W5
003A18  200002     MOV #0x0, W2
003A1A  2447A3     MOV #0x447A, W3
003A1C  BE0004     MOV.D W4, W0
003A1E  07E6AE     RCALL ___mulsf3
003A20  BE0200     MOV.D W0, W4
003A22  BE0004     MOV.D W4, W0
003A24  07E49F     RCALL ___fixsfsi
003A26  BE0200     MOV.D W0, W4
003A28  780204     MOV W4, W4
003A2A  780F04     MOV W4, [W14]
9:                     pos.y = (int)(1000*posFl.y);
003A2C  90025E     MOV [W14+10], W4
003A2E  9002EE     MOV [W14+12], W5
003A30  200002     MOV #0x0, W2
003A32  2447A3     MOV #0x447A, W3
003A34  BE0004     MOV.D W4, W0
003A36  07E6A2     RCALL ___mulsf3
003A38  BE0200     MOV.D W0, W4
003A3A  BE0004     MOV.D W4, W0
003A3C  07E493     RCALL ___fixsfsi
003A3E  BE0200     MOV.D W0, W4
003A40  780204     MOV W4, W4
003A42  980714     MOV W4, [W14+2]
10:                    pos.alpha = (int)(RAD_TO_DEG10*posFl.alpha);
003A44  90027E     MOV [W14+14], W4
003A46  900A8E     MOV [W14+16], W5
003A48  23D4C2     MOV #0x3D4C, W2
003A4A  2440F3     MOV #0x440F, W3
003A4C  BE0004     MOV.D W4, W0
003A4E  07E696     RCALL ___mulsf3
003A50  BE0200     MOV.D W0, W4
003A52  BE0004     MOV.D W4, W0
003A54  07E487     RCALL ___fixsfsi
003A56  BE0200     MOV.D W0, W4
003A58  780204     MOV W4, W4
003A5A  980724     MOV W4, [W14+4]
11:                    return(pos);
003A5C  781C3E     MOV [W14++], [W8++]
003A5E  78142E     MOV [W14--], [W8--]
003A60  90022E     MOV [W14+4], W4
003A62  980424     MOV W4, [W8+4]
12:                }
003A64  780008     MOV W8, W0
003A66  78044F     MOV [--W15], W8
003A68  FA8000     ULNK
003A6A  060000     RETURN
13:                
14:                
15:                inline relativeCoordInteger relativeCoordFloatToInteger(relativeCoord posFl) {
003A6C  FA000C     LNK #0xC
003A6E  781F88     MOV W8, [W15++]
003A70  780400     MOV W0, W8
003A72  980724     MOV W4, [W14+4]
003A74  980735     MOV W5, [W14+6]
003A76  980746     MOV W6, [W14+8]
003A78  980757     MOV W7, [W14+10]
16:                    relativeCoordInteger pos;
17:                	
18:                    pos.l = (int)(1000*posFl.l);
003A7A  90022E     MOV [W14+4], W4
003A7C  9002BE     MOV [W14+6], W5
003A7E  200002     MOV #0x0, W2
003A80  2447A3     MOV #0x447A, W3
003A82  BE0004     MOV.D W4, W0
003A84  07E67B     RCALL ___mulsf3
003A86  BE0200     MOV.D W0, W4
003A88  BE0004     MOV.D W4, W0
003A8A  07E46C     RCALL ___fixsfsi
003A8C  BE0200     MOV.D W0, W4
003A8E  780204     MOV W4, W4
003A90  780F04     MOV W4, [W14]
19:                    pos.r = (int)(RAD_TO_DEG10*posFl.r);
003A92  90024E     MOV [W14+8], W4
003A94  9002DE     MOV [W14+10], W5
003A96  23D4C2     MOV #0x3D4C, W2
003A98  2440F3     MOV #0x440F, W3
003A9A  BE0004     MOV.D W4, W0
003A9C  07E66F     RCALL ___mulsf3
003A9E  BE0200     MOV.D W0, W4
003AA0  BE0004     MOV.D W4, W0
003AA2  07E460     RCALL ___fixsfsi
003AA4  BE0200     MOV.D W0, W4
003AA6  780204     MOV W4, W4
003AA8  980714     MOV W4, [W14+2]
20:                    return(pos);
003AAA  781C3E     MOV [W14++], [W8++]
003AAC  78142E     MOV [W14--], [W8--]
21:                }
003AAE  780008     MOV W8, W0
003AB0  78044F     MOV [--W15], W8
003AB2  FA8000     ULNK
003AB4  060000     RETURN
22:                
23:                
24:                inline float satureAngle(float angle) {
003AB6  FA0004     LNK #0x4
003AB8  781F88     MOV W8, [W15++]
003ABA  BE8F00     MOV.D W0, [W14]
25:                	while (angle > PI)		angle -= 2*PI;
003ABC  370006     BRA 0x3ACA
003ABE  20FD02     MOV #0xFD0, W2
003AC0  240C93     MOV #0x40C9, W3
003AC2  BE001E     MOV.D [W14], W0
003AC4  07E56D     RCALL ___subsf3
003AC6  BE0200     MOV.D W0, W4
003AC8  BE8F04     MOV.D W4, [W14]
003ACA  B3C018     MOV #0x1, W8
003ACC  20FD02     MOV #0xFD0, W2
003ACE  240493     MOV #0x4049, W3
003AD0  BE001E     MOV.D [W14], W0
003AD2  07E446     RCALL ___gtsf2
003AD4  780200     MOV W0, W4
003AD6  520FE0     SUB W4, #0x0, [W15]
003AD8  3C0001     BRA GT, 0x3ADC
003ADA  EB4400     CLR.B W8
003ADC  544FE0     SUB.B W8, #0x0, [W15]
003ADE  3AFFEF     BRA NZ, 0x3ABE
26:                	while (angle < -PI)		angle += 2*PI;
003AE0  370006     BRA 0x3AEE
003AE2  20FD02     MOV #0xFD0, W2
003AE4  240C93     MOV #0x40C9, W3
003AE6  BE001E     MOV.D [W14], W0
003AE8  07E564     RCALL ___addsf3
003AEA  BE0200     MOV.D W0, W4
003AEC  BE8F04     MOV.D W4, [W14]
003AEE  B3C018     MOV #0x1, W8
003AF0  20FD02     MOV #0xFD0, W2
003AF2  2C0493     MOV #0xC049, W3
003AF4  BE001E     MOV.D [W14], W0
003AF6  07E432     RCALL ___lesf2
003AF8  780200     MOV W0, W4
003AFA  520FE0     SUB W4, #0x0, [W15]
003AFC  350001     BRA LT, 0x3B00
003AFE  EB4400     CLR.B W8
003B00  544FE0     SUB.B W8, #0x0, [W15]
003B02  3AFFEF     BRA NZ, 0x3AE2
27:                	return(angle);
003B04  BE021E     MOV.D [W14], W4
28:                }
003B06  BE0004     MOV.D W4, W0
003B08  78044F     MOV [--W15], W8
003B0A  FA8000     ULNK
003B0C  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/consigne.c  ------------------------------------------
1:                 #include "Configware.h"
2:                 #include "Globals.h"
3:                 #include "Constantes.h"
4:                 #include "consigne.h"
5:                 #include <stdlib.h>
6:                 
7:                 
8:                 #define TS (1/SAMPLE_FREQ)
9:                 #define SQR_TS_DEMI		(TS*TS/2)
10:                
11:                relativeCoord	prCsgPos;       // Position actuelle
12:                relativeCoord	prCsgFinalPos;	// Position finale
13:                relativeCoord	prCsgVel;		// Vitesse actuelle
14:                relativeCoord	prCsgNomVel;	// Vitesse nominale
15:                relativeCoord	prCsgNomAcc;	// Accélération nominale
16:                relativeCoord	prMinDist;		// Distance minimum parcourue en 1 période
17:                csgStatusType	prCsgStatus;	// Statut du générateur de consigne
18:                
19:                
20:                inline float sign(float x) {
001492  FA0004     LNK #0x4
001494  781F88     MOV W8, [W15++]
001496  BE8F00     MOV.D W0, [W14]
21:                	if (x >= 0) {
001498  B3C018     MOV #0x1, W8
00149A  B81160     MUL.UU W2, #0, W2
00149C  BE001E     MOV.D [W14], W0
00149E  07F760     RCALL ___gtsf2
0014A0  780200     MOV W0, W4
0014A2  520FE0     SUB W4, #0x0, [W15]
0014A4  3D0001     BRA GE, 0x14A8
0014A6  EB4400     CLR.B W8
0014A8  544FE0     SUB.B W8, #0x0, [W15]
0014AA  320003     BRA Z, 0x14B2
22:                		return(1);
0014AC  200004     MOV #0x0, W4
0014AE  23F805     MOV #0x3F80, W5
0014B0  370002     BRA 0x14B6
23:                	} else {
24:                		return(-1);
0014B2  200004     MOV #0x0, W4
0014B4  2BF805     MOV #0xBF80, W5
25:                	}
26:                }
0014B6  BE0004     MOV.D W4, W0
0014B8  78044F     MOV [--W15], W8
0014BA  FA8000     ULNK
0014BC  060000     RETURN
27:                
28:                
29:                inline float absol(float x) {
0014BE  FA0004     LNK #0x4
0014C0  781F88     MOV W8, [W15++]
0014C2  BE8F00     MOV.D W0, [W14]
30:                if (x >= 0) {
0014C4  B3C018     MOV #0x1, W8
0014C6  B81160     MUL.UU W2, #0, W2
0014C8  BE001E     MOV.D [W14], W0
0014CA  07F74A     RCALL ___gtsf2
0014CC  780200     MOV W0, W4
0014CE  520FE0     SUB W4, #0x0, [W15]
0014D0  3D0001     BRA GE, 0x14D4
0014D2  EB4400     CLR.B W8
0014D4  544FE0     SUB.B W8, #0x0, [W15]
0014D6  320002     BRA Z, 0x14DC
31:                		return(x);
0014D8  BE021E     MOV.D [W14], W4
0014DA  370002     BRA 0x14E0
32:                	} else {
33:                		return(-x);
0014DC  BE021E     MOV.D [W14], W4
0014DE  A2F005     BTG W5, #15
34:                	}
35:                }
0014E0  BE0004     MOV.D W4, W0
0014E2  78044F     MOV [--W15], W8
0014E4  FA8000     ULNK
0014E6  060000     RETURN
36:                
37:                
38:                csgStatusType csgInit(relativeCoord nomVel, relativeCoord nomAcc) {
0014E8  FA0010     LNK #0x10
0014EA  BE9F00     MOV.D W0, [W14++]
0014EC  BE9702     MOV.D W2, [W14--]
0014EE  980744     MOV W4, [W14+8]
0014F0  980755     MOV W5, [W14+10]
0014F2  980766     MOV W6, [W14+12]
0014F4  980777     MOV W7, [W14+14]
39:                	prCsgPos.l = 0;
0014F6  2089C6     MOV #0x89C, W6
0014F8  B82260     MUL.UU W4, #0, W4
0014FA  BE8B04     MOV.D W4, [W6]
40:                	prCsgFinalPos.l = 0;
0014FC  208A46     MOV #0x8A4, W6
0014FE  B82260     MUL.UU W4, #0, W4
001500  BE8B04     MOV.D W4, [W6]
41:                	prCsgVel.l = 0;
001502  208AC6     MOV #0x8AC, W6
001504  B82260     MUL.UU W4, #0, W4
001506  BE8B04     MOV.D W4, [W6]
42:                	prCsgNomVel.l = nomVel.l;
001508  BE021E     MOV.D [W14], W4
00150A  208B46     MOV #0x8B4, W6
00150C  BE8B04     MOV.D W4, [W6]
43:                	prCsgNomAcc.l = nomAcc.l;
00150E  90024E     MOV [W14+8], W4
001510  9002DE     MOV [W14+10], W5
001512  208BC6     MOV #0x8BC, W6
001514  BE8B04     MOV.D W4, [W6]
44:                	prMinDist.l = prCsgNomAcc.l*SQR_TS_DEMI;
001516  208BC4     MOV #0x8BC, W4
001518  BE0214     MOV.D [W4], W4
00151A  2B7172     MOV #0xB717, W2
00151C  238513     MOV #0x3851, W3
00151E  BE0004     MOV.D W4, W0
001520  07F92D     RCALL ___mulsf3
001522  BE0200     MOV.D W0, W4
001524  208C46     MOV #0x8C4, W6
001526  BE8B04     MOV.D W4, [W6]
45:                
46:                	prCsgPos.r = 0;
001528  2089C6     MOV #0x89C, W6
00152A  B82260     MUL.UU W4, #0, W4
00152C  980324     MOV W4, [W6+4]
00152E  980335     MOV W5, [W6+6]
47:                	prCsgFinalPos.r = 0;
001530  208A46     MOV #0x8A4, W6
001532  B82260     MUL.UU W4, #0, W4
001534  980324     MOV W4, [W6+4]
001536  980335     MOV W5, [W6+6]
48:                	prCsgVel.r = 0;
001538  208AC6     MOV #0x8AC, W6
00153A  B82260     MUL.UU W4, #0, W4
00153C  980324     MOV W4, [W6+4]
00153E  980335     MOV W5, [W6+6]
49:                	prCsgNomVel.r = nomVel.r;
001540  90022E     MOV [W14+4], W4
001542  9002BE     MOV [W14+6], W5
001544  208B46     MOV #0x8B4, W6
001546  980324     MOV W4, [W6+4]
001548  980335     MOV W5, [W6+6]
50:                	prCsgNomAcc.r = nomAcc.r;
00154A  90026E     MOV [W14+12], W4
00154C  9002FE     MOV [W14+14], W5
00154E  208BC6     MOV #0x8BC, W6
001550  980324     MOV W4, [W6+4]
001552  980335     MOV W5, [W6+6]
51:                	prMinDist.r = prCsgNomAcc.r*SQR_TS_DEMI;
001554  208BC4     MOV #0x8BC, W4
001556  9002B4     MOV [W4+6], W5
001558  900224     MOV [W4+4], W4
00155A  2B7172     MOV #0xB717, W2
00155C  238513     MOV #0x3851, W3
00155E  BE0004     MOV.D W4, W0
001560  07F90D     RCALL ___mulsf3
001562  BE0200     MOV.D W0, W4
001564  208C46     MOV #0x8C4, W6
001566  980324     MOV W4, [W6+4]
001568  980335     MOV W5, [W6+6]
52:                	prCsgStatus = CSG_STANDING;
00156A  EB0200     CLR W4
00156C  884664     MOV W4, prCsgStatus
53:                	return(prCsgStatus);
00156E  804664     MOV prCsgStatus, W4
54:                }
001570  780004     MOV W4, W0
001572  FA8000     ULNK
001574  060000     RETURN
55:                
56:                
57:                void csgSetFinalPos(relativeCoord finalPos) {
001576  FA0008     LNK #0x8
001578  BE9F00     MOV.D W0, [W14++]
00157A  BE9702     MOV.D W2, [W14--]
58:                	prCsgFinalPos.l = finalPos.l;
00157C  BE021E     MOV.D [W14], W4
00157E  208A46     MOV #0x8A4, W6
001580  BE8B04     MOV.D W4, [W6]
59:                	prCsgFinalPos.r = finalPos.r;
001582  90022E     MOV [W14+4], W4
001584  9002BE     MOV [W14+6], W5
001586  208A46     MOV #0x8A4, W6
001588  980324     MOV W4, [W6+4]
00158A  980335     MOV W5, [W6+6]
60:                }
00158C  FA8000     ULNK
00158E  060000     RETURN
61:                
62:                // Modifie les accélérations polaires nominales
63:                inline void csgSetNomAcc(relativeCoord nomAcc) {
001590  FA0008     LNK #0x8
001592  BE9F00     MOV.D W0, [W14++]
001594  BE9702     MOV.D W2, [W14--]
64:                	prCsgNomAcc.l = nomAcc.l;
001596  BE021E     MOV.D [W14], W4
001598  208BC6     MOV #0x8BC, W6
00159A  BE8B04     MOV.D W4, [W6]
65:                	prCsgNomAcc.r = nomAcc.r;
00159C  90022E     MOV [W14+4], W4
00159E  9002BE     MOV [W14+6], W5
0015A0  208BC6     MOV #0x8BC, W6
0015A2  980324     MOV W4, [W6+4]
0015A4  980335     MOV W5, [W6+6]
66:                	prMinDist.l = prCsgNomAcc.l*SQR_TS_DEMI;
0015A6  208BC4     MOV #0x8BC, W4
0015A8  BE0214     MOV.D [W4], W4
0015AA  2B7172     MOV #0xB717, W2
0015AC  238513     MOV #0x3851, W3
0015AE  BE0004     MOV.D W4, W0
0015B0  07F8E5     RCALL ___mulsf3
0015B2  BE0200     MOV.D W0, W4
0015B4  208C46     MOV #0x8C4, W6
0015B6  BE8B04     MOV.D W4, [W6]
67:                	prMinDist.r = prCsgNomAcc.r*SQR_TS_DEMI;
0015B8  208BC4     MOV #0x8BC, W4
0015BA  9002B4     MOV [W4+6], W5
0015BC  900224     MOV [W4+4], W4
0015BE  2B7172     MOV #0xB717, W2
0015C0  238513     MOV #0x3851, W3
0015C2  BE0004     MOV.D W4, W0
0015C4  07F8DB     RCALL ___mulsf3
0015C6  BE0200     MOV.D W0, W4
0015C8  208C46     MOV #0x8C4, W6
0015CA  980324     MOV W4, [W6+4]
0015CC  980335     MOV W5, [W6+6]
68:                }
0015CE  FA8000     ULNK
0015D0  060000     RETURN
69:                
70:                // Modifie les vitesses polaires nominales
71:                inline void csgSetNomVel(relativeCoord nomVel) {
0015D2  FA0008     LNK #0x8
0015D4  BE9F00     MOV.D W0, [W14++]
0015D6  BE9702     MOV.D W2, [W14--]
72:                	prCsgNomVel.l = nomVel.l;
0015D8  BE021E     MOV.D [W14], W4
0015DA  208B46     MOV #0x8B4, W6
0015DC  BE8B04     MOV.D W4, [W6]
73:                	prCsgNomVel.r = nomVel.r;
0015DE  90022E     MOV [W14+4], W4
0015E0  9002BE     MOV [W14+6], W5
0015E2  208B46     MOV #0x8B4, W6
0015E4  980324     MOV W4, [W6+4]
0015E6  980335     MOV W5, [W6+6]
74:                }
0015E8  FA8000     ULNK
0015EA  060000     RETURN
75:                
76:                // Renvoie la consigne de vitesse polaire actuelle
77:                inline relativeCoord csgGetVel(void) {
0015EC  FA0000     LNK #0x0
0015EE  BE9F88     MOV.D W8, [W15++]
0015F0  BE9F8A     MOV.D W10, [W15++]
0015F2  780200     MOV W0, W4
78:                	return(prCsgVel);
0015F4  208AC5     MOV #0x8AC, W5
0015F6  BE0435     MOV.D [W5++], W8
0015F8  BE0525     MOV.D [W5--], W10
0015FA  BE9A08     MOV.D W8, [W4++]
0015FC  BE920A     MOV.D W10, [W4--]
79:                }
0015FE  780004     MOV W4, W0
001600  BE054F     MOV.D [--W15], W10
001602  BE044F     MOV.D [--W15], W8
001604  FA8000     ULNK
001606  060000     RETURN
80:                
81:                // Renvoie la consigne de position polaire actuelle
82:                inline relativeCoord csgGetPos(void) {
001608  FA0000     LNK #0x0
00160A  BE9F88     MOV.D W8, [W15++]
00160C  BE9F8A     MOV.D W10, [W15++]
00160E  780200     MOV W0, W4
83:                	return(prCsgPos);
001610  2089C5     MOV #0x89C, W5
001612  BE0435     MOV.D [W5++], W8
001614  BE0525     MOV.D [W5--], W10
001616  BE9A08     MOV.D W8, [W4++]
001618  BE920A     MOV.D W10, [W4--]
84:                }
00161A  780004     MOV W4, W0
00161C  BE054F     MOV.D [--W15], W10
00161E  BE044F     MOV.D [--W15], W8
001620  FA8000     ULNK
001622  060000     RETURN
85:                
86:                // Renvoie la consigne de vitesse polaire actuelle
87:                inline relativeCoord csgGetNomVel(void) {
001624  FA0000     LNK #0x0
001626  BE9F88     MOV.D W8, [W15++]
001628  BE9F8A     MOV.D W10, [W15++]
00162A  780200     MOV W0, W4
88:                	return(prCsgNomVel);
00162C  208B45     MOV #0x8B4, W5
00162E  BE0435     MOV.D [W5++], W8
001630  BE0525     MOV.D [W5--], W10
001632  BE9A08     MOV.D W8, [W4++]
001634  BE920A     MOV.D W10, [W4--]
89:                }
001636  780004     MOV W4, W0
001638  BE054F     MOV.D [--W15], W10
00163A  BE044F     MOV.D [--W15], W8
00163C  FA8000     ULNK
00163E  060000     RETURN
90:                
91:                // Renvoie la consigne de vitesse polaire actuelle
92:                inline relativeCoord csgGetNomAcc(void) {
001640  FA0000     LNK #0x0
001642  BE9F88     MOV.D W8, [W15++]
001644  BE9F8A     MOV.D W10, [W15++]
001646  780200     MOV W0, W4
93:                	return(prCsgNomAcc);
001648  208BC5     MOV #0x8BC, W5
00164A  BE0435     MOV.D [W5++], W8
00164C  BE0525     MOV.D [W5--], W10
00164E  BE9A08     MOV.D W8, [W4++]
001650  BE920A     MOV.D W10, [W4--]
94:                }
001652  780004     MOV W4, W0
001654  BE054F     MOV.D [--W15], W10
001656  BE044F     MOV.D [--W15], W8
001658  FA8000     ULNK
00165A  060000     RETURN
95:                
96:                // Renvoie la consigne de position polaire actuelle
97:                inline relativeCoord csgGetFinalPos(void) {
00165C  FA0000     LNK #0x0
00165E  BE9F88     MOV.D W8, [W15++]
001660  BE9F8A     MOV.D W10, [W15++]
001662  780200     MOV W0, W4
98:                	return(prCsgFinalPos);
001664  208A45     MOV #0x8A4, W5
001666  BE0435     MOV.D [W5++], W8
001668  BE0525     MOV.D [W5--], W10
00166A  BE9A08     MOV.D W8, [W4++]
00166C  BE920A     MOV.D W10, [W4--]
99:                }
00166E  780004     MOV W4, W0
001670  BE054F     MOV.D [--W15], W10
001672  BE044F     MOV.D [--W15], W8
001674  FA8000     ULNK
001676  060000     RETURN
100:               
101:               // Renvoie l'état actuel du générateur de consigne
102:               inline csgStatusType csgGetState(void) {
001678  FA0000     LNK #0x0
103:                   return(prCsgStatus);
00167A  804664     MOV prCsgStatus, W4
104:               }
00167C  780004     MOV W4, W0
00167E  FA8000     ULNK
001680  060000     RETURN
105:               
106:               csgStatusType csgCompute(void) {
001682  FA000E     LNK #0xE
001684  BE9F88     MOV.D W8, [W15++]
001686  BE9F8A     MOV.D W10, [W15++]
107:               	float tmp;
108:               	float acc;
109:               	float sqrVel;
110:               	propStateType state;
111:               
112:               	state = CSG_STANDING;
001688  EB0200     CLR W4
00168A  980724     MOV W4, [W14+4]
113:               	if (abs(prCsgFinalPos.l - prCsgPos.l) <= prMinDist.l) {			// si a distance qu'il reste a parcourir est négligeable
00168C  208A44     MOV #0x8A4, W4
00168E  BE0314     MOV.D [W4], W6
001690  2089C4     MOV #0x89C, W4
001692  BE0214     MOV.D [W4], W4
001694  BE0104     MOV.D W4, W2
001696  BE0006     MOV.D W6, W0
001698  07F783     RCALL ___subsf3
00169A  BE0200     MOV.D W0, W4
00169C  BE0004     MOV.D W4, W0
00169E  07F662     RCALL ___fixsfsi
0016A0  BE0200     MOV.D W0, W4
0016A2  780204     MOV W4, W4
0016A4  A7F004     BTSC W4, #15
0016A6  EA0204     NEG W4, W4
0016A8  DEA2CF     ASR W4, #15, W5
0016AA  BE0004     MOV.D W4, W0
0016AC  07F697     RCALL ___floatsisf
0016AE  BE0300     MOV.D W0, W6
0016B0  208C44     MOV #0x8C4, W4
0016B2  BE0214     MOV.D [W4], W4
0016B4  B3C018     MOV #0x1, W8
0016B6  BE0104     MOV.D W4, W2
0016B8  BE0006     MOV.D W6, W0
0016BA  07F650     RCALL ___lesf2
0016BC  780200     MOV W0, W4
0016BE  520FE0     SUB W4, #0x0, [W15]
0016C0  340001     BRA LE, 0x16C4
0016C2  EB4400     CLR.B W8
0016C4  544FE0     SUB.B W8, #0x0, [W15]
0016C6  320008     BRA Z, 0x16D8
114:               		prCsgVel.l = 0;
0016C8  208AC6     MOV #0x8AC, W6
0016CA  B82260     MUL.UU W4, #0, W4
0016CC  BE8B04     MOV.D W4, [W6]
115:               		prCsgPos.l = prCsgFinalPos.l;
0016CE  208A44     MOV #0x8A4, W4
0016D0  BE0214     MOV.D [W4], W4
0016D2  2089C6     MOV #0x89C, W6
0016D4  BE8B04     MOV.D W4, [W6]
0016D6  370126     BRA 0x1924
116:               	} else {
117:               		state = CSG_MOVING;
0016D8  200014     MOV #0x1, W4
0016DA  980724     MOV W4, [W14+4]
118:               		sqrVel = prCsgVel.l*prCsgVel.l;
0016DC  208AC4     MOV #0x8AC, W4
0016DE  BE0314     MOV.D [W4], W6
0016E0  208AC4     MOV #0x8AC, W4
0016E2  BE0214     MOV.D [W4], W4
0016E4  BE0104     MOV.D W4, W2
0016E6  BE0006     MOV.D W6, W0
0016E8  07F849     RCALL ___mulsf3
0016EA  BE0200     MOV.D W0, W4
0016EC  980734     MOV W4, [W14+6]
0016EE  980745     MOV W5, [W14+8]
119:               		tmp = prCsgPos.l + prCsgVel.l*TS + sign(prCsgVel.l)*sqrVel/(2*prCsgNomAcc.l);
0016F0  2089C4     MOV #0x89C, W4
0016F2  BE0414     MOV.D [W4], W8
0016F4  208AC4     MOV #0x8AC, W4
0016F6  BE0214     MOV.D [W4], W4
0016F8  2D70A2     MOV #0xD70A, W2
0016FA  23C233     MOV #0x3C23, W3
0016FC  BE0004     MOV.D W4, W0
0016FE  07F83E     RCALL ___mulsf3
001700  BE0200     MOV.D W0, W4
001702  BE0104     MOV.D W4, W2
001704  BE0008     MOV.D W8, W0
001706  07F755     RCALL ___addsf3
001708  BE0200     MOV.D W0, W4
00170A  BE0404     MOV.D W4, W8
00170C  208AC4     MOV #0x8AC, W4
00170E  BE0214     MOV.D [W4], W4
001710  BE0004     MOV.D W4, W0
001712  07FEBF     RCALL sign
001714  BE0200     MOV.D W0, W4
001716  90013E     MOV [W14+6], W2
001718  9001CE     MOV [W14+8], W3
00171A  BE0004     MOV.D W4, W0
00171C  07F82F     RCALL ___mulsf3
00171E  BE0200     MOV.D W0, W4
001720  BE0504     MOV.D W4, W10
001722  208BC4     MOV #0x8BC, W4
001724  BE0214     MOV.D [W4], W4
001726  BE0104     MOV.D W4, W2
001728  BE0004     MOV.D W4, W0
00172A  07F743     RCALL ___addsf3
00172C  BE0200     MOV.D W0, W4
00172E  BE0104     MOV.D W4, W2
001730  BE000A     MOV.D W10, W0
001732  07F954     RCALL ___divsf3x
001734  BE0200     MOV.D W0, W4
001736  BE0104     MOV.D W4, W2
001738  BE0008     MOV.D W8, W0
00173A  07F73B     RCALL ___addsf3
00173C  BE0200     MOV.D W0, W4
00173E  980754     MOV W4, [W14+10]
001740  980765     MOV W5, [W14+12]
120:               		if (prCsgPos.l < prCsgFinalPos.l) {
001742  2089C4     MOV #0x89C, W4
001744  BE0314     MOV.D [W4], W6
001746  208A44     MOV #0x8A4, W4
001748  BE0214     MOV.D [W4], W4
00174A  B3C018     MOV #0x1, W8
00174C  BE0104     MOV.D W4, W2
00174E  BE0006     MOV.D W6, W0
001750  07F605     RCALL ___lesf2
001752  780200     MOV W0, W4
001754  520FE0     SUB W4, #0x0, [W15]
001756  350001     BRA LT, 0x175A
001758  EB4400     CLR.B W8
00175A  544FE0     SUB.B W8, #0x0, [W15]
00175C  32005D     BRA Z, 0x1818
121:               			if (tmp > prCsgFinalPos.l) {
00175E  208A44     MOV #0x8A4, W4
001760  BE0214     MOV.D [W4], W4
001762  B3C018     MOV #0x1, W8
001764  90015E     MOV [W14+10], W2
001766  9001EE     MOV [W14+12], W3
001768  BE0004     MOV.D W4, W0
00176A  07F5F8     RCALL ___lesf2
00176C  780200     MOV W0, W4
00176E  520FE0     SUB W4, #0x0, [W15]
001770  350001     BRA LT, 0x1774
001772  EB4400     CLR.B W8
001774  544FE0     SUB.B W8, #0x0, [W15]
001776  320013     BRA Z, 0x179E
122:               				acc = sqrVel/(2*(prCsgPos.l - prCsgFinalPos.l));
001778  2089C4     MOV #0x89C, W4
00177A  BE0314     MOV.D [W4], W6
00177C  208A44     MOV #0x8A4, W4
00177E  BE0214     MOV.D [W4], W4
001780  BE0104     MOV.D W4, W2
001782  BE0006     MOV.D W6, W0
001784  07F70D     RCALL ___subsf3
001786  BE0200     MOV.D W0, W4
001788  BE0104     MOV.D W4, W2
00178A  BE0004     MOV.D W4, W0
00178C  07F712     RCALL ___addsf3
00178E  BE0200     MOV.D W0, W4
001790  BE0104     MOV.D W4, W2
001792  90003E     MOV [W14+6], W0
001794  9000CE     MOV [W14+8], W1
001796  07F922     RCALL ___divsf3x
001798  BE0200     MOV.D W0, W4
00179A  BE8F04     MOV.D W4, [W14]
00179C  37009D     BRA 0x18D8
123:               			} else if (prCsgVel.l < prCsgNomVel.l) {
00179E  208AC4     MOV #0x8AC, W4
0017A0  BE0314     MOV.D [W4], W6
0017A2  208B44     MOV #0x8B4, W4
0017A4  BE0214     MOV.D [W4], W4
0017A6  B3C018     MOV #0x1, W8
0017A8  BE0104     MOV.D W4, W2
0017AA  BE0006     MOV.D W6, W0
0017AC  07F5D7     RCALL ___lesf2
0017AE  780200     MOV W0, W4
0017B0  520FE0     SUB W4, #0x0, [W15]
0017B2  350001     BRA LT, 0x17B6
0017B4  EB4400     CLR.B W8
0017B6  544FE0     SUB.B W8, #0x0, [W15]
0017B8  32002C     BRA Z, 0x1812
124:               				if (prCsgVel.l < prCsgNomVel.l-prCsgNomAcc.l*TS) {
0017BA  208AC4     MOV #0x8AC, W4
0017BC  BE0414     MOV.D [W4], W8
0017BE  208B44     MOV #0x8B4, W4
0017C0  BE0514     MOV.D [W4], W10
0017C2  208BC4     MOV #0x8BC, W4
0017C4  BE0214     MOV.D [W4], W4
0017C6  2D70A2     MOV #0xD70A, W2
0017C8  23C233     MOV #0x3C23, W3
0017CA  BE0004     MOV.D W4, W0
0017CC  07F7D7     RCALL ___mulsf3
0017CE  BE0200     MOV.D W0, W4
0017D0  BE0104     MOV.D W4, W2
0017D2  BE000A     MOV.D W10, W0
0017D4  07F6E5     RCALL ___subsf3
0017D6  BE0200     MOV.D W0, W4
0017D8  B3C01A     MOV #0x1, W10
0017DA  BE0104     MOV.D W4, W2
0017DC  BE0008     MOV.D W8, W0
0017DE  07F5BE     RCALL ___lesf2
0017E0  780200     MOV W0, W4
0017E2  520FE0     SUB W4, #0x0, [W15]
0017E4  350001     BRA LT, 0x17E8
0017E6  EB4500     CLR.B W10
0017E8  554FE0     SUB.B W10, #0x0, [W15]
0017EA  320004     BRA Z, 0x17F4
125:               					acc = prCsgNomAcc.l;
0017EC  208BC4     MOV #0x8BC, W4
0017EE  781F34     MOV [W4++], [W14++]
0017F0  781724     MOV [W4--], [W14--]
0017F2  370072     BRA 0x18D8
126:               				} else {
127:               					acc = (prCsgNomVel.l - prCsgVel.l)*SAMPLE_FREQ;
0017F4  208B44     MOV #0x8B4, W4
0017F6  BE0314     MOV.D [W4], W6
0017F8  208AC4     MOV #0x8AC, W4
0017FA  BE0214     MOV.D [W4], W4
0017FC  BE0104     MOV.D W4, W2
0017FE  BE0006     MOV.D W6, W0
001800  07F6CF     RCALL ___subsf3
001802  BE0200     MOV.D W0, W4
001804  200002     MOV #0x0, W2
001806  242C83     MOV #0x42C8, W3
001808  BE0004     MOV.D W4, W0
00180A  07F7B8     RCALL ___mulsf3
00180C  BE0200     MOV.D W0, W4
00180E  BE8F04     MOV.D W4, [W14]
001810  370063     BRA 0x18D8
128:               				}
129:               			} else {
130:               				acc = 0;
001812  B82260     MUL.UU W4, #0, W4
001814  BE8F04     MOV.D W4, [W14]
001816  370060     BRA 0x18D8
131:               			}
132:               		} else {
133:               			if (tmp < prCsgFinalPos.l) {
001818  208A44     MOV #0x8A4, W4
00181A  BE0214     MOV.D [W4], W4
00181C  B3C018     MOV #0x1, W8
00181E  90015E     MOV [W14+10], W2
001820  9001EE     MOV [W14+12], W3
001822  BE0004     MOV.D W4, W0
001824  07F59D     RCALL ___gtsf2
001826  780200     MOV W0, W4
001828  520FE0     SUB W4, #0x0, [W15]
00182A  3C0001     BRA GT, 0x182E
00182C  EB4400     CLR.B W8
00182E  544FE0     SUB.B W8, #0x0, [W15]
001830  320013     BRA Z, 0x1858
134:               				acc = sqrVel/(2*(prCsgPos.l - prCsgFinalPos.l));
001832  2089C4     MOV #0x89C, W4
001834  BE0314     MOV.D [W4], W6
001836  208A44     MOV #0x8A4, W4
001838  BE0214     MOV.D [W4], W4
00183A  BE0104     MOV.D W4, W2
00183C  BE0006     MOV.D W6, W0
00183E  07F6B0     RCALL ___subsf3
001840  BE0200     MOV.D W0, W4
001842  BE0104     MOV.D W4, W2
001844  BE0004     MOV.D W4, W0
001846  07F6B5     RCALL ___addsf3
001848  BE0200     MOV.D W0, W4
00184A  BE0104     MOV.D W4, W2
00184C  90003E     MOV [W14+6], W0
00184E  9000CE     MOV [W14+8], W1
001850  07F8C5     RCALL ___divsf3x
001852  BE0200     MOV.D W0, W4
001854  BE8F04     MOV.D W4, [W14]
001856  370040     BRA 0x18D8
135:               			} else if (prCsgVel.l > -prCsgNomVel.l) {
001858  208AC4     MOV #0x8AC, W4
00185A  BE0314     MOV.D [W4], W6
00185C  208B44     MOV #0x8B4, W4
00185E  BE0214     MOV.D [W4], W4
001860  A2F005     BTG W5, #15
001862  B3C018     MOV #0x1, W8
001864  BE0104     MOV.D W4, W2
001866  BE0006     MOV.D W6, W0
001868  07F57B     RCALL ___gtsf2
00186A  780200     MOV W0, W4
00186C  520FE0     SUB W4, #0x0, [W15]
00186E  3C0001     BRA GT, 0x1872
001870  EB4400     CLR.B W8
001872  544FE0     SUB.B W8, #0x0, [W15]
001874  32002F     BRA Z, 0x18D4
136:               				if (prCsgVel.l > prCsgNomAcc.l*TS - prCsgNomVel.l) {
001876  208AC4     MOV #0x8AC, W4
001878  BE0414     MOV.D [W4], W8
00187A  208BC4     MOV #0x8BC, W4
00187C  BE0214     MOV.D [W4], W4
00187E  2D70A2     MOV #0xD70A, W2
001880  23C233     MOV #0x3C23, W3
001882  BE0004     MOV.D W4, W0
001884  07F77B     RCALL ___mulsf3
001886  BE0200     MOV.D W0, W4
001888  BE0304     MOV.D W4, W6
00188A  208B44     MOV #0x8B4, W4
00188C  BE0214     MOV.D [W4], W4
00188E  BE0104     MOV.D W4, W2
001890  BE0006     MOV.D W6, W0
001892  07F686     RCALL ___subsf3
001894  BE0200     MOV.D W0, W4
001896  B3C01A     MOV #0x1, W10
001898  BE0104     MOV.D W4, W2
00189A  BE0008     MOV.D W8, W0
00189C  07F561     RCALL ___gtsf2
00189E  780200     MOV W0, W4
0018A0  520FE0     SUB W4, #0x0, [W15]
0018A2  3C0001     BRA GT, 0x18A6
0018A4  EB4500     CLR.B W10
0018A6  554FE0     SUB.B W10, #0x0, [W15]
0018A8  320005     BRA Z, 0x18B4
137:               					acc = -prCsgNomAcc.l;
0018AA  208BC4     MOV #0x8BC, W4
0018AC  BE0214     MOV.D [W4], W4
0018AE  A2F005     BTG W5, #15
0018B0  BE8F04     MOV.D W4, [W14]
0018B2  370012     BRA 0x18D8
138:               				} else {
139:               					acc = -(prCsgNomVel.l + prCsgVel.l)*SAMPLE_FREQ;
0018B4  208B44     MOV #0x8B4, W4
0018B6  BE0314     MOV.D [W4], W6
0018B8  208AC4     MOV #0x8AC, W4
0018BA  BE0214     MOV.D [W4], W4
0018BC  BE0104     MOV.D W4, W2
0018BE  BE0006     MOV.D W6, W0
0018C0  07F678     RCALL ___addsf3
0018C2  BE0200     MOV.D W0, W4
0018C4  A2F005     BTG W5, #15
0018C6  200002     MOV #0x0, W2
0018C8  242C83     MOV #0x42C8, W3
0018CA  BE0004     MOV.D W4, W0
0018CC  07F757     RCALL ___mulsf3
0018CE  BE0200     MOV.D W0, W4
0018D0  BE8F04     MOV.D W4, [W14]
0018D2  370002     BRA 0x18D8
140:               				}
141:               			} else {
142:               				acc = 0;
0018D4  B82260     MUL.UU W4, #0, W4
0018D6  BE8F04     MOV.D W4, [W14]
143:               			}
144:               		}
145:               		prCsgPos.l += prCsgVel.l*TS + acc*SQR_TS_DEMI;
0018D8  2089C4     MOV #0x89C, W4
0018DA  BE0414     MOV.D [W4], W8
0018DC  208AC4     MOV #0x8AC, W4
0018DE  BE0214     MOV.D [W4], W4
0018E0  2D70A2     MOV #0xD70A, W2
0018E2  23C233     MOV #0x3C23, W3
0018E4  BE0004     MOV.D W4, W0
0018E6  07F74A     RCALL ___mulsf3
0018E8  BE0200     MOV.D W0, W4
0018EA  BE0504     MOV.D W4, W10
0018EC  2B7172     MOV #0xB717, W2
0018EE  238513     MOV #0x3851, W3
0018F0  BE001E     MOV.D [W14], W0
0018F2  07F744     RCALL ___mulsf3
0018F4  BE0200     MOV.D W0, W4
0018F6  BE0104     MOV.D W4, W2
0018F8  BE000A     MOV.D W10, W0
0018FA  07F65B     RCALL ___addsf3
0018FC  BE0200     MOV.D W0, W4
0018FE  BE0104     MOV.D W4, W2
001900  BE0008     MOV.D W8, W0
001902  07F657     RCALL ___addsf3
001904  BE0200     MOV.D W0, W4
001906  2089C6     MOV #0x89C, W6
001908  BE8B04     MOV.D W4, [W6]
146:               		prCsgVel.l += acc*TS;
00190A  208AC4     MOV #0x8AC, W4
00190C  BE0414     MOV.D [W4], W8
00190E  2D70A2     MOV #0xD70A, W2
001910  23C233     MOV #0x3C23, W3
001912  BE001E     MOV.D [W14], W0
001914  07F733     RCALL ___mulsf3
001916  BE0200     MOV.D W0, W4
001918  BE0104     MOV.D W4, W2
00191A  BE0008     MOV.D W8, W0
00191C  07F64A     RCALL ___addsf3
00191E  BE0200     MOV.D W0, W4
001920  208AC6     MOV #0x8AC, W6
001922  BE8B04     MOV.D W4, [W6]
147:               	}
148:               
149:               	if (abs(prCsgFinalPos.r - prCsgPos.r) <= prMinDist.r) {			// si la distance qu'il reste a parcourir est négligeable
001924  208A44     MOV #0x8A4, W4
001926  900324     MOV [W4+4], W6
001928  9003B4     MOV [W4+6], W7
00192A  2089C4     MOV #0x89C, W4
00192C  9002B4     MOV [W4+6], W5
00192E  900224     MOV [W4+4], W4
001930  BE0104     MOV.D W4, W2
001932  BE0006     MOV.D W6, W0
001934  07F635     RCALL ___subsf3
001936  BE0200     MOV.D W0, W4
001938  BE0004     MOV.D W4, W0
00193A  07F514     RCALL ___fixsfsi
00193C  BE0200     MOV.D W0, W4
00193E  780204     MOV W4, W4
001940  A7F004     BTSC W4, #15
001942  EA0204     NEG W4, W4
001944  DEA2CF     ASR W4, #15, W5
001946  BE0004     MOV.D W4, W0
001948  07F549     RCALL ___floatsisf
00194A  BE0300     MOV.D W0, W6
00194C  208C44     MOV #0x8C4, W4
00194E  9002B4     MOV [W4+6], W5
001950  900224     MOV [W4+4], W4
001952  B3C018     MOV #0x1, W8
001954  BE0104     MOV.D W4, W2
001956  BE0006     MOV.D W6, W0
001958  07F501     RCALL ___lesf2
00195A  780200     MOV W0, W4
00195C  520FE0     SUB W4, #0x0, [W15]
00195E  340001     BRA LE, 0x1962
001960  EB4400     CLR.B W8
001962  544FE0     SUB.B W8, #0x0, [W15]
001964  32000B     BRA Z, 0x197C
150:               		prCsgVel.r = 0;
001966  208AC6     MOV #0x8AC, W6
001968  B82260     MUL.UU W4, #0, W4
00196A  980324     MOV W4, [W6+4]
00196C  980335     MOV W5, [W6+6]
151:               		prCsgPos.r = prCsgFinalPos.r;
00196E  208A44     MOV #0x8A4, W4
001970  9002B4     MOV [W4+6], W5
001972  900224     MOV [W4+4], W4
001974  2089C6     MOV #0x89C, W6
001976  980324     MOV W4, [W6+4]
001978  980335     MOV W5, [W6+6]
00197A  370149     BRA 0x1C0E
152:               	} else {
153:               		state = CSG_MOVING;
00197C  200014     MOV #0x1, W4
00197E  980724     MOV W4, [W14+4]
154:               		sqrVel = prCsgVel.r*prCsgVel.r;
001980  208AC4     MOV #0x8AC, W4
001982  900324     MOV [W4+4], W6
001984  9003B4     MOV [W4+6], W7
001986  208AC4     MOV #0x8AC, W4
001988  9002B4     MOV [W4+6], W5
00198A  900224     MOV [W4+4], W4
00198C  BE0104     MOV.D W4, W2
00198E  BE0006     MOV.D W6, W0
001990  07F6F5     RCALL ___mulsf3
001992  BE0200     MOV.D W0, W4
001994  980734     MOV W4, [W14+6]
001996  980745     MOV W5, [W14+8]
155:               		tmp = prCsgPos.r + prCsgVel.r*TS + sign(prCsgVel.r)*sqrVel/(2*prCsgNomAcc.r);
001998  2089C4     MOV #0x89C, W4
00199A  900424     MOV [W4+4], W8
00199C  9004B4     MOV [W4+6], W9
00199E  208AC4     MOV #0x8AC, W4
0019A0  9002B4     MOV [W4+6], W5
0019A2  900224     MOV [W4+4], W4
0019A4  2D70A2     MOV #0xD70A, W2
0019A6  23C233     MOV #0x3C23, W3
0019A8  BE0004     MOV.D W4, W0
0019AA  07F6E8     RCALL ___mulsf3
0019AC  BE0200     MOV.D W0, W4
0019AE  BE0104     MOV.D W4, W2
0019B0  BE0008     MOV.D W8, W0
0019B2  07F5FF     RCALL ___addsf3
0019B4  BE0200     MOV.D W0, W4
0019B6  BE0404     MOV.D W4, W8
0019B8  208AC4     MOV #0x8AC, W4
0019BA  9002B4     MOV [W4+6], W5
0019BC  900224     MOV [W4+4], W4
0019BE  BE0004     MOV.D W4, W0
0019C0  07FD68     RCALL sign
0019C2  BE0200     MOV.D W0, W4
0019C4  90013E     MOV [W14+6], W2
0019C6  9001CE     MOV [W14+8], W3
0019C8  BE0004     MOV.D W4, W0
0019CA  07F6D8     RCALL ___mulsf3
0019CC  BE0200     MOV.D W0, W4
0019CE  BE0504     MOV.D W4, W10
0019D0  208BC4     MOV #0x8BC, W4
0019D2  9002B4     MOV [W4+6], W5
0019D4  900224     MOV [W4+4], W4
0019D6  BE0104     MOV.D W4, W2
0019D8  BE0004     MOV.D W4, W0
0019DA  07F5EB     RCALL ___addsf3
0019DC  BE0200     MOV.D W0, W4
0019DE  BE0104     MOV.D W4, W2
0019E0  BE000A     MOV.D W10, W0
0019E2  07F7FC     RCALL ___divsf3x
0019E4  BE0200     MOV.D W0, W4
0019E6  BE0104     MOV.D W4, W2
0019E8  BE0008     MOV.D W8, W0
0019EA  07F5E3     RCALL ___addsf3
0019EC  BE0200     MOV.D W0, W4
0019EE  980754     MOV W4, [W14+10]
0019F0  980765     MOV W5, [W14+12]
156:               		if (prCsgPos.r < prCsgFinalPos.r) {
0019F2  2089C4     MOV #0x89C, W4
0019F4  900324     MOV [W4+4], W6
0019F6  9003B4     MOV [W4+6], W7
0019F8  208A44     MOV #0x8A4, W4
0019FA  9002B4     MOV [W4+6], W5
0019FC  900224     MOV [W4+4], W4
0019FE  B3C018     MOV #0x1, W8
001A00  BE0104     MOV.D W4, W2
001A02  BE0006     MOV.D W6, W0
001A04  07F4AB     RCALL ___lesf2
001A06  780200     MOV W0, W4
001A08  520FE0     SUB W4, #0x0, [W15]
001A0A  350001     BRA LT, 0x1A0E
001A0C  EB4400     CLR.B W8
001A0E  544FE0     SUB.B W8, #0x0, [W15]
001A10  320068     BRA Z, 0x1AE2
157:               			if (tmp > prCsgFinalPos.r) {
001A12  208A44     MOV #0x8A4, W4
001A14  9002B4     MOV [W4+6], W5
001A16  900224     MOV [W4+4], W4
001A18  B3C018     MOV #0x1, W8
001A1A  90015E     MOV [W14+10], W2
001A1C  9001EE     MOV [W14+12], W3
001A1E  BE0004     MOV.D W4, W0
001A20  07F49D     RCALL ___lesf2
001A22  780200     MOV W0, W4
001A24  520FE0     SUB W4, #0x0, [W15]
001A26  350001     BRA LT, 0x1A2A
001A28  EB4400     CLR.B W8
001A2A  544FE0     SUB.B W8, #0x0, [W15]
001A2C  320015     BRA Z, 0x1A58
158:               				acc = sqrVel/(2*(prCsgPos.r - prCsgFinalPos.r));
001A2E  2089C4     MOV #0x89C, W4
001A30  900324     MOV [W4+4], W6
001A32  9003B4     MOV [W4+6], W7
001A34  208A44     MOV #0x8A4, W4
001A36  9002B4     MOV [W4+6], W5
001A38  900224     MOV [W4+4], W4
001A3A  BE0104     MOV.D W4, W2
001A3C  BE0006     MOV.D W6, W0
001A3E  07F5B0     RCALL ___subsf3
001A40  BE0200     MOV.D W0, W4
001A42  BE0104     MOV.D W4, W2
001A44  BE0004     MOV.D W4, W0
001A46  07F5B5     RCALL ___addsf3
001A48  BE0200     MOV.D W0, W4
001A4A  BE0104     MOV.D W4, W2
001A4C  90003E     MOV [W14+6], W0
001A4E  9000CE     MOV [W14+8], W1
001A50  07F7C5     RCALL ___divsf3x
001A52  BE0200     MOV.D W0, W4
001A54  BE8F04     MOV.D W4, [W14]
001A56  3700B0     BRA 0x1BB8
159:               			} else if (prCsgVel.r < prCsgNomVel.r) {
001A58  208AC4     MOV #0x8AC, W4
001A5A  900324     MOV [W4+4], W6
001A5C  9003B4     MOV [W4+6], W7
001A5E  208B44     MOV #0x8B4, W4
001A60  9002B4     MOV [W4+6], W5
001A62  900224     MOV [W4+4], W4
001A64  B3C018     MOV #0x1, W8
001A66  BE0104     MOV.D W4, W2
001A68  BE0006     MOV.D W6, W0
001A6A  07F478     RCALL ___lesf2
001A6C  780200     MOV W0, W4
001A6E  520FE0     SUB W4, #0x0, [W15]
001A70  350001     BRA LT, 0x1A74
001A72  EB4400     CLR.B W8
001A74  544FE0     SUB.B W8, #0x0, [W15]
001A76  320032     BRA Z, 0x1ADC
160:               				if (prCsgVel.r < prCsgNomVel.r-prCsgNomAcc.r*TS) {
001A78  208AC4     MOV #0x8AC, W4
001A7A  900424     MOV [W4+4], W8
001A7C  9004B4     MOV [W4+6], W9
001A7E  208B44     MOV #0x8B4, W4
001A80  900524     MOV [W4+4], W10
001A82  9005B4     MOV [W4+6], W11
001A84  208BC4     MOV #0x8BC, W4
001A86  9002B4     MOV [W4+6], W5
001A88  900224     MOV [W4+4], W4
001A8A  2D70A2     MOV #0xD70A, W2
001A8C  23C233     MOV #0x3C23, W3
001A8E  BE0004     MOV.D W4, W0
001A90  07F675     RCALL ___mulsf3
001A92  BE0200     MOV.D W0, W4
001A94  BE0104     MOV.D W4, W2
001A96  BE000A     MOV.D W10, W0
001A98  07F583     RCALL ___subsf3
001A9A  BE0200     MOV.D W0, W4
001A9C  B3C01A     MOV #0x1, W10
001A9E  BE0104     MOV.D W4, W2
001AA0  BE0008     MOV.D W8, W0
001AA2  07F45C     RCALL ___lesf2
001AA4  780200     MOV W0, W4
001AA6  520FE0     SUB W4, #0x0, [W15]
001AA8  350001     BRA LT, 0x1AAC
001AAA  EB4500     CLR.B W10
001AAC  554FE0     SUB.B W10, #0x0, [W15]
001AAE  320005     BRA Z, 0x1ABA
161:               					acc = prCsgNomAcc.r;
001AB0  208BC4     MOV #0x8BC, W4
001AB2  900324     MOV [W4+4], W6
001AB4  9003B4     MOV [W4+6], W7
001AB6  BE8F06     MOV.D W6, [W14]
001AB8  37007F     BRA 0x1BB8
162:               				} else {
163:               					acc = (prCsgNomVel.r - prCsgVel.r)*SAMPLE_FREQ;
001ABA  208B44     MOV #0x8B4, W4
001ABC  900324     MOV [W4+4], W6
001ABE  9003B4     MOV [W4+6], W7
001AC0  208AC4     MOV #0x8AC, W4
001AC2  9002B4     MOV [W4+6], W5
001AC4  900224     MOV [W4+4], W4
001AC6  BE0104     MOV.D W4, W2
001AC8  BE0006     MOV.D W6, W0
001ACA  07F56A     RCALL ___subsf3
001ACC  BE0200     MOV.D W0, W4
001ACE  200002     MOV #0x0, W2
001AD0  242C83     MOV #0x42C8, W3
001AD2  BE0004     MOV.D W4, W0
001AD4  07F653     RCALL ___mulsf3
001AD6  BE0200     MOV.D W0, W4
001AD8  BE8F04     MOV.D W4, [W14]
001ADA  37006E     BRA 0x1BB8
164:               				}
165:               			} else {
166:               				acc = 0;
001ADC  B82260     MUL.UU W4, #0, W4
001ADE  BE8F04     MOV.D W4, [W14]
001AE0  37006B     BRA 0x1BB8
167:               			}
168:               		} else {
169:               			if (tmp < prCsgFinalPos.r) {
001AE2  208A44     MOV #0x8A4, W4
001AE4  9002B4     MOV [W4+6], W5
001AE6  900224     MOV [W4+4], W4
001AE8  B3C018     MOV #0x1, W8
001AEA  90015E     MOV [W14+10], W2
001AEC  9001EE     MOV [W14+12], W3
001AEE  BE0004     MOV.D W4, W0
001AF0  07F437     RCALL ___gtsf2
001AF2  780200     MOV W0, W4
001AF4  520FE0     SUB W4, #0x0, [W15]
001AF6  3C0001     BRA GT, 0x1AFA
001AF8  EB4400     CLR.B W8
001AFA  544FE0     SUB.B W8, #0x0, [W15]
001AFC  320015     BRA Z, 0x1B28
170:               				acc = sqrVel/(2*(prCsgPos.r - prCsgFinalPos.r));
001AFE  2089C4     MOV #0x89C, W4
001B00  900324     MOV [W4+4], W6
001B02  9003B4     MOV [W4+6], W7
001B04  208A44     MOV #0x8A4, W4
001B06  9002B4     MOV [W4+6], W5
001B08  900224     MOV [W4+4], W4
001B0A  BE0104     MOV.D W4, W2
001B0C  BE0006     MOV.D W6, W0
001B0E  07F548     RCALL ___subsf3
001B10  BE0200     MOV.D W0, W4
001B12  BE0104     MOV.D W4, W2
001B14  BE0004     MOV.D W4, W0
001B16  07F54D     RCALL ___addsf3
001B18  BE0200     MOV.D W0, W4
001B1A  BE0104     MOV.D W4, W2
001B1C  90003E     MOV [W14+6], W0
001B1E  9000CE     MOV [W14+8], W1
001B20  07F75D     RCALL ___divsf3x
001B22  BE0200     MOV.D W0, W4
001B24  BE8F04     MOV.D W4, [W14]
001B26  370048     BRA 0x1BB8
171:               			} else if (prCsgVel.r > -prCsgNomVel.r) {
001B28  208AC4     MOV #0x8AC, W4
001B2A  900324     MOV [W4+4], W6
001B2C  9003B4     MOV [W4+6], W7
001B2E  208B44     MOV #0x8B4, W4
001B30  9002B4     MOV [W4+6], W5
001B32  900224     MOV [W4+4], W4
001B34  A2F005     BTG W5, #15
001B36  B3C018     MOV #0x1, W8
001B38  BE0104     MOV.D W4, W2
001B3A  BE0006     MOV.D W6, W0
001B3C  07F411     RCALL ___gtsf2
001B3E  780200     MOV W0, W4
001B40  520FE0     SUB W4, #0x0, [W15]
001B42  3C0001     BRA GT, 0x1B46
001B44  EB4400     CLR.B W8
001B46  544FE0     SUB.B W8, #0x0, [W15]
001B48  320035     BRA Z, 0x1BB4
172:               				if (prCsgVel.r > prCsgNomAcc.r*TS - prCsgNomVel.r) {
001B4A  208AC4     MOV #0x8AC, W4
001B4C  900424     MOV [W4+4], W8
001B4E  9004B4     MOV [W4+6], W9
001B50  208BC4     MOV #0x8BC, W4
001B52  9002B4     MOV [W4+6], W5
001B54  900224     MOV [W4+4], W4
001B56  2D70A2     MOV #0xD70A, W2
001B58  23C233     MOV #0x3C23, W3
001B5A  BE0004     MOV.D W4, W0
001B5C  07F60F     RCALL ___mulsf3
001B5E  BE0200     MOV.D W0, W4
001B60  BE0304     MOV.D W4, W6
001B62  208B44     MOV #0x8B4, W4
001B64  9002B4     MOV [W4+6], W5
001B66  900224     MOV [W4+4], W4
001B68  BE0104     MOV.D W4, W2
001B6A  BE0006     MOV.D W6, W0
001B6C  07F519     RCALL ___subsf3
001B6E  BE0200     MOV.D W0, W4
001B70  B3C01A     MOV #0x1, W10
001B72  BE0104     MOV.D W4, W2
001B74  BE0008     MOV.D W8, W0
001B76  07F3F4     RCALL ___gtsf2
001B78  780200     MOV W0, W4
001B7A  520FE0     SUB W4, #0x0, [W15]
001B7C  3C0001     BRA GT, 0x1B80
001B7E  EB4500     CLR.B W10
001B80  554FE0     SUB.B W10, #0x0, [W15]
001B82  320006     BRA Z, 0x1B90
173:               					acc = -prCsgNomAcc.r;
001B84  208BC4     MOV #0x8BC, W4
001B86  9002B4     MOV [W4+6], W5
001B88  900224     MOV [W4+4], W4
001B8A  A2F005     BTG W5, #15
001B8C  BE8F04     MOV.D W4, [W14]
001B8E  370014     BRA 0x1BB8
174:               				} else {
175:               					acc = -(prCsgNomVel.r + prCsgVel.r)*SAMPLE_FREQ;
001B90  208B44     MOV #0x8B4, W4
001B92  900324     MOV [W4+4], W6
001B94  9003B4     MOV [W4+6], W7
001B96  208AC4     MOV #0x8AC, W4
001B98  9002B4     MOV [W4+6], W5
001B9A  900224     MOV [W4+4], W4
001B9C  BE0104     MOV.D W4, W2
001B9E  BE0006     MOV.D W6, W0
001BA0  07F508     RCALL ___addsf3
001BA2  BE0200     MOV.D W0, W4
001BA4  A2F005     BTG W5, #15
001BA6  200002     MOV #0x0, W2
001BA8  242C83     MOV #0x42C8, W3
001BAA  BE0004     MOV.D W4, W0
001BAC  07F5E7     RCALL ___mulsf3
001BAE  BE0200     MOV.D W0, W4
001BB0  BE8F04     MOV.D W4, [W14]
001BB2  370002     BRA 0x1BB8
176:               				}
177:               			} else {
178:               				acc = 0;
001BB4  B82260     MUL.UU W4, #0, W4
001BB6  BE8F04     MOV.D W4, [W14]
179:               			}
180:               		}
181:               		prCsgPos.r += prCsgVel.r*TS + acc*SQR_TS_DEMI;
001BB8  2089C4     MOV #0x89C, W4
001BBA  900424     MOV [W4+4], W8
001BBC  9004B4     MOV [W4+6], W9
001BBE  208AC4     MOV #0x8AC, W4
001BC0  9002B4     MOV [W4+6], W5
001BC2  900224     MOV [W4+4], W4
001BC4  2D70A2     MOV #0xD70A, W2
001BC6  23C233     MOV #0x3C23, W3
001BC8  BE0004     MOV.D W4, W0
001BCA  07F5D8     RCALL ___mulsf3
001BCC  BE0200     MOV.D W0, W4
001BCE  BE0504     MOV.D W4, W10
001BD0  2B7172     MOV #0xB717, W2
001BD2  238513     MOV #0x3851, W3
001BD4  BE001E     MOV.D [W14], W0
001BD6  07F5D2     RCALL ___mulsf3
001BD8  BE0200     MOV.D W0, W4
001BDA  BE0104     MOV.D W4, W2
001BDC  BE000A     MOV.D W10, W0
001BDE  07F4E9     RCALL ___addsf3
001BE0  BE0200     MOV.D W0, W4
001BE2  BE0104     MOV.D W4, W2
001BE4  BE0008     MOV.D W8, W0
001BE6  07F4E5     RCALL ___addsf3
001BE8  BE0200     MOV.D W0, W4
001BEA  2089C6     MOV #0x89C, W6
001BEC  980324     MOV W4, [W6+4]
001BEE  980335     MOV W5, [W6+6]
182:               		prCsgVel.r += acc*TS;
001BF0  208AC4     MOV #0x8AC, W4
001BF2  900424     MOV [W4+4], W8
001BF4  9004B4     MOV [W4+6], W9
001BF6  2D70A2     MOV #0xD70A, W2
001BF8  23C233     MOV #0x3C23, W3
001BFA  BE001E     MOV.D [W14], W0
001BFC  07F5BF     RCALL ___mulsf3
001BFE  BE0200     MOV.D W0, W4
001C00  BE0104     MOV.D W4, W2
001C02  BE0008     MOV.D W8, W0
001C04  07F4D6     RCALL ___addsf3
001C06  BE0200     MOV.D W0, W4
001C08  208AC6     MOV #0x8AC, W6
001C0A  980324     MOV W4, [W6+4]
001C0C  980335     MOV W5, [W6+6]
183:               	}
184:               	prCsgStatus = state;
001C0E  9003AE     MOV [W14+4], W7
001C10  884667     MOV W7, prCsgStatus
185:               	return(prCsgStatus);
001C12  804664     MOV prCsgStatus, W4
186:               }
001C14  780004     MOV W4, W0
001C16  BE054F     MOV.D [--W15], W10
001C18  BE044F     MOV.D [--W15], W8
001C1A  FA8000     ULNK
001C1C  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/Regulator.c  -----------------------------------------
1:                 #include "Configware.h"
2:                 #include "globals.h"
3:                 #include "Consigne.h"
4:                 #include "motors.h"
5:                 #include <math.h>
6:                 #include "odoLibre.h"
7:                 #include "Regulator.h"
8:                 
9:                 #define MAXT				20E-3
10:                #define MAXR				100E-3
11:                #define KV_T			 	1		// gain du rÈgulateur de vitesse linÈaire=> terme dÈrivÈ en l
12:                #define KV_R				50E-3	// gain du rÈgulateur de vitesse angulaire=> terme dÈrivÈ en r
13:                #define KP_T				25		// gain du rÈgulateur de position longitudinal=> terme proportionnel en l
14:                #define KP_R				2.8		// gain du rÈgulateur de position transversal=> terme proportionnel en r
15:                #define DC_MAX_DELTA		0.01	// variation maximale du rapport cyclique des moteurs pour une pÈriode
16:                
17:                
18:                float prRegOldDcLeft, prRegOldDcRight;
19:                
20:                
21:                void regInit(void) {
003308  FA0000     LNK #0x0
22:                	prRegOldDcLeft = 0;
00330A  B82260     MUL.UU W4, #0, W4
00330C  884814     MOV W4, prRegOldDcLeft
00330E  884825     MOV W5, 0x904
23:                	prRegOldDcRight = 0;
003310  B82260     MUL.UU W4, #0, W4
003312  884834     MOV W4, prRegOldDcRight
003314  884845     MOV W5, 0x908
24:                }
003316  FA8000     ULNK
003318  060000     RETURN
25:                
26:                regType regCompute(void) {
00331A  FA0040     LNK #0x40
00331C  BE9F88     MOV.D W8, [W15++]
27:                	relativeCoord odoPos = odoGetRelPos();
00331E  200204     MOV #0x20, W4
003320  42020E     ADD W4, W14, W4
003322  780004     MOV W4, W0
003324  07FFB9     RCALL odoGetRelPos
28:                	relativeCoord csgPos = csgGetPos();
003326  200284     MOV #0x28, W4
003328  42020E     ADD W4, W14, W4
00332A  780004     MOV W4, W0
00332C  07F16D     RCALL csgGetPos
29:                	relativeCoord odoVel = odoGetRelVel();
00332E  200304     MOV #0x30, W4
003330  42020E     ADD W4, W14, W4
003332  780004     MOV W4, W0
003334  07FFA3     RCALL odoGetRelVel
30:                	relativeCoord csgVel = csgGetVel();
003336  200384     MOV #0x38, W4
003338  42020E     ADD W4, W14, W4
00333A  780004     MOV W4, W0
00333C  07F157     RCALL csgGetVel
31:                	float errT, errR, errVt, errVr;
32:                	float dcTrans, dcRot, dcLeft, dcRight;
33:                
34:                	// On calcule les erreurs
35:                	errT = csgPos.l - odoPos.l;
00333E  90134E     MOV [W14+40], W6
003340  9013DE     MOV [W14+42], W7
003342  90120E     MOV [W14+32], W4
003344  90129E     MOV [W14+34], W5
003346  BE0104     MOV.D W4, W2
003348  BE0006     MOV.D W6, W0
00334A  07E92A     RCALL ___subsf3
00334C  BE0200     MOV.D W0, W4
00334E  980744     MOV W4, [W14+8]
003350  980755     MOV W5, [W14+10]
36:                	errR = csgPos.r - odoPos.r;
003352  90136E     MOV [W14+44], W6
003354  9013FE     MOV [W14+46], W7
003356  90122E     MOV [W14+36], W4
003358  9012BE     MOV [W14+38], W5
00335A  BE0104     MOV.D W4, W2
00335C  BE0006     MOV.D W6, W0
00335E  07E920     RCALL ___subsf3
003360  BE0200     MOV.D W0, W4
003362  980764     MOV W4, [W14+12]
003364  980775     MOV W5, [W14+14]
37:                	errVt = csgVel.l - odoVel.l;
003366  901B4E     MOV [W14+56], W6
003368  901BDE     MOV [W14+58], W7
00336A  901A0E     MOV [W14+48], W4
00336C  901A9E     MOV [W14+50], W5
00336E  BE0104     MOV.D W4, W2
003370  BE0006     MOV.D W6, W0
003372  07E916     RCALL ___subsf3
003374  BE0200     MOV.D W0, W4
003376  980F04     MOV W4, [W14+16]
003378  980F15     MOV W5, [W14+18]
38:                	errVr = csgVel.r - odoVel.r;
00337A  901B6E     MOV [W14+60], W6
00337C  901BFE     MOV [W14+62], W7
00337E  901A2E     MOV [W14+52], W4
003380  901ABE     MOV [W14+54], W5
003382  BE0104     MOV.D W4, W2
003384  BE0006     MOV.D W6, W0
003386  07E90C     RCALL ___subsf3
003388  BE0200     MOV.D W0, W4
00338A  980F24     MOV W4, [W14+20]
00338C  980F35     MOV W5, [W14+22]
39:                	// on calcule la sortie des rÈgulateurs de vitesse
40:                	dcTrans = KP_T*errT + KV_T*errVt;
00338E  200002     MOV #0x0, W2
003390  241C83     MOV #0x41C8, W3
003392  90004E     MOV [W14+8], W0
003394  9000DE     MOV [W14+10], W1
003396  07E9F2     RCALL ___mulsf3
003398  BE0200     MOV.D W0, W4
00339A  90090E     MOV [W14+16], W2
00339C  90099E     MOV [W14+18], W3
00339E  BE0004     MOV.D W4, W0
0033A0  07E908     RCALL ___addsf3
0033A2  BE0200     MOV.D W0, W4
0033A4  980F44     MOV W4, [W14+24]
0033A6  980F55     MOV W5, [W14+26]
41:                	dcRot = KP_R*errR + KV_R*errVr;
0033A8  233332     MOV #0x3333, W2
0033AA  240333     MOV #0x4033, W3
0033AC  90006E     MOV [W14+12], W0
0033AE  9000FE     MOV [W14+14], W1
0033B0  07E9E5     RCALL ___mulsf3
0033B2  BE0200     MOV.D W0, W4
0033B4  BE0404     MOV.D W4, W8
0033B6  2CCCD2     MOV #0xCCCD, W2
0033B8  23D4C3     MOV #0x3D4C, W3
0033BA  90082E     MOV [W14+20], W0
0033BC  9008BE     MOV [W14+22], W1
0033BE  07E9DE     RCALL ___mulsf3
0033C0  BE0200     MOV.D W0, W4
0033C2  BE0104     MOV.D W4, W2
0033C4  BE0008     MOV.D W8, W0
0033C6  07E8F5     RCALL ___addsf3
0033C8  BE0200     MOV.D W0, W4
0033CA  980F64     MOV W4, [W14+28]
0033CC  980F75     MOV W5, [W14+30]
42:                	// on fait le changement de variables entre les rapports cycliques en translation/rotation
43:                	// et ceux en droite/gauche
44:                	dcRight = dcTrans + dcRot;
0033CE  90096E     MOV [W14+28], W2
0033D0  9009FE     MOV [W14+30], W3
0033D2  90084E     MOV [W14+24], W0
0033D4  9008DE     MOV [W14+26], W1
0033D6  07E8ED     RCALL ___addsf3
0033D8  BE0200     MOV.D W0, W4
0033DA  980724     MOV W4, [W14+4]
0033DC  980735     MOV W5, [W14+6]
45:                	dcLeft = dcTrans - dcRot;
0033DE  90096E     MOV [W14+28], W2
0033E0  9009FE     MOV [W14+30], W3
0033E2  90084E     MOV [W14+24], W0
0033E4  9008DE     MOV [W14+26], W1
0033E6  07E8DC     RCALL ___subsf3
0033E8  BE0200     MOV.D W0, W4
0033EA  BE8F04     MOV.D W4, [W14]
46:                	// on limite la variation des rapports cycliques
47:                	if ((dcRight - prRegOldDcRight) > DC_MAX_DELTA) {
0033EC  804834     MOV prRegOldDcRight, W4
0033EE  804845     MOV 0x908, W5
0033F0  BE0104     MOV.D W4, W2
0033F2  90002E     MOV [W14+4], W0
0033F4  9000BE     MOV [W14+6], W1
0033F6  07E8D4     RCALL ___subsf3
0033F8  BE0200     MOV.D W0, W4
0033FA  B3C018     MOV #0x1, W8
0033FC  2D70A2     MOV #0xD70A, W2
0033FE  23C233     MOV #0x3C23, W3
003400  BE0004     MOV.D W4, W0
003402  07E7AE     RCALL ___gtsf2
003404  780200     MOV W0, W4
003406  520FE0     SUB W4, #0x0, [W15]
003408  3C0001     BRA GT, 0x340C
00340A  EB4400     CLR.B W8
00340C  544FE0     SUB.B W8, #0x0, [W15]
00340E  32000A     BRA Z, 0x3424
48:                		dcRight = prRegOldDcRight + DC_MAX_DELTA;
003410  804834     MOV prRegOldDcRight, W4
003412  804845     MOV 0x908, W5
003414  2D70A2     MOV #0xD70A, W2
003416  23C233     MOV #0x3C23, W3
003418  BE0004     MOV.D W4, W0
00341A  07E8CB     RCALL ___addsf3
00341C  BE0200     MOV.D W0, W4
00341E  980724     MOV W4, [W14+4]
003420  980735     MOV W5, [W14+6]
003422  37001B     BRA 0x345A
49:                	} else if ((prRegOldDcRight - dcRight) > DC_MAX_DELTA) {
003424  804834     MOV prRegOldDcRight, W4
003426  804845     MOV 0x908, W5
003428  90012E     MOV [W14+4], W2
00342A  9001BE     MOV [W14+6], W3
00342C  BE0004     MOV.D W4, W0
00342E  07E8B8     RCALL ___subsf3
003430  BE0200     MOV.D W0, W4
003432  B3C018     MOV #0x1, W8
003434  2D70A2     MOV #0xD70A, W2
003436  23C233     MOV #0x3C23, W3
003438  BE0004     MOV.D W4, W0
00343A  07E792     RCALL ___gtsf2
00343C  780200     MOV W0, W4
00343E  520FE0     SUB W4, #0x0, [W15]
003440  3C0001     BRA GT, 0x3444
003442  EB4400     CLR.B W8
003444  544FE0     SUB.B W8, #0x0, [W15]
003446  320009     BRA Z, 0x345A
50:                		dcRight = prRegOldDcRight - DC_MAX_DELTA;
003448  804834     MOV prRegOldDcRight, W4
00344A  804845     MOV 0x908, W5
00344C  2D70A2     MOV #0xD70A, W2
00344E  23C233     MOV #0x3C23, W3
003450  BE0004     MOV.D W4, W0
003452  07E8A6     RCALL ___subsf3
003454  BE0200     MOV.D W0, W4
003456  980724     MOV W4, [W14+4]
003458  980735     MOV W5, [W14+6]
51:                	}
52:                	prRegOldDcRight = dcRight;
00345A  90022E     MOV [W14+4], W4
00345C  9002BE     MOV [W14+6], W5
00345E  884834     MOV W4, prRegOldDcRight
003460  884845     MOV W5, 0x908
53:                	if ((dcLeft - prRegOldDcLeft) > DC_MAX_DELTA) {
003462  804814     MOV prRegOldDcLeft, W4
003464  804825     MOV 0x904, W5
003466  BE0104     MOV.D W4, W2
003468  BE001E     MOV.D [W14], W0
00346A  07E89A     RCALL ___subsf3
00346C  BE0200     MOV.D W0, W4
00346E  B3C018     MOV #0x1, W8
003470  2D70A2     MOV #0xD70A, W2
003472  23C233     MOV #0x3C23, W3
003474  BE0004     MOV.D W4, W0
003476  07E774     RCALL ___gtsf2
003478  780200     MOV W0, W4
00347A  520FE0     SUB W4, #0x0, [W15]
00347C  3C0001     BRA GT, 0x3480
00347E  EB4400     CLR.B W8
003480  544FE0     SUB.B W8, #0x0, [W15]
003482  320009     BRA Z, 0x3496
54:                		dcLeft = prRegOldDcLeft + DC_MAX_DELTA;
003484  804814     MOV prRegOldDcLeft, W4
003486  804825     MOV 0x904, W5
003488  2D70A2     MOV #0xD70A, W2
00348A  23C233     MOV #0x3C23, W3
00348C  BE0004     MOV.D W4, W0
00348E  07E891     RCALL ___addsf3
003490  BE0200     MOV.D W0, W4
003492  BE8F04     MOV.D W4, [W14]
003494  370019     BRA 0x34C8
55:                	} else if ((prRegOldDcLeft - dcLeft) > DC_MAX_DELTA) {
003496  804814     MOV prRegOldDcLeft, W4
003498  804825     MOV 0x904, W5
00349A  BE011E     MOV.D [W14], W2
00349C  BE0004     MOV.D W4, W0
00349E  07E880     RCALL ___subsf3
0034A0  BE0200     MOV.D W0, W4
0034A2  B3C018     MOV #0x1, W8
0034A4  2D70A2     MOV #0xD70A, W2
0034A6  23C233     MOV #0x3C23, W3
0034A8  BE0004     MOV.D W4, W0
0034AA  07E75A     RCALL ___gtsf2
0034AC  780200     MOV W0, W4
0034AE  520FE0     SUB W4, #0x0, [W15]
0034B0  3C0001     BRA GT, 0x34B4
0034B2  EB4400     CLR.B W8
0034B4  544FE0     SUB.B W8, #0x0, [W15]
0034B6  320008     BRA Z, 0x34C8
56:                		dcLeft = prRegOldDcLeft - DC_MAX_DELTA;
0034B8  804814     MOV prRegOldDcLeft, W4
0034BA  804825     MOV 0x904, W5
0034BC  2D70A2     MOV #0xD70A, W2
0034BE  23C233     MOV #0x3C23, W3
0034C0  BE0004     MOV.D W4, W0
0034C2  07E86E     RCALL ___subsf3
0034C4  BE0200     MOV.D W0, W4
0034C6  BE8F04     MOV.D W4, [W14]
57:                	}
58:                	prRegOldDcLeft = dcLeft;
0034C8  BE021E     MOV.D [W14], W4
0034CA  884814     MOV W4, prRegOldDcLeft
0034CC  884825     MOV W5, 0x904
59:                	motorsSetSpeed(dcRight, dcLeft); // on applique les nouvelles commandes aux moteurs
0034CE  BE011E     MOV.D [W14], W2
0034D0  90002E     MOV [W14+4], W0
0034D2  9000BE     MOV [W14+6], W1
0034D4  07025D     RCALL motorsSetSpeed
60:                	// détecte le patinage sur base des erreurs de position
61:                	if ((fabs(errT) > MAXT) || (fabs(errR) > MAXR)) {
0034D6  90024E     MOV [W14+8], W4
0034D8  9002DE     MOV [W14+10], W5
0034DA  A1F005     BCLR W5, #15
0034DC  B3C018     MOV #0x1, W8
0034DE  2D70A2     MOV #0xD70A, W2
0034E0  23CA33     MOV #0x3CA3, W3
0034E2  BE0004     MOV.D W4, W0
0034E4  07E73D     RCALL ___gtsf2
0034E6  780200     MOV W0, W4
0034E8  520FE0     SUB W4, #0x0, [W15]
0034EA  3C0001     BRA GT, 0x34EE
0034EC  EB4400     CLR.B W8
0034EE  544FE0     SUB.B W8, #0x0, [W15]
0034F0  3A000E     BRA NZ, 0x350E
0034F2  90026E     MOV [W14+12], W4
0034F4  9002FE     MOV [W14+14], W5
0034F6  A1F005     BCLR W5, #15
0034F8  B3C018     MOV #0x1, W8
0034FA  2CCCD2     MOV #0xCCCD, W2
0034FC  23DCC3     MOV #0x3DCC, W3
0034FE  BE0004     MOV.D W4, W0
003500  07E72F     RCALL ___gtsf2
003502  780200     MOV W0, W4
003504  520FE0     SUB W4, #0x0, [W15]
003506  3C0001     BRA GT, 0x350A
003508  EB4400     CLR.B W8
00350A  544FE0     SUB.B W8, #0x0, [W15]
00350C  320002     BRA Z, 0x3512
62:                        return(PATINAGE_DETECTED);
00350E  200014     MOV #0x1, W4
003510  370001     BRA 0x3514
63:                	} else {
64:                		return(NO_PATINAGE);
003512  EB0200     CLR W4
65:                	}
66:                }
003514  780004     MOV W4, W0
003516  BE044F     MOV.D [--W15], W8
003518  FA8000     ULNK
00351A  060000     RETURN
67:                
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/Motors.c  --------------------------------------------
1:                 #include "Configware.h"
2:                 #include "Motors.h"
3:                 #include "../Peripherals/pps.h"
4:                 #include "../Peripherals/pwm.h"
5:                 #include "../Peripherals/timers.h"
6:                 #include <xc.h>
7:                 
8:                 
9:                 #define PWM_PERIOD	50E-3	// période de la pwm, en  ms
10:                // limitation du DC max nécessaire pour les bootstraps du driver
11:                #define MAX_DC		1980
12:                #define MIN_DC		20
13:                
14:                // Pattes du driver moteurs
15:                #define EN_R1		LATAbits.LATA8
16:                #define EN_R2		LATCbits.LATC1		// /!\ c'est AN7
17:                #define EN_L1		LATBbits.LATB15
18:                #define EN_L2		LATAbits.LATA7
19:                #define PWM_R1		(1)
20:                #define PWM_R2		(2)
21:                #define PWM_L1		(3)
22:                #define PWM_L2		(4)
23:                
24:                
25:                void motorsInit(void) {
0038E8  FA0000     LNK #0x0
26:                	// assignation des pattes des PWM
27:                	ppsOutConfig(PPS_OC1, 18);	// OC1 -> RP18	(PWM_R1)
0038EA  200121     MOV #0x12, W1
0038EC  200120     MOV #0x12, W0
0038EE  07F6B5     RCALL ppsOutConfig
28:                	AD1PCFGLbits.PCFG8 = 1;		// AN8/RP18 en numérique
0038F0  A8032D     BSET 0x32D, #0
29:                	ppsOutConfig(PPS_OC2, 16);	// OC2 -> RP16	(PWM_R2)
0038F2  200101     MOV #0x10, W1
0038F4  200130     MOV #0x13, W0
0038F6  07F6B1     RCALL ppsOutConfig
30:                	AD1PCFGLbits.PCFG6 = 1;		// AN6/RP16 en numérique
0038F8  A8C32C     BSET AD1PCFGL, #6
31:                	ppsOutConfig(PPS_OC3, 14);	// OC3 -> RP14	(PWM_L1)
0038FA  2000E1     MOV #0xE, W1
0038FC  200140     MOV #0x14, W0
0038FE  07F6AD     RCALL ppsOutConfig
32:                	ppsOutConfig(PPS_OC4, 13);	// OC4 -> RP13	(PWM_L2)
003900  2000D1     MOV #0xD, W1
003902  200150     MOV #0x15, W0
003904  07F6AA     RCALL ppsOutConfig
33:                	// désactivation des enable tant qu'on n'a pas besoin du driver
34:                	// recommandé quand les alim sont activées
35:                	EN_R1 = 0;
003906  A902C5     BCLR 0x2C5, #0
36:                	EN_R2 = 0;
003908  A922D4     BCLR LATC, #1
37:                	EN_L1 = 0;
00390A  A9E2CD     BCLR 0x2CD, #7
38:                	EN_L2 = 0;
00390C  A9E2C4     BCLR LATA, #7
39:                	// assignation des pattes des EN
40:                	TRISAbits.TRISA8 = 0;
00390E  A902C1     BCLR 0x2C1, #0
41:                	TRISCbits.TRISC1 = 0;
003910  A922D0     BCLR TRISC, #1
42:                	AD1PCFGLbits.PCFG7 = 1;	// AN7/RC1 en numérique
003912  A8E32C     BSET AD1PCFGL, #7
43:                	TRISBbits.TRISB15 = 0;
003914  A9E2C9     BCLR 0x2C9, #7
44:                	TRISAbits.TRISA7 = 0;
003916  A9E2C0     BCLR TRISA, #7
45:                	// configuration des pwm
46:                	 pwmSetup(PWM_R1, 2, PWM_PERIOD);		// active la pwmR1, couplée au timer2, avec une période de 50us
003918  2CCCD2     MOV #0xCCCD, W2
00391A  23D4C3     MOV #0x3D4C, W3
00391C  200021     MOV #0x2, W1
00391E  200010     MOV #0x1, W0
003920  07F8D1     RCALL pwmSetup
47:                	 pwmSetup(PWM_R2, 2, PWM_PERIOD);		// active la pwmR2, couplée au timer2, avec une période de 50us
003922  2CCCD2     MOV #0xCCCD, W2
003924  23D4C3     MOV #0x3D4C, W3
003926  200021     MOV #0x2, W1
003928  200020     MOV #0x2, W0
00392A  07F8CC     RCALL pwmSetup
48:                	 pwmSetup(PWM_L1, 2, PWM_PERIOD);		// active la pwmL1, couplée au timer2, avec une période de 50us
00392C  2CCCD2     MOV #0xCCCD, W2
00392E  23D4C3     MOV #0x3D4C, W3
003930  200021     MOV #0x2, W1
003932  200030     MOV #0x3, W0
003934  07F8C7     RCALL pwmSetup
49:                	 pwmSetup(PWM_L2, 2, PWM_PERIOD);		// active la pwmL2, couplée au timer2, avec une période de 50us
003936  2CCCD2     MOV #0xCCCD, W2
003938  23D4C3     MOV #0x3D4C, W3
00393A  200021     MOV #0x2, W1
00393C  200040     MOV #0x4, W0
00393E  07F8C2     RCALL pwmSetup
50:                }
003940  FA8000     ULNK
003942  060000     RETURN
51:                
52:                
53:                void motorsEnable(void) {
003944  FA0000     LNK #0x0
54:                	pwmSetDutyCycle(PWM_R1, 0);
003946  B81160     MUL.UU W2, #0, W2
003948  200010     MOV #0x1, W0
00394A  07F904     RCALL pwmSetDutyCycle
55:                	pwmSetDutyCycle(PWM_R2, 0);
00394C  B81160     MUL.UU W2, #0, W2
00394E  200020     MOV #0x2, W0
003950  07F901     RCALL pwmSetDutyCycle
56:                	pwmSetDutyCycle(PWM_L1, 0);
003952  B81160     MUL.UU W2, #0, W2
003954  200030     MOV #0x3, W0
003956  07F8FE     RCALL pwmSetDutyCycle
57:                	pwmSetDutyCycle(PWM_L2, 0);
003958  B81160     MUL.UU W2, #0, W2
00395A  200040     MOV #0x4, W0
00395C  07F8FB     RCALL pwmSetDutyCycle
58:                	EN_R1 = 1;
00395E  A802C5     BSET 0x2C5, #0
59:                	EN_R2 = 1;
003960  A822D4     BSET LATC, #1
60:                	EN_L1 = 1;
003962  A8E2CD     BSET 0x2CD, #7
61:                	EN_L2 = 1;
003964  A8E2C4     BSET LATA, #7
62:                }
003966  FA8000     ULNK
003968  060000     RETURN
63:                
64:                
65:                void motorsDisable(void) {
00396A  FA0000     LNK #0x0
66:                	EN_R1 = 0;
00396C  A902C5     BCLR 0x2C5, #0
67:                	EN_R2 = 0;
00396E  A922D4     BCLR LATC, #1
68:                	EN_L1 = 0;
003970  A9E2CD     BCLR 0x2CD, #7
69:                	EN_L2 = 0;
003972  A9E2C4     BCLR LATA, #7
70:                	pwmSetDutyCycle(PWM_R1, 0);
003974  B81160     MUL.UU W2, #0, W2
003976  200010     MOV #0x1, W0
003978  07F8ED     RCALL pwmSetDutyCycle
71:                	pwmSetDutyCycle(PWM_R2, 0);
00397A  B81160     MUL.UU W2, #0, W2
00397C  200020     MOV #0x2, W0
00397E  07F8EA     RCALL pwmSetDutyCycle
72:                	pwmSetDutyCycle(PWM_L1, 0);
003980  B81160     MUL.UU W2, #0, W2
003982  200030     MOV #0x3, W0
003984  07F8E7     RCALL pwmSetDutyCycle
73:                	pwmSetDutyCycle(PWM_L2, 0);
003986  B81160     MUL.UU W2, #0, W2
003988  200040     MOV #0x4, W0
00398A  07F8E4     RCALL pwmSetDutyCycle
74:                }
00398C  FA8000     ULNK
00398E  060000     RETURN
75:                
76:                
77:                void motorsSetSpeed(float dcR, float dcL) {
003990  FA0008     LNK #0x8
003992  781F88     MOV W8, [W15++]
003994  BE8F00     MOV.D W0, [W14]
003996  980722     MOV W2, [W14+4]
003998  980733     MOV W3, [W14+6]
78:                	if (dcR > 0) {
00399A  B3C018     MOV #0x1, W8
00399C  B81160     MUL.UU W2, #0, W2
00399E  BE001E     MOV.D [W14], W0
0039A0  07E4DF     RCALL ___gtsf2
0039A2  780200     MOV W0, W4
0039A4  520FE0     SUB W4, #0x0, [W15]
0039A6  3C0001     BRA GT, 0x39AA
0039A8  EB4400     CLR.B W8
0039AA  544FE0     SUB.B W8, #0x0, [W15]
0039AC  320007     BRA Z, 0x39BC
79:                		pwmSetDutyCycle(PWM_R1, dcR);
0039AE  BE011E     MOV.D [W14], W2
0039B0  200010     MOV #0x1, W0
0039B2  07F8D0     RCALL pwmSetDutyCycle
80:                		pwmSetDutyCycle(PWM_R2, 0);
0039B4  B81160     MUL.UU W2, #0, W2
0039B6  200020     MOV #0x2, W0
0039B8  07F8CD     RCALL pwmSetDutyCycle
0039BA  370006     BRA 0x39C8
81:                	} else {
82:                		pwmSetDutyCycle(PWM_R1, 0);
0039BC  B81160     MUL.UU W2, #0, W2
0039BE  200010     MOV #0x1, W0
0039C0  07F8C9     RCALL pwmSetDutyCycle
83:                		pwmSetDutyCycle(PWM_R2, dcR);
0039C2  BE011E     MOV.D [W14], W2
0039C4  200020     MOV #0x2, W0
0039C6  07F8C6     RCALL pwmSetDutyCycle
84:                	}
85:                	if (dcL > 0) {
0039C8  B3C018     MOV #0x1, W8
0039CA  B81160     MUL.UU W2, #0, W2
0039CC  90002E     MOV [W14+4], W0
0039CE  9000BE     MOV [W14+6], W1
0039D0  07E4C7     RCALL ___gtsf2
0039D2  780200     MOV W0, W4
0039D4  520FE0     SUB W4, #0x0, [W15]
0039D6  3C0001     BRA GT, 0x39DA
0039D8  EB4400     CLR.B W8
0039DA  544FE0     SUB.B W8, #0x0, [W15]
0039DC  320008     BRA Z, 0x39EE
86:                		pwmSetDutyCycle(PWM_L1, dcL);
0039DE  90012E     MOV [W14+4], W2
0039E0  9001BE     MOV [W14+6], W3
0039E2  200030     MOV #0x3, W0
0039E4  07F8B7     RCALL pwmSetDutyCycle
87:                		pwmSetDutyCycle(PWM_L2, 0);
0039E6  B81160     MUL.UU W2, #0, W2
0039E8  200040     MOV #0x4, W0
0039EA  07F8B4     RCALL pwmSetDutyCycle
0039EC  370007     BRA 0x39FC
88:                	} else {
89:                		pwmSetDutyCycle(PWM_L1, 0);
0039EE  B81160     MUL.UU W2, #0, W2
0039F0  200030     MOV #0x3, W0
0039F2  07F8B0     RCALL pwmSetDutyCycle
90:                		pwmSetDutyCycle(PWM_L2, dcL);
0039F4  90012E     MOV [W14+4], W2
0039F6  9001BE     MOV [W14+6], W3
0039F8  200040     MOV #0x4, W0
0039FA  07F8AC     RCALL pwmSetDutyCycle
91:                	}
92:                }
0039FC  78044F     MOV [--W15], W8
0039FE  FA8000     ULNK
003A00  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/Configware.c  ----------------------------------------
1:                 #include "configware.h"
2:                 #include "../Peripherals/pps.h"
3:                 #include <xc.h>
4:                 
5:                 
6:                 // disables the JTAG to prevent conflicts with TRISA
7:                 _FICD(JTAGEN_OFF);
8:                 // disables the watchdog
9:                 _FWDT(FWDTEN_OFF);
10:                // disable the write protection on memory segments
11:                _FGS(GSS_OFF & GCP_OFF & GWRP_OFF);
12:                // The dsPIC will be clocked by the primary oscillator with a 10MHz crystal.
13:                // We want to use the PLL to obtain Fosc = 80MHz ( <=> 40MIPS ).
14:                // Problem : with a 10MHz crystal, PLL constraints are not met with the
15:                // default parameter.
16:                // Solution :
17:                //	- boot using the internal FRC oscillator as clock source,
18:                //	- set the right PLL parameters to obtain Fosc = 80MHz, without violating
19:                //	  the PLL constraints,
20:                //	- switch the clock source to the PLL
21:                //	- wait for the end of the clock switch
22:                //
23:                // Select internal FRC oscillator as clock source
24:                _FOSCSEL(FNOSC_FRC);
25:                // enables clock switching and configure the primary oscillator for a 10MHz crystal
26:                _FOSC(FCKSM_CSECMD & OSCIOFNC_OFF & POSCMD_XT);
27:                
28:                
29:                //! This function configures the PLL to run at 40MIPS
30:                //!
31:                //! Configures PLL prescaler, PLL postscaler, PLL divisor
32:                //! to obtain Fosc = 80MHz with the 10MHz xt oscillator.
33:                //!
34:                //! Fosc = Fin*M/(N1*N2), where :
35:                //!    - N1 = PLLPRE + 2
36:                //!    - N2 = 2 x (PLLPOST + 1)
37:                //!    - M = PLLDIV + 2
38:                //! Fosc = 80MHz = 10MHz*32/(2*2)
39:                void pllConfig(void) {
003B0E  FA0000     LNK #0x0
40:                #ifndef DEBUG
41:                	PLLFBD = 30; // M = 32
003B10  2001E4     MOV #0x1E, W4
003B12  883A34     MOV W4, PLLFBD
42:                	CLKDIVbits.PLLPOST = 0; // N1 = 2
003B14  803A24     MOV CLKDIV, W4
003B16  A16004     BCLR W4, #6
003B18  A17004     BCLR W4, #7
003B1A  883A24     MOV W4, CLKDIV
43:                	CLKDIVbits.PLLPRE = 0; // N2 = 2
003B1C  803A25     MOV CLKDIV, W5
003B1E  2FFE04     MOV #0xFFE0, W4
003B20  628204     AND W5, W4, W4
003B22  883A24     MOV W4, CLKDIV
44:                	// Initiate Clock Switch to Primary Oscillator with PLL
45:                	__builtin_write_OSCCONH(3);
003B24  200036     MOV #0x3, W6
003B26  200784     MOV #0x78, W4
003B28  2009A5     MOV #0x9A, W5
003B2A  207437     MOV #0x743, W7
003B2C  784B84     MOV.B W4, [W7]
003B2E  784B85     MOV.B W5, [W7]
003B30  784B86     MOV.B W6, [W7]
46:                	__builtin_write_OSCCONL(1);
003B32  200016     MOV #0x1, W6
003B34  200464     MOV #0x46, W4
003B36  200575     MOV #0x57, W5
003B38  207427     MOV #0x742, W7
003B3A  784B84     MOV.B W4, [W7]
003B3C  784B85     MOV.B W5, [W7]
003B3E  784B86     MOV.B W6, [W7]
47:                	// Wait for Clock switch to occur
48:                	while (OSCCONbits.COSC != 0b011);
003B40  000000     NOP
003B42  803A15     MOV OSCCON, W5
003B44  270004     MOV #0x7000, W4
003B46  628284     AND W5, W4, W5
003B48  230004     MOV #0x3000, W4
003B4A  528F84     SUB W5, W4, [W15]
003B4C  3AFFFA     BRA NZ, 0x3B42
49:                #endif
50:                }
003B4E  FA8000     ULNK
003B50  060000     RETURN
51:                
52:                
53:                // assignation des I/Os du CAN
54:                void canPinAssign(void) {
003B52  FA0000     LNK #0x0
55:                	ppsInConfig(PPS_IN_C1RX, 10);
003B54  2000A1     MOV #0xA, W1
003B56  2000B0     MOV #0xB, W0
003B58  07F6DE     RCALL ppsInConfig
56:                //	RPINR26bits.C1RXR = 10;  // RP10 -> CANRX
57:                	ppsOutConfig(PPS_C1TX, 11);	// CANTX -> RP11
003B5A  2000B1     MOV #0xB, W1
003B5C  200100     MOV #0x10, W0
003B5E  07F57D     RCALL ppsOutConfig
58:                //	RPOR5bits.RP11R = 16;
59:                }
003B60  FA8000     ULNK
003B62  060000     RETURN
---  D:/Robotique/codes/mainRobot/PropBoard2014-DC/CanCommand.c  ----------------------------------------
1:                 #include "../Canlib/CanDspic.h"
2:                 #include "../CanLib/CanProp.h"
3:                 #include "globals.h"
4:                 #include "motors.h"
5:                 #include "odoLibre.h"
6:                 #include "trajectoire.h"
7:                 
8:                 
9:                 // type défini pour pouvoir manipuler efficacement les octets d'un int
10:                union INTEG {
11:                	int i;
12:                	unsigned int ui;
13:                	char b[2];
14:                	unsigned char ub[2];
15:                };
16:                union INTEG tempINTEG;
17:                
18:                
19:                position canDataGetPos(void);
20:                
21:                
22:                propStateType  canCommand(propStateType state) {
002E14  FA0024     LNK #0x24
002E16  981710     MOV W0, [W14+34]
23:                	propStateType newState;
24:                	float  acc, vel, length;		//! Variables de travail pour les ordres de mouvement
25:                	float dcR, dcL;					//! Variables de travail pour les ordres de l'état TEST
26:                
27:                	if (canReceivedOrderFlag == 1) {
002E18  2089A4     MOV #0x89A, W4
002E1A  784214     MOV.B [W4], W4
002E1C  524FE1     SUB.B W4, #0x1, [W15]
002E1E  3A00F6     BRA NZ, 0x300C
28:                		switch (canReceivedCommand) {
002E20  208924     MOV #0x892, W4
002E22  784214     MOV.B [W4], W4
002E24  FB8204     ZE W4, W4
002E26  DEA2CF     ASR W4, #15, W5
002E28  200126     MOV #0x12, W6
002E2A  200007     MOV #0x0, W7
002E2C  520F86     SUB W4, W6, [W15]
002E2E  5A8F87     SUBB W5, W7, [W15]
002E30  3E00DC     BRA GTU, 0x2FEA
002E32  016004     BRA W4
002E34  37002F     BRA 0x2E94
002E36  37006B     BRA 0x2F0E
002E38  3700AB     BRA 0x2F90
002E3A  37000F     BRA 0x2E5A
002E3C  37001A     BRA 0x2E72
002E3E  370013     BRA 0x2E66
002E40  3700AF     BRA 0x2FA0
002E42  3700D5     BRA 0x2FEE
002E44  3700D4     BRA 0x2FEE
002E46  3700D3     BRA 0x2FEE
002E48  3700D2     BRA 0x2FEE
002E4A  3700D1     BRA 0x2FEE
002E4C  3700D0     BRA 0x2FEE
002E4E  3700CF     BRA 0x2FEE
002E50  3700CE     BRA 0x2FEE
002E52  3700CD     BRA 0x2FEE
002E54  3700CC     BRA 0x2FEE
002E56  3700CB     BRA 0x2FEE
002E58  370012     BRA 0x2E7E
29:                			case PROP_ENABLE:
30:                				if (state == DISABLED) {
002E5A  90121E     MOV [W14+34], W4
002E5C  520FE0     SUB W4, #0x0, [W15]
002E5E  3A00C9     BRA NZ, 0x2FF2
31:                					newState = STANDING;
002E60  200014     MOV #0x1, W4
002E62  780F04     MOV W4, [W14]
32:                				}
33:                				break;
002E64  3700D3     BRA 0x300C
002FF2  000000     NOP
002FF4  37000B     BRA 0x300C
34:                			case PROP_TEST:
35:                				if (state == DISABLED) {
002E66  90121E     MOV [W14+34], W4
002E68  520FE0     SUB W4, #0x0, [W15]
002E6A  3A00C5     BRA NZ, 0x2FF6
36:                					newState = TEST_STANDING;
002E6C  200034     MOV #0x3, W4
002E6E  780F04     MOV W4, [W14]
37:                				}
38:                				break;
002E70  3700CD     BRA 0x300C
002FF6  000000     NOP
002FF8  370009     BRA 0x300C
39:                			case PROP_DISABLE:
40:                				if (state != DISABLED) {
002E72  90121E     MOV [W14+34], W4
002E74  520FE0     SUB W4, #0x0, [W15]
002E76  3200C1     BRA Z, 0x2FFA
41:                					newState = DISABLED;
002E78  EB0200     CLR W4
002E7A  780F04     MOV W4, [W14]
42:                				}
43:                				break;
002E7C  3700C7     BRA 0x300C
002FFA  000000     NOP
002FFC  370007     BRA 0x300C
44:                			case PROP_SET_POS:
45:                				odoSetAbsPos(canDataGetPos());
002E7E  470276     ADD W14, #0x16, W4
002E80  780004     MOV W4, W0
002E82  0700CB     RCALL canDataGetPos
002E84  90083E     MOV [W14+22], W0
002E86  9008CE     MOV [W14+24], W1
002E88  90095E     MOV [W14+26], W2
002E8A  9009EE     MOV [W14+28], W3
002E8C  900A7E     MOV [W14+30], W4
002E8E  90128E     MOV [W14+32], W5
002E90  070224     RCALL odoSetAbsPos
46:                				break;
002E92  3700BC     BRA 0x300C
47:                			case PROP_TRANSLATION:
48:                				if ((state == STANDING) || (state == TEST_STANDING)) {
002E94  90121E     MOV [W14+34], W4
002E96  520FE1     SUB W4, #0x1, [W15]
002E98  320003     BRA Z, 0x2EA0
002E9A  90121E     MOV [W14+34], W4
002E9C  520FE3     SUB W4, #0x3, [W15]
002E9E  3A00AF     BRA NZ, 0x2FFE
49:                					tempINTEG.ub[0] = canReceivedData[0];		tempINTEG.ub[1] = canReceivedData[1];
002EA0  208934     MOV #0x893, W4
002EA2  784214     MOV.B [W4], W4
002EA4  784004     MOV.B W4, W0
002EA6  B7E90A     MOV.B WREG, tempINTEG
002EA8  208944     MOV #0x894, W4
002EAA  784214     MOV.B [W4], W4
002EAC  784004     MOV.B W4, W0
002EAE  B7E90B     MOV.B WREG, 0x90B
50:                					acc = tempINTEG.i;
002EB0  804854     MOV tempINTEG, W4
002EB2  DEA2CF     ASR W4, #15, W5
002EB4  BE0004     MOV.D W4, W0
002EB6  07EA92     RCALL ___floatsisf
002EB8  BE0200     MOV.D W0, W4
002EBA  980714     MOV W4, [W14+2]
002EBC  980725     MOV W5, [W14+4]
51:                					tempINTEG.ub[0] = canReceivedData[2];		tempINTEG.ub[1] = canReceivedData[3];
002EBE  208954     MOV #0x895, W4
002EC0  784214     MOV.B [W4], W4
002EC2  784004     MOV.B W4, W0
002EC4  B7E90A     MOV.B WREG, tempINTEG
002EC6  208964     MOV #0x896, W4
002EC8  784214     MOV.B [W4], W4
002ECA  784004     MOV.B W4, W0
002ECC  B7E90B     MOV.B WREG, 0x90B
52:                					vel = tempINTEG.i;
002ECE  804854     MOV tempINTEG, W4
002ED0  DEA2CF     ASR W4, #15, W5
002ED2  BE0004     MOV.D W4, W0
002ED4  07EA83     RCALL ___floatsisf
002ED6  BE0200     MOV.D W0, W4
002ED8  980734     MOV W4, [W14+6]
002EDA  980745     MOV W5, [W14+8]
53:                					tempINTEG.ub[0] = canReceivedData[4];		tempINTEG.ub[1] = canReceivedData[5];
002EDC  208974     MOV #0x897, W4
002EDE  784214     MOV.B [W4], W4
002EE0  784004     MOV.B W4, W0
002EE2  B7E90A     MOV.B WREG, tempINTEG
002EE4  208984     MOV #0x898, W4
002EE6  784214     MOV.B [W4], W4
002EE8  784004     MOV.B W4, W0
002EEA  B7E90B     MOV.B WREG, 0x90B
54:                					length = tempINTEG.i;
002EEC  804854     MOV tempINTEG, W4
002EEE  DEA2CF     ASR W4, #15, W5
002EF0  BE0004     MOV.D W4, W0
002EF2  07EA74     RCALL ___floatsisf
002EF4  BE0200     MOV.D W0, W4
002EF6  980754     MOV W4, [W14+10]
002EF8  980765     MOV W5, [W14+12]
55:                					trajAddTranslation(acc, vel, length);
002EFA  90025E     MOV [W14+10], W4
002EFC  9002EE     MOV [W14+12], W5
002EFE  90013E     MOV [W14+6], W2
002F00  9001CE     MOV [W14+8], W3
002F02  90001E     MOV [W14+2], W0
002F04  9000AE     MOV [W14+4], W1
002F06  070410     RCALL trajAddTranslation
56:                					newState = MOVING;
002F08  200024     MOV #0x2, W4
002F0A  780F04     MOV W4, [W14]
57:                				}
58:                				break;
002F0C  37007F     BRA 0x300C
002FFE  000000     NOP
003000  370005     BRA 0x300C
59:                			case PROP_ROTATION:
60:                				if ((state == STANDING) || (state == TEST_STANDING)) {
002F0E  90121E     MOV [W14+34], W4
002F10  520FE1     SUB W4, #0x1, [W15]
002F12  320003     BRA Z, 0x2F1A
002F14  90121E     MOV [W14+34], W4
002F16  520FE3     SUB W4, #0x3, [W15]
002F18  3A0074     BRA NZ, 0x3002
61:                					tempINTEG.ub[0] = canReceivedData[0];		tempINTEG.ub[1] = canReceivedData[1];
002F1A  208934     MOV #0x893, W4
002F1C  784214     MOV.B [W4], W4
002F1E  784004     MOV.B W4, W0
002F20  B7E90A     MOV.B WREG, tempINTEG
002F22  208944     MOV #0x894, W4
002F24  784214     MOV.B [W4], W4
002F26  784004     MOV.B W4, W0
002F28  B7E90B     MOV.B WREG, 0x90B
62:                					acc = tempINTEG.i;
002F2A  804854     MOV tempINTEG, W4
002F2C  DEA2CF     ASR W4, #15, W5
002F2E  BE0004     MOV.D W4, W0
002F30  07EA55     RCALL ___floatsisf
002F32  BE0200     MOV.D W0, W4
002F34  980714     MOV W4, [W14+2]
002F36  980725     MOV W5, [W14+4]
63:                					tempINTEG.ub[0] = canReceivedData[2];		tempINTEG.ub[1] = canReceivedData[3];
002F38  208954     MOV #0x895, W4
002F3A  784214     MOV.B [W4], W4
002F3C  784004     MOV.B W4, W0
002F3E  B7E90A     MOV.B WREG, tempINTEG
002F40  208964     MOV #0x896, W4
002F42  784214     MOV.B [W4], W4
002F44  784004     MOV.B W4, W0
002F46  B7E90B     MOV.B WREG, 0x90B
64:                					vel = tempINTEG.i;
002F48  804854     MOV tempINTEG, W4
002F4A  DEA2CF     ASR W4, #15, W5
002F4C  BE0004     MOV.D W4, W0
002F4E  07EA46     RCALL ___floatsisf
002F50  BE0200     MOV.D W0, W4
002F52  980734     MOV W4, [W14+6]
002F54  980745     MOV W5, [W14+8]
65:                					tempINTEG.ub[0] = canReceivedData[4];		tempINTEG.ub[1] = canReceivedData[5];
002F56  208974     MOV #0x897, W4
002F58  784214     MOV.B [W4], W4
002F5A  784004     MOV.B W4, W0
002F5C  B7E90A     MOV.B WREG, tempINTEG
002F5E  208984     MOV #0x898, W4
002F60  784214     MOV.B [W4], W4
002F62  784004     MOV.B W4, W0
002F64  B7E90B     MOV.B WREG, 0x90B
66:                					length = tempINTEG.i;
002F66  804854     MOV tempINTEG, W4
002F68  DEA2CF     ASR W4, #15, W5
002F6A  BE0004     MOV.D W4, W0
002F6C  07EA37     RCALL ___floatsisf
002F6E  BE0200     MOV.D W0, W4
002F70  980754     MOV W4, [W14+10]
002F72  980765     MOV W5, [W14+12]
67:                					trajAddRotation(acc, vel, (length/10.0));
002F74  200002     MOV #0x0, W2
002F76  241203     MOV #0x4120, W3
002F78  90005E     MOV [W14+10], W0
002F7A  9000EE     MOV [W14+12], W1
002F7C  07ED2F     RCALL ___divsf3x
002F7E  BE0200     MOV.D W0, W4
002F80  90013E     MOV [W14+6], W2
002F82  9001CE     MOV [W14+8], W3
002F84  90001E     MOV [W14+2], W0
002F86  9000AE     MOV [W14+4], W1
002F88  0703F3     RCALL trajAddRotation
68:                					newState = MOVING;
002F8A  200024     MOV #0x2, W4
002F8C  780F04     MOV W4, [W14]
69:                				}
70:                				break;
002F8E  37003E     BRA 0x300C
003002  000000     NOP
003004  370003     BRA 0x300C
71:                				case PROP_STOP_NOW :
72:                					if ((state == MOVING) || (state == TEST_MOVING)) {
002F90  90121E     MOV [W14+34], W4
002F92  520FE2     SUB W4, #0x2, [W15]
002F94  320003     BRA Z, 0x2F9C
002F96  90121E     MOV [W14+34], W4
002F98  520FE4     SUB W4, #0x4, [W15]
002F9A  3A0035     BRA NZ, 0x3006
73:                						trajStopNow();
002F9C  070410     RCALL trajStopNow
74:                					}
75:                					break;
002F9E  370036     BRA 0x300C
003006  000000     NOP
003008  370001     BRA 0x300C
76:                				case PROP_SET_DUTY_CYCLE:
77:                					if (state == TEST_STANDING) {
002FA0  90121E     MOV [W14+34], W4
002FA2  520FE3     SUB W4, #0x3, [W15]
002FA4  3A0032     BRA NZ, 0x300A
78:                						dcR = ((float)canReceivedData[0]) / 100;
002FA6  208934     MOV #0x893, W4
002FA8  784214     MOV.B [W4], W4
002FAA  FB8204     ZE W4, W4
002FAC  200005     MOV #0x0, W5
002FAE  BE0004     MOV.D W4, W0
002FB0  07EA18     RCALL ___floatunsisf
002FB2  BE0200     MOV.D W0, W4
002FB4  200002     MOV #0x0, W2
002FB6  242C83     MOV #0x42C8, W3
002FB8  BE0004     MOV.D W4, W0
002FBA  07ED10     RCALL ___divsf3x
002FBC  BE0200     MOV.D W0, W4
002FBE  980774     MOV W4, [W14+14]
002FC0  980F05     MOV W5, [W14+16]
79:                						dcL = ((float)canReceivedData[1]) / 100;
002FC2  208944     MOV #0x894, W4
002FC4  784214     MOV.B [W4], W4
002FC6  FB8204     ZE W4, W4
002FC8  200005     MOV #0x0, W5
002FCA  BE0004     MOV.D W4, W0
002FCC  07EA0A     RCALL ___floatunsisf
002FCE  BE0200     MOV.D W0, W4
002FD0  200002     MOV #0x0, W2
002FD2  242C83     MOV #0x42C8, W3
002FD4  BE0004     MOV.D W4, W0
002FD6  07ED02     RCALL ___divsf3x
002FD8  BE0200     MOV.D W0, W4
002FDA  980F14     MOV W4, [W14+18]
002FDC  980F25     MOV W5, [W14+20]
80:                						motorsSetSpeed(dcR, dcL);
002FDE  90091E     MOV [W14+18], W2
002FE0  9009AE     MOV [W14+20], W3
002FE2  90007E     MOV [W14+14], W0
002FE4  90088E     MOV [W14+16], W1
002FE6  0704D4     RCALL motorsSetSpeed
81:                					}
82:                					break;
002FE8  370011     BRA 0x300C
00300A  000000     NOP
83:                			default:
84:                				break;
002FEA  000000     NOP
002FEC  37000F     BRA 0x300C
002FEE  000000     NOP
002FF0  37000D     BRA 0x300C
85:                		}
86:                	}
87:                	canReceivedOrderFlag = 0;
00300C  EB4200     CLR.B W4
00300E  784004     MOV.B W4, W0
003010  B7E89A     MOV.B WREG, canReceivedOrderFlag
88:                	return(newState);
003012  78021E     MOV [W14], W4
89:                }
003014  780004     MOV W4, W0
003016  FA8000     ULNK
003018  060000     RETURN
90:                
91:                
92:                position canDataGetPos(void) {
00301A  FA000C     LNK #0xC
00301C  781F88     MOV W8, [W15++]
00301E  780400     MOV W0, W8
93:                	position pos;
94:                
95:                	tempINTEG.ub[0] = canReceivedData[0];		tempINTEG.ub[1] = canReceivedData[1];
003020  208934     MOV #0x893, W4
003022  784214     MOV.B [W4], W4
003024  784004     MOV.B W4, W0
003026  B7E90A     MOV.B WREG, tempINTEG
003028  208944     MOV #0x894, W4
00302A  784214     MOV.B [W4], W4
00302C  784004     MOV.B W4, W0
00302E  B7E90B     MOV.B WREG, 0x90B
96:                	pos.x = tempINTEG.i;
003030  804854     MOV tempINTEG, W4
003032  DEA2CF     ASR W4, #15, W5
003034  BE0004     MOV.D W4, W0
003036  07E9D2     RCALL ___floatsisf
003038  BE0200     MOV.D W0, W4
00303A  BE8F04     MOV.D W4, [W14]
97:                	tempINTEG.ub[0] = canReceivedData[2];		tempINTEG.ub[1] = canReceivedData[3];
00303C  208954     MOV #0x895, W4
00303E  784214     MOV.B [W4], W4
003040  784004     MOV.B W4, W0
003042  B7E90A     MOV.B WREG, tempINTEG
003044  208964     MOV #0x896, W4
003046  784214     MOV.B [W4], W4
003048  784004     MOV.B W4, W0
00304A  B7E90B     MOV.B WREG, 0x90B
98:                	pos.y = tempINTEG.i;
00304C  804854     MOV tempINTEG, W4
00304E  DEA2CF     ASR W4, #15, W5
003050  BE0004     MOV.D W4, W0
003052  07E9C4     RCALL ___floatsisf
003054  BE0200     MOV.D W0, W4
003056  980724     MOV W4, [W14+4]
003058  980735     MOV W5, [W14+6]
99:                	tempINTEG.ub[0] = canReceivedData[4];		tempINTEG.ub[1] = canReceivedData[5];
00305A  208974     MOV #0x897, W4
00305C  784214     MOV.B [W4], W4
00305E  784004     MOV.B W4, W0
003060  B7E90A     MOV.B WREG, tempINTEG
003062  208984     MOV #0x898, W4
003064  784214     MOV.B [W4], W4
003066  784004     MOV.B W4, W0
003068  B7E90B     MOV.B WREG, 0x90B
100:               	pos.alpha = tempINTEG.i;
00306A  804854     MOV tempINTEG, W4
00306C  DEA2CF     ASR W4, #15, W5
00306E  BE0004     MOV.D W4, W0
003070  07E9B5     RCALL ___floatsisf
003072  BE0200     MOV.D W0, W4
003074  980744     MOV W4, [W14+8]
003076  980755     MOV W5, [W14+10]
101:               	return(pos);
003078  78020E     MOV W14, W4
00307A  780288     MOV W8, W5
00307C  781AB4     MOV [W4++], [W5++]
00307E  7812A4     MOV [W4--], [W5--]
003080  4282E4     ADD W5, #0x4, W5
003082  420264     ADD W4, #0x4, W4
003084  781AB4     MOV [W4++], [W5++]
003086  7812A4     MOV [W4--], [W5--]
003088  4282E4     ADD W5, #0x4, W5
00308A  420264     ADD W4, #0x4, W4
00308C  781AB4     MOV [W4++], [W5++]
00308E  7812A4     MOV [W4--], [W5--]
003090  4282E4     ADD W5, #0x4, W5
003092  420264     ADD W4, #0x4, W4
102:               }
003094  780008     MOV W8, W0
003096  78044F     MOV [--W15], W8
003098  FA8000     ULNK
00309A  060000     RETURN
---  D:/Robotique/codes/mainRobot/Peripherals/timers.c  -------------------------------------------------
1:                 /*!
2:                  * @file timers.c
3:                  * @author Kevin De Cuyper
4:                  * @brief Fonctions pour la gestion des timers et pour la dÃ©finition des ISR
5:                  */
6:                 
7:                 #include <xc.h>
8:                 #include "timers.h"
9:                 #include "clock.h"
10:                
11:                //! Vecteur avec les pointeurs vers les registres de configuration
12:                volatile unsigned int* const TxCON[5] = {&T1CON, &T2CON, &T3CON, &T4CON, &T5CON};
13:                //! Vecteur avec les pointeurs vers les registres de pÃ©riode
14:                volatile unsigned int* const PRx[5] = {&PR1, &PR2, &PR3, &PR4, &PR5};
15:                //! Vecteur avec les pointeurs vers les registres de comptage
16:                volatile unsigned int* const TMRx[5] = {&TMR1, &TMR2, &TMR3, &TMR4, &TMR5};
17:                //! Vecteur avec les pointeurs vers les registres d'activation des interruptions
18:                volatile unsigned int* const ISRENx[5] = {&IEC0, &IEC0, &IEC0, &IEC1, &IEC1};
19:                //! Bit masks pour isoler le bon bit Ã  activer 
20:                unsigned int const ISRMaskx[5] = {0x0008, 0x0080, 0x0100, 0x0800, 0x1000};
21:                
22:                //! Pointeurs de fonction vers les fonctions Ã  appeler lors de l'interruption du timer
23:                void (*TxISR[5])(void) = {0,0,0,0,0};
24:                
25:                
26:                
27:                timerStatus timerSetup(int id, float periodMs){
0021DC  FA000C     LNK #0xC
0021DE  980730     MOV W0, [W14+6]
0021E0  980742     MOV W2, [W14+8]
0021E2  980753     MOV W3, [W14+10]
28:                    
29:                    long PRval;
30:                    int prescale;
31:                    
32:                    //Ã©limination des cas indÃ©sirables
33:                    if( id < 1 || id > 5)
0021E4  90023E     MOV [W14+6], W4
0021E6  520FE0     SUB W4, #0x0, [W15]
0021E8  340003     BRA LE, 0x21F0
0021EA  90023E     MOV [W14+6], W4
0021EC  520FE5     SUB W4, #0x5, [W15]
0021EE  340002     BRA LE, 0x21F4
34:                        return TIMER_ID_ERROR;
0021F0  200014     MOV #0x1, W4
0021F2  370075     BRA 0x22DE
35:                    
36:                    PRval = (float)(FCY/1000)*periodMs-1;
0021F4  240002     MOV #0x4000, W2
0021F6  2471C3     MOV #0x471C, W3
0021F8  90004E     MOV [W14+8], W0
0021FA  9000DE     MOV [W14+10], W1
0021FC  07F2BF     RCALL ___mulsf3
0021FE  BE0200     MOV.D W0, W4
002200  200002     MOV #0x0, W2
002202  23F803     MOV #0x3F80, W3
002204  BE0004     MOV.D W4, W0
002206  07F1CC     RCALL ___subsf3
002208  BE0200     MOV.D W0, W4
00220A  BE0004     MOV.D W4, W0
00220C  07F0AB     RCALL ___fixsfsi
00220E  BE0200     MOV.D W0, W4
002210  BE8F04     MOV.D W4, [W14]
37:                    if(PRval <= 0)
002212  BE021E     MOV.D [W14], W4
002214  520FE0     SUB W4, #0x0, [W15]
002216  5A8FE0     SUBB W5, #0x0, [W15]
002218  3C0002     BRA GT, 0x221E
38:                        return TIMER_PERIOD_ERROR;
00221A  200024     MOV #0x2, W4
00221C  370060     BRA 0x22DE
39:                
40:                    //calcul du prescale Ã©ventuel
41:                    if(PRval  <= 65535)
00221E  2FFFF4     MOV #0xFFFF, W4
002220  200005     MOV #0x0, W5
002222  BE031E     MOV.D [W14], W6
002224  530F84     SUB W6, W4, [W15]
002226  5B8F85     SUBB W7, W5, [W15]
002228  3C0003     BRA GT, 0x2230
42:                        prescale = 0;
00222A  EB0200     CLR W4
00222C  980724     MOV W4, [W14+4]
00222E  37003E     BRA 0x22AC
43:                    else if(PRval <= 65535*8){
002230  2FFF84     MOV #0xFFF8, W4
002232  200075     MOV #0x7, W5
002234  BE031E     MOV.D [W14], W6
002236  530F84     SUB W6, W4, [W15]
002238  5B8F85     SUBB W7, W5, [W15]
00223A  3C000E     BRA GT, 0x2258
44:                        prescale = 0x10;
00223C  200104     MOV #0x10, W4
00223E  980724     MOV W4, [W14+4]
45:                        PRval /=8;
002240  BE021E     MOV.D [W14], W4
002242  520FE0     SUB W4, #0x0, [W15]
002244  5A8FE0     SUBB W5, #0x0, [W15]
002246  3D0002     BRA GE, 0x224C
002248  420267     ADD W4, #0x7, W4
00224A  4A82E0     ADDC W5, #0x0, W5
00224C  DD2B4D     SL W5, #13, W6
00224E  DE2243     LSR W4, #3, W4
002250  730204     IOR W6, W4, W4
002252  DEAAC3     ASR W5, #3, W5
002254  BE8F04     MOV.D W4, [W14]
002256  37002A     BRA 0x22AC
46:                    }    
47:                    else if(PRval <= 65535*64){
002258  2FFC04     MOV #0xFFC0, W4
00225A  2003F5     MOV #0x3F, W5
00225C  BE031E     MOV.D [W14], W6
00225E  530F84     SUB W6, W4, [W15]
002260  5B8F85     SUBB W7, W5, [W15]
002262  3C000E     BRA GT, 0x2280
48:                        prescale = 0x20;
002264  200204     MOV #0x20, W4
002266  980724     MOV W4, [W14+4]
49:                        PRval /= 64;
002268  BE021E     MOV.D [W14], W4
00226A  520FE0     SUB W4, #0x0, [W15]
00226C  5A8FE0     SUBB W5, #0x0, [W15]
00226E  3D0002     BRA GE, 0x2274
002270  B003F4     ADD #0x3F, W4
002272  B08005     ADDC #0x0, W5
002274  DD2B4A     SL W5, #10, W6
002276  DE2246     LSR W4, #6, W4
002278  730204     IOR W6, W4, W4
00227A  DEAAC6     ASR W5, #6, W5
00227C  BE8F04     MOV.D W4, [W14]
00227E  370016     BRA 0x22AC
50:                    }
51:                    else if(PRval <= 65535*256){
002280  2FF004     MOV #0xFF00, W4
002282  200FF5     MOV #0xFF, W5
002284  BE031E     MOV.D [W14], W6
002286  530F84     SUB W6, W4, [W15]
002288  5B8F85     SUBB W7, W5, [W15]
00228A  3C000E     BRA GT, 0x22A8
52:                        prescale = 0x30;
00228C  200304     MOV #0x30, W4
00228E  980724     MOV W4, [W14+4]
53:                        PRval /=256;
002290  BE021E     MOV.D [W14], W4
002292  520FE0     SUB W4, #0x0, [W15]
002294  5A8FE0     SUBB W5, #0x0, [W15]
002296  3D0002     BRA GE, 0x229C
002298  B00FF4     ADD #0xFF, W4
00229A  B08005     ADDC #0x0, W5
00229C  DD2B48     SL W5, #8, W6
00229E  DE2248     LSR W4, #8, W4
0022A0  730204     IOR W6, W4, W4
0022A2  DEAAC8     ASR W5, #8, W5
0022A4  BE8F04     MOV.D W4, [W14]
0022A6  370002     BRA 0x22AC
54:                    }
55:                    else return TIMER_PERIOD_ERROR;
0022A8  200024     MOV #0x2, W4
0022AA  370019     BRA 0x22DE
56:                
57:                    // modification des registres
58:                    *TxCON[id-1] = prescale;
0022AC  90023E     MOV [W14+6], W4
0022AE  E90204     DEC W4, W4
0022B0  420284     ADD W4, W4, W5
0022B2  2944C4     MOV #0x944C, W4
0022B4  428204     ADD W5, W4, W4
0022B6  780214     MOV [W4], W4
0022B8  9002AE     MOV [W14+4], W5
0022BA  780A05     MOV W5, [W4]
59:                    *PRx[id-1] = PRval;
0022BC  90023E     MOV [W14+6], W4
0022BE  E90204     DEC W4, W4
0022C0  420284     ADD W4, W4, W5
0022C2  294564     MOV #0x9456, W4
0022C4  428204     ADD W5, W4, W4
0022C6  780214     MOV [W4], W4
0022C8  78029E     MOV [W14], W5
0022CA  780A05     MOV W5, [W4]
60:                    *TMRx[id-1] = 0; //remise Ã  zÃ©ro du compteur
0022CC  90023E     MOV [W14+6], W4
0022CE  E90204     DEC W4, W4
0022D0  420284     ADD W4, W4, W5
0022D2  294604     MOV #0x9460, W4
0022D4  428204     ADD W5, W4, W4
0022D6  780214     MOV [W4], W4
0022D8  EB0280     CLR W5
0022DA  780A05     MOV W5, [W4]
61:                
62:                    return TIMER_SUCCESS;
0022DC  EB0200     CLR W4
63:                }
0022DE  780004     MOV W4, W0
0022E0  FA8000     ULNK
0022E2  060000     RETURN
64:                
65:                
66:                timerStatus timerSetup32(int id, float periodMs){
0022E4  FA000E     LNK #0xE
0022E6  781F88     MOV W8, [W15++]
0022E8  980740     MOV W0, [W14+8]
0022EA  980752     MOV W2, [W14+10]
0022EC  980763     MOV W3, [W14+12]
67:                
68:                    float PRval;
69:                    int prescale;
70:                    int x;
71:                    //Ã©limination des cas indÃ©sirables
72:                    if( id != TIMER_2_3 && id != TIMER_4_5)
0022EE  90024E     MOV [W14+8], W4
0022F0  520FE6     SUB W4, #0x6, [W15]
0022F2  320005     BRA Z, 0x22FE
0022F4  90024E     MOV [W14+8], W4
0022F6  520FE7     SUB W4, #0x7, [W15]
0022F8  320002     BRA Z, 0x22FE
73:                        return TIMER_ID_ERROR;
0022FA  200014     MOV #0x1, W4
0022FC  37009C     BRA 0x2436
74:                
75:                    PRval = (float)(FCY/1000)*periodMs-1;
0022FE  240002     MOV #0x4000, W2
002300  2471C3     MOV #0x471C, W3
002302  90005E     MOV [W14+10], W0
002304  9000EE     MOV [W14+12], W1
002306  07F23A     RCALL ___mulsf3
002308  BE0200     MOV.D W0, W4
00230A  200002     MOV #0x0, W2
00230C  23F803     MOV #0x3F80, W3
00230E  BE0004     MOV.D W4, W0
002310  07F147     RCALL ___subsf3
002312  BE0200     MOV.D W0, W4
002314  BE8F04     MOV.D W4, [W14]
76:                    if(PRval <= 0)
002316  B3C018     MOV #0x1, W8
002318  B81160     MUL.UU W2, #0, W2
00231A  BE001E     MOV.D [W14], W0
00231C  07F01F     RCALL ___lesf2
00231E  780200     MOV W0, W4
002320  520FE0     SUB W4, #0x0, [W15]
002322  340001     BRA LE, 0x2326
002324  EB4400     CLR.B W8
002326  544FE0     SUB.B W8, #0x0, [W15]
002328  320002     BRA Z, 0x232E
77:                        return TIMER_PERIOD_ERROR;
00232A  200024     MOV #0x2, W4
00232C  370084     BRA 0x2436
78:                
79:                    //calcul du prescale Ã©ventuel
80:                    if(PRval  <= 4294967295.0)
00232E  B3C018     MOV #0x1, W8
002330  200002     MOV #0x0, W2
002332  24F803     MOV #0x4F80, W3
002334  BE001E     MOV.D [W14], W0
002336  07F012     RCALL ___lesf2
002338  780200     MOV W0, W4
00233A  520FE0     SUB W4, #0x0, [W15]
00233C  340001     BRA LE, 0x2340
00233E  EB4400     CLR.B W8
002340  544FE0     SUB.B W8, #0x0, [W15]
002342  320003     BRA Z, 0x234A
81:                        prescale = 0;
002344  EB0200     CLR W4
002346  980724     MOV W4, [W14+4]
002348  37003E     BRA 0x23C6
82:                    else if(PRval <= 4294967295.0*8){
00234A  B3C018     MOV #0x1, W8
00234C  200002     MOV #0x0, W2
00234E  251003     MOV #0x5100, W3
002350  BE001E     MOV.D [W14], W0
002352  07F004     RCALL ___lesf2
002354  780200     MOV W0, W4
002356  520FE0     SUB W4, #0x0, [W15]
002358  340001     BRA LE, 0x235C
00235A  EB4400     CLR.B W8
00235C  544FE0     SUB.B W8, #0x0, [W15]
00235E  320009     BRA Z, 0x2372
83:                        prescale = 0x10;
002360  200104     MOV #0x10, W4
002362  980724     MOV W4, [W14+4]
84:                        PRval /=8;
002364  200002     MOV #0x0, W2
002366  241003     MOV #0x4100, W3
002368  BE001E     MOV.D [W14], W0
00236A  07F338     RCALL ___divsf3x
00236C  BE0200     MOV.D W0, W4
00236E  BE8F04     MOV.D W4, [W14]
002370  37002A     BRA 0x23C6
85:                    }
86:                    else if(PRval <= 4294967295.0*64){
002372  B3C018     MOV #0x1, W8
002374  200002     MOV #0x0, W2
002376  252803     MOV #0x5280, W3
002378  BE001E     MOV.D [W14], W0
00237A  07EFF0     RCALL ___lesf2
00237C  780200     MOV W0, W4
00237E  520FE0     SUB W4, #0x0, [W15]
002380  340001     BRA LE, 0x2384
002382  EB4400     CLR.B W8
002384  544FE0     SUB.B W8, #0x0, [W15]
002386  320009     BRA Z, 0x239A
87:                        prescale = 0x20;
002388  200204     MOV #0x20, W4
00238A  980724     MOV W4, [W14+4]
88:                        PRval /= 64;
00238C  200002     MOV #0x0, W2
00238E  242803     MOV #0x4280, W3
002390  BE001E     MOV.D [W14], W0
002392  07F324     RCALL ___divsf3x
002394  BE0200     MOV.D W0, W4
002396  BE8F04     MOV.D W4, [W14]
002398  370016     BRA 0x23C6
89:                    }
90:                    else if(PRval <= 4294967295.0*256){
00239A  B3C018     MOV #0x1, W8
00239C  200002     MOV #0x0, W2
00239E  253803     MOV #0x5380, W3
0023A0  BE001E     MOV.D [W14], W0
0023A2  07EFDC     RCALL ___lesf2
0023A4  780200     MOV W0, W4
0023A6  520FE0     SUB W4, #0x0, [W15]
0023A8  340001     BRA LE, 0x23AC
0023AA  EB4400     CLR.B W8
0023AC  544FE0     SUB.B W8, #0x0, [W15]
0023AE  320009     BRA Z, 0x23C2
91:                        prescale = 0x30;
0023B0  200304     MOV #0x30, W4
0023B2  980724     MOV W4, [W14+4]
92:                        PRval /=256;
0023B4  200002     MOV #0x0, W2
0023B6  243803     MOV #0x4380, W3
0023B8  BE001E     MOV.D [W14], W0
0023BA  07F310     RCALL ___divsf3x
0023BC  BE0200     MOV.D W0, W4
0023BE  BE8F04     MOV.D W4, [W14]
0023C0  370002     BRA 0x23C6
93:                    }
94:                    else return TIMER_PERIOD_ERROR;
0023C2  200024     MOV #0x2, W4
0023C4  370038     BRA 0x2436
95:                
96:                    // modification des registres
97:                    if(id == TIMER_2_3) x = 2;
0023C6  90024E     MOV [W14+8], W4
0023C8  520FE6     SUB W4, #0x6, [W15]
0023CA  3A0003     BRA NZ, 0x23D2
0023CC  200024     MOV #0x2, W4
0023CE  980734     MOV W4, [W14+6]
0023D0  370002     BRA 0x23D6
98:                    else x = 4;
0023D2  200044     MOV #0x4, W4
0023D4  980734     MOV W4, [W14+6]
99:                    *TxCON[x-1] = prescale+0x8; //modification du prescaler + passage en 32bits
0023D6  90023E     MOV [W14+6], W4
0023D8  E90204     DEC W4, W4
0023DA  420284     ADD W4, W4, W5
0023DC  2944C4     MOV #0x944C, W4
0023DE  428204     ADD W5, W4, W4
0023E0  780214     MOV [W4], W4
0023E2  9002AE     MOV [W14+4], W5
0023E4  4282E8     ADD W5, #0x8, W5
0023E6  780A05     MOV W5, [W4]
100:                   *PRx[x] = ((unsigned long)PRval)>>16;
0023E8  90023E     MOV [W14+6], W4
0023EA  420284     ADD W4, W4, W5
0023EC  294564     MOV #0x9456, W4
0023EE  428204     ADD W5, W4, W4
0023F0  780414     MOV [W4], W8
0023F2  BE001E     MOV.D [W14], W0
0023F4  07EFD8     RCALL ___fixunssfsi
0023F6  BE0200     MOV.D W0, W4
0023F8  DE2A40     LSR W5, #0, W4
0023FA  200005     MOV #0x0, W5
0023FC  780204     MOV W4, W4
0023FE  780C04     MOV W4, [W8]
101:                   *PRx[x-1] = (unsigned long)PRval;
002400  90023E     MOV [W14+6], W4
002402  E90204     DEC W4, W4
002404  420284     ADD W4, W4, W5
002406  294564     MOV #0x9456, W4
002408  428204     ADD W5, W4, W4
00240A  780414     MOV [W4], W8
00240C  BE001E     MOV.D [W14], W0
00240E  07EFCB     RCALL ___fixunssfsi
002410  BE0200     MOV.D W0, W4
002412  780204     MOV W4, W4
002414  780C04     MOV W4, [W8]
102:                   *TMRx[x-1] = 0; //remise Ã  zÃ©ro du compteur
002416  90023E     MOV [W14+6], W4
002418  E90204     DEC W4, W4
00241A  420284     ADD W4, W4, W5
00241C  294604     MOV #0x9460, W4
00241E  428204     ADD W5, W4, W4
002420  780214     MOV [W4], W4
002422  EB0280     CLR W5
002424  780A05     MOV W5, [W4]
103:                   *TMRx[x] = 0; //remise Ã  zÃ©ro du compteur
002426  90023E     MOV [W14+6], W4
002428  420284     ADD W4, W4, W5
00242A  294604     MOV #0x9460, W4
00242C  428204     ADD W5, W4, W4
00242E  780214     MOV [W4], W4
002430  EB0280     CLR W5
002432  780A05     MOV W5, [W4]
104:               
105:                   return TIMER_SUCCESS;
002434  EB0200     CLR W4
106:               }
002436  780004     MOV W4, W0
002438  78044F     MOV [--W15], W8
00243A  FA8000     ULNK
00243C  060000     RETURN
107:               
108:               
109:               timerStatus timerStart(int id)
110:               {
00243E  FA0004     LNK #0x4
002440  980710     MOV W0, [W14+2]
111:                   int x;
112:                   if(id < 1 || (id > 5 && (id != TIMER_2_3) && (id !=TIMER_4_5)))
002442  90021E     MOV [W14+2], W4
002444  520FE0     SUB W4, #0x0, [W15]
002446  340009     BRA LE, 0x245A
002448  90021E     MOV [W14+2], W4
00244A  520FE5     SUB W4, #0x5, [W15]
00244C  340008     BRA LE, 0x245E
00244E  90021E     MOV [W14+2], W4
002450  520FE6     SUB W4, #0x6, [W15]
002452  320005     BRA Z, 0x245E
002454  90021E     MOV [W14+2], W4
002456  520FE7     SUB W4, #0x7, [W15]
002458  320002     BRA Z, 0x245E
113:                       return TIMER_ID_ERROR;
00245A  200014     MOV #0x1, W4
00245C  37001D     BRA 0x2498
114:               
115:                   if(id <= 5){
00245E  90021E     MOV [W14+2], W4
002460  520FE5     SUB W4, #0x5, [W15]
002462  3C0003     BRA GT, 0x246A
116:                       x = id;
002464  90021E     MOV [W14+2], W4
002466  780F04     MOV W4, [W14]
002468  370008     BRA 0x247A
117:                   }
118:                   else{
119:                       if(id == TIMER_2_3) x = 2;
00246A  90021E     MOV [W14+2], W4
00246C  520FE6     SUB W4, #0x6, [W15]
00246E  3A0003     BRA NZ, 0x2476
002470  200024     MOV #0x2, W4
002472  780F04     MOV W4, [W14]
002474  370002     BRA 0x247A
120:                       else x = 4;
002476  200044     MOV #0x4, W4
002478  780F04     MOV W4, [W14]
121:               
122:                       
123:                   }
124:                   *TxCON[x-1] |= 0x8000; //lancement du timer
00247A  E9021E     DEC [W14], W4
00247C  420284     ADD W4, W4, W5
00247E  2944C4     MOV #0x944C, W4
002480  428204     ADD W5, W4, W4
002482  780294     MOV [W4], W5
002484  E9021E     DEC [W14], W4
002486  420304     ADD W4, W4, W6
002488  2944C4     MOV #0x944C, W4
00248A  430204     ADD W6, W4, W4
00248C  780214     MOV [W4], W4
00248E  780314     MOV [W4], W6
002490  280004     MOV #0x8000, W4
002492  730204     IOR W6, W4, W4
002494  780A84     MOV W4, [W5]
125:                   return TIMER_SUCCESS;
002496  EB0200     CLR W4
126:               }
002498  780004     MOV W4, W0
00249A  FA8000     ULNK
00249C  060000     RETURN
127:               
128:               
129:               timerStatus timerStop(int id)
130:               {
00249E  FA0004     LNK #0x4
0024A0  980710     MOV W0, [W14+2]
131:                   int x;
132:                   if(id < 1 || (id > 5 && (id != TIMER_2_3) && (id !=TIMER_4_5)))
0024A2  90021E     MOV [W14+2], W4
0024A4  520FE0     SUB W4, #0x0, [W15]
0024A6  340009     BRA LE, 0x24BA
0024A8  90021E     MOV [W14+2], W4
0024AA  520FE5     SUB W4, #0x5, [W15]
0024AC  340008     BRA LE, 0x24BE
0024AE  90021E     MOV [W14+2], W4
0024B0  520FE6     SUB W4, #0x6, [W15]
0024B2  320005     BRA Z, 0x24BE
0024B4  90021E     MOV [W14+2], W4
0024B6  520FE7     SUB W4, #0x7, [W15]
0024B8  320002     BRA Z, 0x24BE
133:                       return TIMER_ID_ERROR;
0024BA  200014     MOV #0x1, W4
0024BC  37001D     BRA 0x24F8
134:               
135:                   if(id <= 5) x = id;
0024BE  90021E     MOV [W14+2], W4
0024C0  520FE5     SUB W4, #0x5, [W15]
0024C2  3C0003     BRA GT, 0x24CA
0024C4  90021E     MOV [W14+2], W4
0024C6  780F04     MOV W4, [W14]
0024C8  370008     BRA 0x24DA
136:                   else{
137:                       if(id == TIMER_2_3) x = 2;
0024CA  90021E     MOV [W14+2], W4
0024CC  520FE6     SUB W4, #0x6, [W15]
0024CE  3A0003     BRA NZ, 0x24D6
0024D0  200024     MOV #0x2, W4
0024D2  780F04     MOV W4, [W14]
0024D4  370002     BRA 0x24DA
138:                       else x = 4;
0024D6  200044     MOV #0x4, W4
0024D8  780F04     MOV W4, [W14]
139:                   }
140:                   *TxCON[x-1] &= 0x7FFF; //arret du timer
0024DA  E9021E     DEC [W14], W4
0024DC  420284     ADD W4, W4, W5
0024DE  2944C4     MOV #0x944C, W4
0024E0  428204     ADD W5, W4, W4
0024E2  780294     MOV [W4], W5
0024E4  E9021E     DEC [W14], W4
0024E6  420304     ADD W4, W4, W6
0024E8  2944C4     MOV #0x944C, W4
0024EA  430204     ADD W6, W4, W4
0024EC  780214     MOV [W4], W4
0024EE  780314     MOV [W4], W6
0024F0  27FFF4     MOV #0x7FFF, W4
0024F2  630204     AND W6, W4, W4
0024F4  780A84     MOV W4, [W5]
141:                   return TIMER_SUCCESS;
0024F6  EB0200     CLR W4
142:               }
0024F8  780004     MOV W4, W0
0024FA  FA8000     ULNK
0024FC  060000     RETURN
143:               
144:               
145:               timerStatus timerInterrupt(int id, void (*fonction)(void)){
0024FE  FA0006     LNK #0x6
002500  980710     MOV W0, [W14+2]
002502  980721     MOV W1, [W14+4]
146:                   int x;
147:               
148:                   if(id < 1 || (id > 5 && (id != TIMER_2_3) && (id !=TIMER_4_5)))
002504  90021E     MOV [W14+2], W4
002506  520FE0     SUB W4, #0x0, [W15]
002508  340009     BRA LE, 0x251C
00250A  90021E     MOV [W14+2], W4
00250C  520FE5     SUB W4, #0x5, [W15]
00250E  340008     BRA LE, 0x2520
002510  90021E     MOV [W14+2], W4
002512  520FE6     SUB W4, #0x6, [W15]
002514  320005     BRA Z, 0x2520
002516  90021E     MOV [W14+2], W4
002518  520FE7     SUB W4, #0x7, [W15]
00251A  320002     BRA Z, 0x2520
149:                       return TIMER_ID_ERROR;
00251C  200014     MOV #0x1, W4
00251E  370027     BRA 0x256E
150:                   if(id <= 5) x = id;
002520  90021E     MOV [W14+2], W4
002522  520FE5     SUB W4, #0x5, [W15]
002524  3C0003     BRA GT, 0x252C
002526  90021E     MOV [W14+2], W4
002528  780F04     MOV W4, [W14]
00252A  370008     BRA 0x253C
151:                   else{
152:                       if(id == TIMER_2_3) x = 3;
00252C  90021E     MOV [W14+2], W4
00252E  520FE6     SUB W4, #0x6, [W15]
002530  3A0003     BRA NZ, 0x2538
002532  200034     MOV #0x3, W4
002534  780F04     MOV W4, [W14]
002536  370002     BRA 0x253C
153:                       else x = 5;
002538  200054     MOV #0x5, W4
00253A  780F04     MOV W4, [W14]
154:                   }
155:                   *ISRENx[x-1] |= ISRMaskx[x-1];
00253C  E9021E     DEC [W14], W4
00253E  420284     ADD W4, W4, W5
002540  2946A4     MOV #0x946A, W4
002542  428204     ADD W5, W4, W4
002544  780294     MOV [W4], W5
002546  E9021E     DEC [W14], W4
002548  420304     ADD W4, W4, W6
00254A  2946A4     MOV #0x946A, W4
00254C  430204     ADD W6, W4, W4
00254E  780214     MOV [W4], W4
002550  780314     MOV [W4], W6
002552  E9021E     DEC [W14], W4
002554  420384     ADD W4, W4, W7
002556  294744     MOV #0x9474, W4
002558  438204     ADD W7, W4, W4
00255A  780214     MOV [W4], W4
00255C  730204     IOR W6, W4, W4
00255E  780A84     MOV W4, [W5]
156:                   TxISR[x-1] = fonction;
002560  E9021E     DEC [W14], W4
002562  420284     ADD W4, W4, W5
002564  208EE4     MOV #0x8EE, W4
002566  428204     ADD W5, W4, W4
002568  9002AE     MOV [W14+4], W5
00256A  780A05     MOV W5, [W4]
157:                   
158:                   return TIMER_SUCCESS;
00256C  EB0200     CLR W4
159:               }
00256E  780004     MOV W4, W0
002570  FA8000     ULNK
002572  060000     RETURN
160:               
161:               
162:               void __attribute__((interrupt, auto_psv)) _T1Interrupt(void){
002574  F80036     PUSH RCOUNT
002576  BE9F80     MOV.D W0, [W15++]
002578  BE9F82     MOV.D W2, [W15++]
00257A  BE9F84     MOV.D W4, [W15++]
00257C  BE9F86     MOV.D W6, [W15++]
00257E  F80034     PUSH PSVPAG
002580  200000     MOV #0x0, W0
002582  8801A0     MOV W0, PSVPAG
002584  FA0000     LNK #0x0
163:                   IFS0bits.T1IF = 0;
002586  A96084     BCLR IFS0, #3
164:                   if(TxISR[0]) //si une fonction a Ã©tÃ© dÃ©finie
002588  804774     MOV TxISR, W4
00258A  520FE0     SUB W4, #0x0, [W15]
00258C  320002     BRA Z, 0x2592
165:                       (*TxISR[0])(); //appel Ã  la fonction en question
00258E  804774     MOV TxISR, W4
002590  010004     CALL W4
166:               }
002592  FA8000     ULNK
002594  F90034     POP PSVPAG
002596  BE034F     MOV.D [--W15], W6
002598  BE024F     MOV.D [--W15], W4
00259A  BE014F     MOV.D [--W15], W2
00259C  BE004F     MOV.D [--W15], W0
00259E  F90036     POP RCOUNT
0025A0  064000     RETFIE
167:               
168:               void __attribute__((interrupt, auto_psv)) _T2Interrupt(void){
0025A2  F80036     PUSH RCOUNT
0025A4  BE9F80     MOV.D W0, [W15++]
0025A6  BE9F82     MOV.D W2, [W15++]
0025A8  BE9F84     MOV.D W4, [W15++]
0025AA  BE9F86     MOV.D W6, [W15++]
0025AC  F80034     PUSH PSVPAG
0025AE  200000     MOV #0x0, W0
0025B0  8801A0     MOV W0, PSVPAG
0025B2  FA0000     LNK #0x0
169:                   IFS0bits.T2IF = 0;
0025B4  A9E084     BCLR IFS0, #7
170:                   if(TxISR[1]) //si une fonction a Ã©tÃ© dÃ©finie
0025B6  804784     MOV 0x8F0, W4
0025B8  520FE0     SUB W4, #0x0, [W15]
0025BA  320002     BRA Z, 0x25C0
171:                       (*TxISR[1])(); //appel Ã  la fonction en question
0025BC  804784     MOV 0x8F0, W4
0025BE  010004     CALL W4
172:               }
0025C0  FA8000     ULNK
0025C2  F90034     POP PSVPAG
0025C4  BE034F     MOV.D [--W15], W6
0025C6  BE024F     MOV.D [--W15], W4
0025C8  BE014F     MOV.D [--W15], W2
0025CA  BE004F     MOV.D [--W15], W0
0025CC  F90036     POP RCOUNT
0025CE  064000     RETFIE
173:               
174:               void __attribute__((interrupt, auto_psv)) _T3Interrupt(void){
0025D0  F80036     PUSH RCOUNT
0025D2  BE9F80     MOV.D W0, [W15++]
0025D4  BE9F82     MOV.D W2, [W15++]
0025D6  BE9F84     MOV.D W4, [W15++]
0025D8  BE9F86     MOV.D W6, [W15++]
0025DA  F80034     PUSH PSVPAG
0025DC  200000     MOV #0x0, W0
0025DE  8801A0     MOV W0, PSVPAG
0025E0  FA0000     LNK #0x0
175:                   IFS0bits.T3IF = 0;
0025E2  A90085     BCLR 0x85, #0
176:                   if(TxISR[2]) //si une fonction a Ã©tÃ© dÃ©finie
0025E4  804794     MOV 0x8F2, W4
0025E6  520FE0     SUB W4, #0x0, [W15]
0025E8  320002     BRA Z, 0x25EE
177:                       (*TxISR[2])(); //appel Ã  la fonction en question
0025EA  804794     MOV 0x8F2, W4
0025EC  010004     CALL W4
178:               }
0025EE  FA8000     ULNK
0025F0  F90034     POP PSVPAG
0025F2  BE034F     MOV.D [--W15], W6
0025F4  BE024F     MOV.D [--W15], W4
0025F6  BE014F     MOV.D [--W15], W2
0025F8  BE004F     MOV.D [--W15], W0
0025FA  F90036     POP RCOUNT
0025FC  064000     RETFIE
179:               
180:               void __attribute__((interrupt, auto_psv)) _T4Interrupt(void){
0025FE  F80036     PUSH RCOUNT
002600  BE9F80     MOV.D W0, [W15++]
002602  BE9F82     MOV.D W2, [W15++]
002604  BE9F84     MOV.D W4, [W15++]
002606  BE9F86     MOV.D W6, [W15++]
002608  F80034     PUSH PSVPAG
00260A  200000     MOV #0x0, W0
00260C  8801A0     MOV W0, PSVPAG
00260E  FA0000     LNK #0x0
181:                   IFS1bits.T4IF = 0;
002610  A96087     BCLR 0x87, #3
182:                   if(TxISR[3]) //si une fonction a Ã©tÃ© dÃ©finie
002612  8047A4     MOV 0x8F4, W4
002614  520FE0     SUB W4, #0x0, [W15]
002616  320002     BRA Z, 0x261C
183:                       (*TxISR[3])(); //appel Ã  la fonction en question
002618  8047A4     MOV 0x8F4, W4
00261A  010004     CALL W4
184:               }
00261C  FA8000     ULNK
00261E  F90034     POP PSVPAG
002620  BE034F     MOV.D [--W15], W6
002622  BE024F     MOV.D [--W15], W4
002624  BE014F     MOV.D [--W15], W2
002626  BE004F     MOV.D [--W15], W0
002628  F90036     POP RCOUNT
00262A  064000     RETFIE
185:               
186:               void __attribute__((interrupt, auto_psv)) _T5Interrupt(void){
00262C  F80036     PUSH RCOUNT
00262E  BE9F80     MOV.D W0, [W15++]
002630  BE9F82     MOV.D W2, [W15++]
002632  BE9F84     MOV.D W4, [W15++]
002634  BE9F86     MOV.D W6, [W15++]
002636  F80034     PUSH PSVPAG
002638  200000     MOV #0x0, W0
00263A  8801A0     MOV W0, PSVPAG
00263C  FA0000     LNK #0x0
187:                   IFS1bits.T5IF = 0;
00263E  A98087     BCLR 0x87, #4
188:                   if(TxISR[4]) //si une fonction a Ã©tÃ© dÃ©finie
002640  8047B4     MOV 0x8F6, W4
002642  520FE0     SUB W4, #0x0, [W15]
002644  320002     BRA Z, 0x264A
189:                       (*TxISR[4])(); //appel Ã  la fonction en question
002646  8047B4     MOV 0x8F6, W4
002648  010004     CALL W4
190:               }
00264A  FA8000     ULNK
00264C  F90034     POP PSVPAG
00264E  BE034F     MOV.D [--W15], W6
002650  BE024F     MOV.D [--W15], W4
002652  BE014F     MOV.D [--W15], W2
002654  BE004F     MOV.D [--W15], W0
002656  F90036     POP RCOUNT
002658  064000     RETFIE
---  D:/Robotique/codes/mainRobot/Peripherals/pwm.c  ----------------------------------------------------
1:                 /*!
2:                  * @file pwm.c
3:                  * @author Kevin De Cuyper
4:                  * @brief Fonctions pour la gestion des pwm
5:                  */
6:                 #include <xc.h>
7:                 #include "timers.h"
8:                 #include "pwm.h"
9:                 #include "clock.h"
10:                
11:                volatile unsigned int* const OCxCON[4] = {&OC1CON, &OC2CON, &OC3CON, &OC4CON};
12:                volatile unsigned int* const OCxRS[4] = {&OC1RS, &OC2RS, &OC3RS, &OC4RS};
13:                
14:                pwmStatus pwmSetup(int id, int timer, float periodMs) {
002AC4  FA000A     LNK #0xA
002AC6  980710     MOV W0, [W14+2]
002AC8  980721     MOV W1, [W14+4]
002ACA  980732     MOV W2, [W14+6]
002ACC  980743     MOV W3, [W14+8]
15:                    timerStatus err;
16:                
17:                    //on vÃ©rifie si l'ID de la pwm est correcte
18:                    if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002ACE  90021E     MOV [W14+2], W4
002AD0  520FE1     SUB W4, #0x1, [W15]
002AD2  32000B     BRA Z, 0x2AEA
002AD4  90021E     MOV [W14+2], W4
002AD6  520FE2     SUB W4, #0x2, [W15]
002AD8  320008     BRA Z, 0x2AEA
002ADA  90021E     MOV [W14+2], W4
002ADC  520FE3     SUB W4, #0x3, [W15]
002ADE  320005     BRA Z, 0x2AEA
002AE0  90021E     MOV [W14+2], W4
002AE2  520FE4     SUB W4, #0x4, [W15]
002AE4  320002     BRA Z, 0x2AEA
19:                        return PWM_ID_ERROR;
002AE6  200034     MOV #0x3, W4
002AE8  370032     BRA 0x2B4E
20:                    }
21:                
22:                    //on vÃ©rifie si l'ID du timer est correcte
23:                    if (timer != TIMER_2 && timer != TIMER_3) {
002AEA  90022E     MOV [W14+4], W4
002AEC  520FE2     SUB W4, #0x2, [W15]
002AEE  320005     BRA Z, 0x2AFA
002AF0  90022E     MOV [W14+4], W4
002AF2  520FE3     SUB W4, #0x3, [W15]
002AF4  320002     BRA Z, 0x2AFA
24:                        return PWM_TID_ERROR;
002AF6  200014     MOV #0x1, W4
002AF8  37002A     BRA 0x2B4E
25:                    }
26:                
27:                    //crÃ©ation du timer associÃ©
28:                    err = timerSetup(timer, periodMs);
002AFA  90013E     MOV [W14+6], W2
002AFC  9001CE     MOV [W14+8], W3
002AFE  90002E     MOV [W14+4], W0
002B00  07FB6D     RCALL timerSetup
002B02  780200     MOV W0, W4
002B04  780F04     MOV W4, [W14]
29:                
30:                
31:                    //on vÃ©rifie si la pÃ©riode est correcte
32:                    if (err == TIMER_PERIOD_ERROR) {
002B06  78021E     MOV [W14], W4
002B08  520FE2     SUB W4, #0x2, [W15]
002B0A  3A0002     BRA NZ, 0x2B10
33:                        return PWM_PERIOD_ERROR;
002B0C  200024     MOV #0x2, W4
002B0E  37001F     BRA 0x2B4E
34:                    }
35:                
36:                    *OCxRS[id - 1] = 0; // remise Ã  zÃ©ro du rapport cyclique
002B10  90021E     MOV [W14+2], W4
002B12  E90204     DEC W4, W4
002B14  294865     MOV #0x9486, W5
002B16  420204     ADD W4, W4, W4
002B18  428204     ADD W5, W4, W4
002B1A  780214     MOV [W4], W4
002B1C  EB0280     CLR W5
002B1E  780A05     MOV W5, [W4]
37:                
38:                    //activation de la PWM
39:                    if (timer == TIMER_2) {
002B20  90022E     MOV [W14+4], W4
002B22  520FE2     SUB W4, #0x2, [W15]
002B24  3A0009     BRA NZ, 0x2B38
40:                        *OCxCON[id - 1] = 0b0110;
002B26  90021E     MOV [W14+2], W4
002B28  E90204     DEC W4, W4
002B2A  2947E5     MOV #0x947E, W5
002B2C  420204     ADD W4, W4, W4
002B2E  428204     ADD W5, W4, W4
002B30  780214     MOV [W4], W4
002B32  200065     MOV #0x6, W5
002B34  780A05     MOV W5, [W4]
002B36  370008     BRA 0x2B48
41:                    } else {
42:                        *OCxCON[id - 1] = 0b1110;
002B38  90021E     MOV [W14+2], W4
002B3A  E90204     DEC W4, W4
002B3C  2947E5     MOV #0x947E, W5
002B3E  420204     ADD W4, W4, W4
002B40  428204     ADD W5, W4, W4
002B42  780214     MOV [W4], W4
002B44  2000E5     MOV #0xE, W5
002B46  780A05     MOV W5, [W4]
43:                    }
44:                
45:                    //lancement du timer
46:                    timerStart(timer);
002B48  90002E     MOV [W14+4], W0
002B4A  07FC79     RCALL timerStart
47:                    
48:                    return PWM_SUCCESS;
002B4C  EB0200     CLR W4
49:                }
002B4E  780004     MOV W4, W0
002B50  FA8000     ULNK
002B52  060000     RETURN
50:                
51:                pwmStatus pwmSetDutyCycle(int id, float dutyCycle) {
002B54  FA0006     LNK #0x6
002B56  781F88     MOV W8, [W15++]
002B58  780F00     MOV W0, [W14]
002B5A  980712     MOV W2, [W14+2]
002B5C  980723     MOV W3, [W14+4]
52:                    //on vÃ©rifie si l'ID de la pwm est correcte
53:                    if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002B5E  78021E     MOV [W14], W4
002B60  520FE1     SUB W4, #0x1, [W15]
002B62  32000B     BRA Z, 0x2B7A
002B64  78021E     MOV [W14], W4
002B66  520FE2     SUB W4, #0x2, [W15]
002B68  320008     BRA Z, 0x2B7A
002B6A  78021E     MOV [W14], W4
002B6C  520FE3     SUB W4, #0x3, [W15]
002B6E  320005     BRA Z, 0x2B7A
002B70  78021E     MOV [W14], W4
002B72  520FE4     SUB W4, #0x4, [W15]
002B74  320002     BRA Z, 0x2B7A
54:                        return PWM_ID_ERROR;
002B76  200034     MOV #0x3, W4
002B78  370052     BRA 0x2C1E
55:                    }
56:                
57:                    //saturation du rapport cyclique 
58:                    if (dutyCycle > 1.0) {
002B7A  B3C018     MOV #0x1, W8
002B7C  200002     MOV #0x0, W2
002B7E  23F803     MOV #0x3F80, W3
002B80  90001E     MOV [W14+2], W0
002B82  9000AE     MOV [W14+4], W1
002B84  07EBED     RCALL ___gtsf2
002B86  780200     MOV W0, W4
002B88  520FE0     SUB W4, #0x0, [W15]
002B8A  3C0001     BRA GT, 0x2B8E
002B8C  EB4400     CLR.B W8
002B8E  544FE0     SUB.B W8, #0x0, [W15]
002B90  320005     BRA Z, 0x2B9C
59:                        dutyCycle = 1.0;
002B92  200004     MOV #0x0, W4
002B94  23F805     MOV #0x3F80, W5
002B96  980714     MOV W4, [W14+2]
002B98  980725     MOV W5, [W14+4]
002B9A  37000E     BRA 0x2BB8
60:                    } else if (dutyCycle < 0) {
002B9C  B3C018     MOV #0x1, W8
002B9E  B81160     MUL.UU W2, #0, W2
002BA0  90001E     MOV [W14+2], W0
002BA2  9000AE     MOV [W14+4], W1
002BA4  07EBDB     RCALL ___lesf2
002BA6  780200     MOV W0, W4
002BA8  520FE0     SUB W4, #0x0, [W15]
002BAA  350001     BRA LT, 0x2BAE
002BAC  EB4400     CLR.B W8
002BAE  544FE0     SUB.B W8, #0x0, [W15]
002BB0  320003     BRA Z, 0x2BB8
61:                        dutyCycle = 0;
002BB2  B82260     MUL.UU W4, #0, W4
002BB4  980714     MOV W4, [W14+2]
002BB6  980725     MOV W5, [W14+4]
62:                    }
63:                
64:                    //si la PWM est branchÃ©e sur le timer 2
65:                    if (0 == ((*OCxCON[id - 1])& 0b1000)) {
002BB8  E9021E     DEC [W14], W4
002BBA  2947E5     MOV #0x947E, W5
002BBC  420204     ADD W4, W4, W4
002BBE  428204     ADD W5, W4, W4
002BC0  780214     MOV [W4], W4
002BC2  780214     MOV [W4], W4
002BC4  620268     AND W4, #0x8, W4
002BC6  520FE0     SUB W4, #0x0, [W15]
002BC8  3A0015     BRA NZ, 0x2BF4
66:                        *OCxRS[id - 1] = (float) PR2 * dutyCycle;
002BCA  E9021E     DEC [W14], W4
002BCC  294865     MOV #0x9486, W5
002BCE  420204     ADD W4, W4, W4
002BD0  428204     ADD W5, W4, W4
002BD2  780414     MOV [W4], W8
002BD4  800864     MOV PR2, W4
002BD6  200005     MOV #0x0, W5
002BD8  BE0004     MOV.D W4, W0
002BDA  07EC03     RCALL ___floatunsisf
002BDC  BE0200     MOV.D W0, W4
002BDE  90011E     MOV [W14+2], W2
002BE0  9001AE     MOV [W14+4], W3
002BE2  BE0004     MOV.D W4, W0
002BE4  07EDCB     RCALL ___mulsf3
002BE6  BE0200     MOV.D W0, W4
002BE8  BE0004     MOV.D W4, W0
002BEA  07EBDD     RCALL ___fixunssfsi
002BEC  BE0200     MOV.D W0, W4
002BEE  780204     MOV W4, W4
002BF0  780C04     MOV W4, [W8]
002BF2  370014     BRA 0x2C1C
67:                    } else {
68:                        *OCxRS[id - 1] = (float) PR3 * dutyCycle;
002BF4  E9021E     DEC [W14], W4
002BF6  294865     MOV #0x9486, W5
002BF8  420204     ADD W4, W4, W4
002BFA  428204     ADD W5, W4, W4
002BFC  780414     MOV [W4], W8
002BFE  800874     MOV PR3, W4
002C00  200005     MOV #0x0, W5
002C02  BE0004     MOV.D W4, W0
002C04  07EBEE     RCALL ___floatunsisf
002C06  BE0200     MOV.D W0, W4
002C08  90011E     MOV [W14+2], W2
002C0A  9001AE     MOV [W14+4], W3
002C0C  BE0004     MOV.D W4, W0
002C0E  07EDB6     RCALL ___mulsf3
002C10  BE0200     MOV.D W0, W4
002C12  BE0004     MOV.D W4, W0
002C14  07EBC8     RCALL ___fixunssfsi
002C16  BE0200     MOV.D W0, W4
002C18  780204     MOV W4, W4
002C1A  780C04     MOV W4, [W8]
69:                    }
70:                
71:                    return PWM_SUCCESS;
002C1C  EB0200     CLR W4
72:                }
002C1E  780004     MOV W4, W0
002C20  78044F     MOV [--W15], W8
002C22  FA8000     ULNK
002C24  060000     RETURN
73:                
74:                pwmStatus pwmSetDuration(int id, float durationMs) {
002C26  FA0010     LNK #0x10
002C28  980750     MOV W0, [W14+10]
002C2A  980762     MOV W2, [W14+12]
002C2C  980773     MOV W3, [W14+14]
75:                
76:                    int PRx;
77:                    char prescaleShift[4] = {0,3,6,8}; //valeur de dÃ©calage Ã  droite correspondant au prescaler
002C2E  470266     ADD W14, #0x6, W4
002C30  2948E5     MOV #0x948E, W5
002C32  090003     REPEAT #0x3
002C34  785A35     MOV.B [W5++], [W4++]
78:                
79:                    //conversion de la durÃ©e en cycles machine
80:                    long OCx = (float) (FCY / 1000) * durationMs - 1;
002C36  240002     MOV #0x4000, W2
002C38  2471C3     MOV #0x471C, W3
002C3A  90006E     MOV [W14+12], W0
002C3C  9000FE     MOV [W14+14], W1
002C3E  07ED9E     RCALL ___mulsf3
002C40  BE0200     MOV.D W0, W4
002C42  200002     MOV #0x0, W2
002C44  23F803     MOV #0x3F80, W3
002C46  BE0004     MOV.D W4, W0
002C48  07ECAB     RCALL ___subsf3
002C4A  BE0200     MOV.D W0, W4
002C4C  BE0004     MOV.D W4, W0
002C4E  07EB8A     RCALL ___fixsfsi
002C50  BE0200     MOV.D W0, W4
002C52  980714     MOV W4, [W14+2]
002C54  980725     MOV W5, [W14+4]
81:                
82:                    //on vÃ©rifie si l'ID de la pwm est correcte
83:                    if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002C56  90025E     MOV [W14+10], W4
002C58  520FE1     SUB W4, #0x1, [W15]
002C5A  32000B     BRA Z, 0x2C72
002C5C  90025E     MOV [W14+10], W4
002C5E  520FE2     SUB W4, #0x2, [W15]
002C60  320008     BRA Z, 0x2C72
002C62  90025E     MOV [W14+10], W4
002C64  520FE3     SUB W4, #0x3, [W15]
002C66  320005     BRA Z, 0x2C72
002C68  90025E     MOV [W14+10], W4
002C6A  520FE4     SUB W4, #0x4, [W15]
002C6C  320002     BRA Z, 0x2C72
84:                        return PWM_ID_ERROR;
002C6E  200034     MOV #0x3, W4
002C70  37004E     BRA 0x2D0E
85:                    }
86:                
87:                    //si la PWM est branchÃ©e sur le timer 2
88:                    if (0 == ((*OCxCON[id - 1])& 0b1000)) {
002C72  90025E     MOV [W14+10], W4
002C74  E90204     DEC W4, W4
002C76  2947E5     MOV #0x947E, W5
002C78  420204     ADD W4, W4, W4
002C7A  428204     ADD W5, W4, W4
002C7C  780214     MOV [W4], W4
002C7E  780214     MOV [W4], W4
002C80  620268     AND W4, #0x8, W4
002C82  520FE0     SUB W4, #0x0, [W15]
002C84  3A0014     BRA NZ, 0x2CAE
89:                        PRx = PR2;
002C86  800864     MOV PR2, W4
002C88  780F04     MOV W4, [W14]
90:                        OCx >>= prescaleShift[T2CONbits.TCKPS]; //on tient compte du prescaler original
002C8A  800884     MOV T2CON, W4
002C8C  DE2244     LSR W4, #4, W4
002C8E  624263     AND.B W4, #0x3, W4
002C90  FB8204     ZE W4, W4
002C92  470204     ADD W14, W4, W4
002C94  904264     MOV.B [W4+6], W4
002C96  FB0304     SE W4, W6
002C98  90021E     MOV [W14+2], W4
002C9A  9002AE     MOV [W14+4], W5
002C9C  780386     MOV W6, W7
002C9E  E90387     DEC W7, W7
002CA0  330003     BRA N, 0x2CA8
002CA2  D18285     ASR W5, W5
002CA4  D38204     RRC W4, W4
002CA6  37FFFB     BRA 0x2C9E
002CA8  980714     MOV W4, [W14+2]
002CAA  980725     MOV W5, [W14+4]
002CAC  370013     BRA 0x2CD4
91:                    } else {
92:                        PRx = PR3;
002CAE  800874     MOV PR3, W4
002CB0  780F04     MOV W4, [W14]
93:                        OCx >>= prescaleShift[T3CONbits.TCKPS];
002CB2  800894     MOV T3CON, W4
002CB4  DE2244     LSR W4, #4, W4
002CB6  624263     AND.B W4, #0x3, W4
002CB8  FB8204     ZE W4, W4
002CBA  470204     ADD W14, W4, W4
002CBC  904264     MOV.B [W4+6], W4
002CBE  FB0304     SE W4, W6
002CC0  90021E     MOV [W14+2], W4
002CC2  9002AE     MOV [W14+4], W5
002CC4  780386     MOV W6, W7
002CC6  E90387     DEC W7, W7
002CC8  330003     BRA N, 0x2CD0
002CCA  D18285     ASR W5, W5
002CCC  D38204     RRC W4, W4
002CCE  37FFFB     BRA 0x2CC6
002CD0  980714     MOV W4, [W14+2]
002CD2  980725     MOV W5, [W14+4]
94:                    }
95:                
96:                    //saturation du rapport cyclique
97:                    if (OCx > PRx) {
002CD4  78021E     MOV [W14], W4
002CD6  B92361     MUL.SU W4, #1, W6
002CD8  90021E     MOV [W14+2], W4
002CDA  9002AE     MOV [W14+4], W5
002CDC  530F84     SUB W6, W4, [W15]
002CDE  5B8F85     SUBB W7, W5, [W15]
002CE0  3D0005     BRA GE, 0x2CEC
98:                        OCx = PRx;
002CE2  78021E     MOV [W14], W4
002CE4  DEA2CF     ASR W4, #15, W5
002CE6  980714     MOV W4, [W14+2]
002CE8  980725     MOV W5, [W14+4]
002CEA  370008     BRA 0x2CFC
99:                    } else if (OCx < 0) {
002CEC  90021E     MOV [W14+2], W4
002CEE  9002AE     MOV [W14+4], W5
002CF0  520FE0     SUB W4, #0x0, [W15]
002CF2  5A8FE0     SUBB W5, #0x0, [W15]
002CF4  3D0003     BRA GE, 0x2CFC
100:                       OCx = 0;
002CF6  B82260     MUL.UU W4, #0, W4
002CF8  980714     MOV W4, [W14+2]
002CFA  980725     MOV W5, [W14+4]
101:                   }
102:               
103:                   //modification du rapport cyclique
104:                   *OCxRS[id - 1] = OCx;
002CFC  90025E     MOV [W14+10], W4
002CFE  E90204     DEC W4, W4
002D00  294865     MOV #0x9486, W5
002D02  420204     ADD W4, W4, W4
002D04  428204     ADD W5, W4, W4
002D06  780214     MOV [W4], W4
002D08  90029E     MOV [W14+2], W5
002D0A  780A05     MOV W5, [W4]
105:               
106:                   return PWM_SUCCESS;
002D0C  EB0200     CLR W4
107:               }
002D0E  780004     MOV W4, W0
002D10  FA8000     ULNK
002D12  060000     RETURN
108:               
109:               pwmStatus pwmSetCycle(int id, float duration) {
002D14  FA000A     LNK #0xA
002D16  980720     MOV W0, [W14+4]
002D18  980732     MOV W2, [W14+6]
002D1A  980743     MOV W3, [W14+8]
110:               
111:                   int PRx;
112:               
113:                   //conversion de la durÃ©e en cycles machine
114:                   int OCx = duration;
002D1C  90003E     MOV [W14+6], W0
002D1E  9000CE     MOV [W14+8], W1
002D20  07EB21     RCALL ___fixsfsi
002D22  BE0200     MOV.D W0, W4
002D24  980714     MOV W4, [W14+2]
115:               
116:                   //on vÃ©rifie si l'ID de la pwm est correcte
117:                   if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002D26  90022E     MOV [W14+4], W4
002D28  520FE1     SUB W4, #0x1, [W15]
002D2A  32000B     BRA Z, 0x2D42
002D2C  90022E     MOV [W14+4], W4
002D2E  520FE2     SUB W4, #0x2, [W15]
002D30  320008     BRA Z, 0x2D42
002D32  90022E     MOV [W14+4], W4
002D34  520FE3     SUB W4, #0x3, [W15]
002D36  320005     BRA Z, 0x2D42
002D38  90022E     MOV [W14+4], W4
002D3A  520FE4     SUB W4, #0x4, [W15]
002D3C  320002     BRA Z, 0x2D42
118:                       return PWM_ID_ERROR;
002D3E  200034     MOV #0x3, W4
002D40  370023     BRA 0x2D88
119:                   }
120:               
121:                   //si la PWM est branchÃ©e sur le timer 2
122:                   if (0 == ((*OCxCON[id - 1])& 0b1000)) {
002D42  90022E     MOV [W14+4], W4
002D44  E90204     DEC W4, W4
002D46  2947E5     MOV #0x947E, W5
002D48  420204     ADD W4, W4, W4
002D4A  428204     ADD W5, W4, W4
002D4C  780214     MOV [W4], W4
002D4E  780214     MOV [W4], W4
002D50  620268     AND W4, #0x8, W4
002D52  520FE0     SUB W4, #0x0, [W15]
002D54  3A0003     BRA NZ, 0x2D5C
123:                       PRx = PR2;
002D56  800864     MOV PR2, W4
002D58  780F04     MOV W4, [W14]
002D5A  370002     BRA 0x2D60
124:                   } else {
125:                       PRx = PR3;
002D5C  800874     MOV PR3, W4
002D5E  780F04     MOV W4, [W14]
126:                   }
127:               
128:                   //saturation du rapport cyclique
129:                   if (OCx > PRx) {
002D60  90021E     MOV [W14+2], W4
002D62  520F9E     SUB W4, [W14], [W15]
002D64  340003     BRA LE, 0x2D6C
130:                       OCx = PRx;
002D66  78021E     MOV [W14], W4
002D68  980714     MOV W4, [W14+2]
002D6A  370005     BRA 0x2D76
131:                   } else if (OCx < 0) {
002D6C  90021E     MOV [W14+2], W4
002D6E  520FE0     SUB W4, #0x0, [W15]
002D70  3D0002     BRA GE, 0x2D76
132:                       OCx = 0;
002D72  EB0200     CLR W4
002D74  980714     MOV W4, [W14+2]
133:                   }
134:               
135:                   //modification du rapport cyclique
136:                   *OCxRS[id - 1] = OCx;
002D76  90022E     MOV [W14+4], W4
002D78  E90204     DEC W4, W4
002D7A  294865     MOV #0x9486, W5
002D7C  420204     ADD W4, W4, W4
002D7E  428204     ADD W5, W4, W4
002D80  780214     MOV [W4], W4
002D82  90029E     MOV [W14+2], W5
002D84  780A05     MOV W5, [W4]
137:               
138:                   return PWM_SUCCESS;
002D86  EB0200     CLR W4
139:               }
002D88  780004     MOV W4, W0
002D8A  FA8000     ULNK
002D8C  060000     RETURN
140:               
141:               pwmStatus pwmEnable(int id){
002D8E  FA0002     LNK #0x2
002D90  780F00     MOV W0, [W14]
142:                       //on vÃ©rifie si l'ID de la pwm est correcte
143:                   if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002D92  78021E     MOV [W14], W4
002D94  520FE1     SUB W4, #0x1, [W15]
002D96  32000B     BRA Z, 0x2DAE
002D98  78021E     MOV [W14], W4
002D9A  520FE2     SUB W4, #0x2, [W15]
002D9C  320008     BRA Z, 0x2DAE
002D9E  78021E     MOV [W14], W4
002DA0  520FE3     SUB W4, #0x3, [W15]
002DA2  320005     BRA Z, 0x2DAE
002DA4  78021E     MOV [W14], W4
002DA6  520FE4     SUB W4, #0x4, [W15]
002DA8  320002     BRA Z, 0x2DAE
144:                       return PWM_ID_ERROR;
002DAA  200034     MOV #0x3, W4
002DAC  37000E     BRA 0x2DCA
145:                   }
146:               
147:                   *OCxCON[id - 1] |= 0b0110;
002DAE  E9021E     DEC [W14], W4
002DB0  2947E5     MOV #0x947E, W5
002DB2  420204     ADD W4, W4, W4
002DB4  428204     ADD W5, W4, W4
002DB6  780294     MOV [W4], W5
002DB8  E9021E     DEC [W14], W4
002DBA  2947E6     MOV #0x947E, W6
002DBC  420204     ADD W4, W4, W4
002DBE  430204     ADD W6, W4, W4
002DC0  780214     MOV [W4], W4
002DC2  780214     MOV [W4], W4
002DC4  B30064     IOR #0x6, W4
002DC6  780A84     MOV W4, [W5]
148:               
149:                   return PWM_SUCCESS;
002DC8  EB0200     CLR W4
150:               }
002DCA  780004     MOV W4, W0
002DCC  FA8000     ULNK
002DCE  060000     RETURN
151:               
152:               pwmStatus pwmDisable(int id){
002DD0  FA0002     LNK #0x2
002DD2  780F00     MOV W0, [W14]
153:                       //on vÃ©rifie si l'ID de la pwm est correcte
154:                   if (id != PWM_1 && id != PWM_2 && id != PWM_3 && id != PWM_4) {
002DD4  78021E     MOV [W14], W4
002DD6  520FE1     SUB W4, #0x1, [W15]
002DD8  32000B     BRA Z, 0x2DF0
002DDA  78021E     MOV [W14], W4
002DDC  520FE2     SUB W4, #0x2, [W15]
002DDE  320008     BRA Z, 0x2DF0
002DE0  78021E     MOV [W14], W4
002DE2  520FE3     SUB W4, #0x3, [W15]
002DE4  320005     BRA Z, 0x2DF0
002DE6  78021E     MOV [W14], W4
002DE8  520FE4     SUB W4, #0x4, [W15]
002DEA  320002     BRA Z, 0x2DF0
155:                       return PWM_ID_ERROR;
002DEC  200034     MOV #0x3, W4
002DEE  37000F     BRA 0x2E0E
156:                   }
157:               
158:                   *OCxCON[id - 1] &= 0xFFF8;
002DF0  E9021E     DEC [W14], W4
002DF2  2947E5     MOV #0x947E, W5
002DF4  420204     ADD W4, W4, W4
002DF6  428204     ADD W5, W4, W4
002DF8  780294     MOV [W4], W5
002DFA  E9021E     DEC [W14], W4
002DFC  2947E6     MOV #0x947E, W6
002DFE  420204     ADD W4, W4, W4
002E00  430204     ADD W6, W4, W4
002E02  780214     MOV [W4], W4
002E04  780314     MOV [W4], W6
002E06  2FFF84     MOV #0xFFF8, W4
002E08  630204     AND W6, W4, W4
002E0A  780A84     MOV W4, [W5]
159:               
160:                   return PWM_SUCCESS;
002E0C  EB0200     CLR W4
161:               }
002E0E  780004     MOV W4, W0
002E10  FA8000     ULNK
002E12  060000     RETURN
---  D:/Robotique/codes/mainRobot/Peripherals/pps.c  ----------------------------------------------------
1:                 /*!
2:                  * @file pps.c
3:                  * @author Michel OsÃ©e
4:                  * @brief Fonctions de configuration des remappable pins
5:                  */
6:                 
7:                 #include <xc.h>
8:                 #include "pps.h"
9:                 
10:                
11:                ppsStatus ppsOutConfig(ppsOutput periphOutput, int rpPin) {
00265A  FA0004     LNK #0x4
00265C  780F00     MOV W0, [W14]
00265E  980711     MOV W1, [W14+2]
12:                #if defined(__dsPIC33FJ128MC802__) ||defined(__dsPIC33FJ128GP802__)
13:                	if ((periphOutput < 1) || (periphOutput > 10)) {
14:                		return PPS_PERIPH_ERROR;
15:                	}
16:                #elif defined(__dsPIC33FJ128MC804__) ||defined(__dsPIC33FJ128GP804__)
17:                	if ((periphOutput < 1) || (periphOutput > 14)) {
002660  78021E     MOV [W14], W4
002662  520FE0     SUB W4, #0x0, [W15]
002664  320003     BRA Z, 0x266C
002666  78021E     MOV [W14], W4
002668  520FEE     SUB W4, #0xE, [W15]
00266A  360002     BRA LEU, 0x2670
18:                		return PPS_PERIPH_ERROR;
00266C  200014     MOV #0x1, W4
00266E  370150     BRA 0x2910
19:                	}
20:                #endif
21:                	switch (rpPin) {
002670  90021E     MOV [W14+2], W4
002672  DEA2CF     ASR W4, #15, W5
002674  200196     MOV #0x19, W6
002676  200007     MOV #0x0, W7
002678  520F86     SUB W4, W6, [W15]
00267A  5A8F87     SUBB W5, W7, [W15]
00267C  3E0146     BRA GTU, 0x290A
00267E  016004     BRA W4
002680  370019     BRA 0x26B4
002682  370023     BRA 0x26CA
002684  37002E     BRA 0x26E2
002686  370038     BRA 0x26F8
002688  370043     BRA 0x2710
00268A  37004D     BRA 0x2726
00268C  370058     BRA 0x273E
00268E  370062     BRA 0x2754
002690  37006D     BRA 0x276C
002692  370077     BRA 0x2782
002694  370082     BRA 0x279A
002696  37008C     BRA 0x27B0
002698  370097     BRA 0x27C8
00269A  3700A1     BRA 0x27DE
00269C  3700AC     BRA 0x27F6
00269E  3700B6     BRA 0x280C
0026A0  3700C1     BRA 0x2824
0026A2  3700CB     BRA 0x283A
0026A4  3700D6     BRA 0x2852
0026A6  3700E0     BRA 0x2868
0026A8  3700EB     BRA 0x2880
0026AA  3700F5     BRA 0x2896
0026AC  370100     BRA 0x28AE
0026AE  37010A     BRA 0x28C4
0026B0  370115     BRA 0x28DC
0026B2  37011F     BRA 0x28F2
22:                		case 0:		RPOR0bits.RP0R  = periphOutput;	break;
0026B4  78021E     MOV [W14], W4
0026B6  784204     MOV.B W4, W4
0026B8  62427F     AND.B W4, #0x1F, W4
0026BA  FB8204     ZE W4, W4
0026BC  62027F     AND W4, #0x1F, W4
0026BE  803606     MOV RPOR0, W6
0026C0  2FFE05     MOV #0xFFE0, W5
0026C2  630285     AND W6, W5, W5
0026C4  728204     IOR W5, W4, W4
0026C6  883604     MOV W4, RPOR0
0026C8  370122     BRA 0x290E
23:                		case 1:		RPOR0bits.RP1R  = periphOutput;	break;
0026CA  78021E     MOV [W14], W4
0026CC  784204     MOV.B W4, W4
0026CE  62427F     AND.B W4, #0x1F, W4
0026D0  FB8204     ZE W4, W4
0026D2  62027F     AND W4, #0x1F, W4
0026D4  DD2248     SL W4, #8, W4
0026D6  803606     MOV RPOR0, W6
0026D8  2E0FF5     MOV #0xE0FF, W5
0026DA  630285     AND W6, W5, W5
0026DC  728204     IOR W5, W4, W4
0026DE  883604     MOV W4, RPOR0
0026E0  370116     BRA 0x290E
24:                		case 2:		RPOR1bits.RP2R  = periphOutput;	break;
0026E2  78021E     MOV [W14], W4
0026E4  784204     MOV.B W4, W4
0026E6  62427F     AND.B W4, #0x1F, W4
0026E8  FB8204     ZE W4, W4
0026EA  62027F     AND W4, #0x1F, W4
0026EC  803616     MOV RPOR1, W6
0026EE  2FFE05     MOV #0xFFE0, W5
0026F0  630285     AND W6, W5, W5
0026F2  728204     IOR W5, W4, W4
0026F4  883614     MOV W4, RPOR1
0026F6  37010B     BRA 0x290E
25:                		case 3:		RPOR1bits.RP3R  = periphOutput;	break;
0026F8  78021E     MOV [W14], W4
0026FA  784204     MOV.B W4, W4
0026FC  62427F     AND.B W4, #0x1F, W4
0026FE  FB8204     ZE W4, W4
002700  62027F     AND W4, #0x1F, W4
002702  DD2248     SL W4, #8, W4
002704  803616     MOV RPOR1, W6
002706  2E0FF5     MOV #0xE0FF, W5
002708  630285     AND W6, W5, W5
00270A  728204     IOR W5, W4, W4
00270C  883614     MOV W4, RPOR1
00270E  3700FF     BRA 0x290E
26:                		case 4:		RPOR2bits.RP4R  = periphOutput;	break;
002710  78021E     MOV [W14], W4
002712  784204     MOV.B W4, W4
002714  62427F     AND.B W4, #0x1F, W4
002716  FB8204     ZE W4, W4
002718  62027F     AND W4, #0x1F, W4
00271A  803626     MOV RPOR2, W6
00271C  2FFE05     MOV #0xFFE0, W5
00271E  630285     AND W6, W5, W5
002720  728204     IOR W5, W4, W4
002722  883624     MOV W4, RPOR2
002724  3700F4     BRA 0x290E
27:                		case 5:		RPOR2bits.RP5R  = periphOutput;	break;
002726  78021E     MOV [W14], W4
002728  784204     MOV.B W4, W4
00272A  62427F     AND.B W4, #0x1F, W4
00272C  FB8204     ZE W4, W4
00272E  62027F     AND W4, #0x1F, W4
002730  DD2248     SL W4, #8, W4
002732  803626     MOV RPOR2, W6
002734  2E0FF5     MOV #0xE0FF, W5
002736  630285     AND W6, W5, W5
002738  728204     IOR W5, W4, W4
00273A  883624     MOV W4, RPOR2
00273C  3700E8     BRA 0x290E
28:                		case 6:		RPOR3bits.RP6R  = periphOutput;	break;
00273E  78021E     MOV [W14], W4
002740  784204     MOV.B W4, W4
002742  62427F     AND.B W4, #0x1F, W4
002744  FB8204     ZE W4, W4
002746  62027F     AND W4, #0x1F, W4
002748  803636     MOV RPOR3, W6
00274A  2FFE05     MOV #0xFFE0, W5
00274C  630285     AND W6, W5, W5
00274E  728204     IOR W5, W4, W4
002750  883634     MOV W4, RPOR3
002752  3700DD     BRA 0x290E
29:                		case 7:		RPOR3bits.RP7R  = periphOutput;	break;
002754  78021E     MOV [W14], W4
002756  784204     MOV.B W4, W4
002758  62427F     AND.B W4, #0x1F, W4
00275A  FB8204     ZE W4, W4
00275C  62027F     AND W4, #0x1F, W4
00275E  DD2248     SL W4, #8, W4
002760  803636     MOV RPOR3, W6
002762  2E0FF5     MOV #0xE0FF, W5
002764  630285     AND W6, W5, W5
002766  728204     IOR W5, W4, W4
002768  883634     MOV W4, RPOR3
00276A  3700D1     BRA 0x290E
30:                		case 8:		RPOR4bits.RP8R  = periphOutput;	break;
00276C  78021E     MOV [W14], W4
00276E  784204     MOV.B W4, W4
002770  62427F     AND.B W4, #0x1F, W4
002772  FB8204     ZE W4, W4
002774  62027F     AND W4, #0x1F, W4
002776  803646     MOV RPOR4, W6
002778  2FFE05     MOV #0xFFE0, W5
00277A  630285     AND W6, W5, W5
00277C  728204     IOR W5, W4, W4
00277E  883644     MOV W4, RPOR4
002780  3700C6     BRA 0x290E
31:                		case 9:		RPOR4bits.RP9R  = periphOutput;	break;
002782  78021E     MOV [W14], W4
002784  784204     MOV.B W4, W4
002786  62427F     AND.B W4, #0x1F, W4
002788  FB8204     ZE W4, W4
00278A  62027F     AND W4, #0x1F, W4
00278C  DD2248     SL W4, #8, W4
00278E  803646     MOV RPOR4, W6
002790  2E0FF5     MOV #0xE0FF, W5
002792  630285     AND W6, W5, W5
002794  728204     IOR W5, W4, W4
002796  883644     MOV W4, RPOR4
002798  3700BA     BRA 0x290E
32:                		case 10:	RPOR5bits.RP10R = periphOutput;	break;
00279A  78021E     MOV [W14], W4
00279C  784204     MOV.B W4, W4
00279E  62427F     AND.B W4, #0x1F, W4
0027A0  FB8204     ZE W4, W4
0027A2  62027F     AND W4, #0x1F, W4
0027A4  803656     MOV RPOR5, W6
0027A6  2FFE05     MOV #0xFFE0, W5
0027A8  630285     AND W6, W5, W5
0027AA  728204     IOR W5, W4, W4
0027AC  883654     MOV W4, RPOR5
0027AE  3700AF     BRA 0x290E
33:                		case 11:	RPOR5bits.RP11R = periphOutput;	break;
0027B0  78021E     MOV [W14], W4
0027B2  784204     MOV.B W4, W4
0027B4  62427F     AND.B W4, #0x1F, W4
0027B6  FB8204     ZE W4, W4
0027B8  62027F     AND W4, #0x1F, W4
0027BA  DD2248     SL W4, #8, W4
0027BC  803656     MOV RPOR5, W6
0027BE  2E0FF5     MOV #0xE0FF, W5
0027C0  630285     AND W6, W5, W5
0027C2  728204     IOR W5, W4, W4
0027C4  883654     MOV W4, RPOR5
0027C6  3700A3     BRA 0x290E
34:                		case 12:	RPOR6bits.RP12R = periphOutput;	break;
0027C8  78021E     MOV [W14], W4
0027CA  784204     MOV.B W4, W4
0027CC  62427F     AND.B W4, #0x1F, W4
0027CE  FB8204     ZE W4, W4
0027D0  62027F     AND W4, #0x1F, W4
0027D2  803666     MOV RPOR6, W6
0027D4  2FFE05     MOV #0xFFE0, W5
0027D6  630285     AND W6, W5, W5
0027D8  728204     IOR W5, W4, W4
0027DA  883664     MOV W4, RPOR6
0027DC  370098     BRA 0x290E
35:                		case 13:	RPOR6bits.RP13R = periphOutput;	break;
0027DE  78021E     MOV [W14], W4
0027E0  784204     MOV.B W4, W4
0027E2  62427F     AND.B W4, #0x1F, W4
0027E4  FB8204     ZE W4, W4
0027E6  62027F     AND W4, #0x1F, W4
0027E8  DD2248     SL W4, #8, W4
0027EA  803666     MOV RPOR6, W6
0027EC  2E0FF5     MOV #0xE0FF, W5
0027EE  630285     AND W6, W5, W5
0027F0  728204     IOR W5, W4, W4
0027F2  883664     MOV W4, RPOR6
0027F4  37008C     BRA 0x290E
36:                		case 14:	RPOR7bits.RP14R = periphOutput;	break;
0027F6  78021E     MOV [W14], W4
0027F8  784204     MOV.B W4, W4
0027FA  62427F     AND.B W4, #0x1F, W4
0027FC  FB8204     ZE W4, W4
0027FE  62027F     AND W4, #0x1F, W4
002800  803676     MOV RPOR7, W6
002802  2FFE05     MOV #0xFFE0, W5
002804  630285     AND W6, W5, W5
002806  728204     IOR W5, W4, W4
002808  883674     MOV W4, RPOR7
00280A  370081     BRA 0x290E
37:                		case 15:	RPOR7bits.RP15R = periphOutput;	break;
00280C  78021E     MOV [W14], W4
00280E  784204     MOV.B W4, W4
002810  62427F     AND.B W4, #0x1F, W4
002812  FB8204     ZE W4, W4
002814  62027F     AND W4, #0x1F, W4
002816  DD2248     SL W4, #8, W4
002818  803676     MOV RPOR7, W6
00281A  2E0FF5     MOV #0xE0FF, W5
00281C  630285     AND W6, W5, W5
00281E  728204     IOR W5, W4, W4
002820  883674     MOV W4, RPOR7
002822  370075     BRA 0x290E
38:                #if defined(__dsPIC33FJ128GP804__) ||defined(__dsPIC33FJ128MC804__)
39:                		case 16:	RPOR8bits.RP16R  = periphOutput;	break;
002824  78021E     MOV [W14], W4
002826  784204     MOV.B W4, W4
002828  62427F     AND.B W4, #0x1F, W4
00282A  FB8204     ZE W4, W4
00282C  62027F     AND W4, #0x1F, W4
00282E  803686     MOV RPOR8, W6
002830  2FFE05     MOV #0xFFE0, W5
002832  630285     AND W6, W5, W5
002834  728204     IOR W5, W4, W4
002836  883684     MOV W4, RPOR8
002838  37006A     BRA 0x290E
40:                		case 17:	RPOR8bits.RP17R  = periphOutput;	break;
00283A  78021E     MOV [W14], W4
00283C  784204     MOV.B W4, W4
00283E  62427F     AND.B W4, #0x1F, W4
002840  FB8204     ZE W4, W4
002842  62027F     AND W4, #0x1F, W4
002844  DD2248     SL W4, #8, W4
002846  803686     MOV RPOR8, W6
002848  2E0FF5     MOV #0xE0FF, W5
00284A  630285     AND W6, W5, W5
00284C  728204     IOR W5, W4, W4
00284E  883684     MOV W4, RPOR8
002850  37005E     BRA 0x290E
41:                		case 18:	RPOR9bits.RP18R  = periphOutput;	break;
002852  78021E     MOV [W14], W4
002854  784204     MOV.B W4, W4
002856  62427F     AND.B W4, #0x1F, W4
002858  FB8204     ZE W4, W4
00285A  62027F     AND W4, #0x1F, W4
00285C  803696     MOV RPOR9, W6
00285E  2FFE05     MOV #0xFFE0, W5
002860  630285     AND W6, W5, W5
002862  728204     IOR W5, W4, W4
002864  883694     MOV W4, RPOR9
002866  370053     BRA 0x290E
42:                		case 19:	RPOR9bits.RP19R  = periphOutput;	break;
002868  78021E     MOV [W14], W4
00286A  784204     MOV.B W4, W4
00286C  62427F     AND.B W4, #0x1F, W4
00286E  FB8204     ZE W4, W4
002870  62027F     AND W4, #0x1F, W4
002872  DD2248     SL W4, #8, W4
002874  803696     MOV RPOR9, W6
002876  2E0FF5     MOV #0xE0FF, W5
002878  630285     AND W6, W5, W5
00287A  728204     IOR W5, W4, W4
00287C  883694     MOV W4, RPOR9
00287E  370047     BRA 0x290E
43:                		case 20:	RPOR10bits.RP20R = periphOutput;	break;
002880  78021E     MOV [W14], W4
002882  784204     MOV.B W4, W4
002884  62427F     AND.B W4, #0x1F, W4
002886  FB8204     ZE W4, W4
002888  62027F     AND W4, #0x1F, W4
00288A  8036A6     MOV RPOR10, W6
00288C  2FFE05     MOV #0xFFE0, W5
00288E  630285     AND W6, W5, W5
002890  728204     IOR W5, W4, W4
002892  8836A4     MOV W4, RPOR10
002894  37003C     BRA 0x290E
44:                		case 21:	RPOR10bits.RP21R = periphOutput;	break;
002896  78021E     MOV [W14], W4
002898  784204     MOV.B W4, W4
00289A  62427F     AND.B W4, #0x1F, W4
00289C  FB8204     ZE W4, W4
00289E  62027F     AND W4, #0x1F, W4
0028A0  DD2248     SL W4, #8, W4
0028A2  8036A6     MOV RPOR10, W6
0028A4  2E0FF5     MOV #0xE0FF, W5
0028A6  630285     AND W6, W5, W5
0028A8  728204     IOR W5, W4, W4
0028AA  8836A4     MOV W4, RPOR10
0028AC  370030     BRA 0x290E
45:                		case 22:	RPOR11bits.RP22R = periphOutput;	break;
0028AE  78021E     MOV [W14], W4
0028B0  784204     MOV.B W4, W4
0028B2  62427F     AND.B W4, #0x1F, W4
0028B4  FB8204     ZE W4, W4
0028B6  62027F     AND W4, #0x1F, W4
0028B8  8036B6     MOV RPOR11, W6
0028BA  2FFE05     MOV #0xFFE0, W5
0028BC  630285     AND W6, W5, W5
0028BE  728204     IOR W5, W4, W4
0028C0  8836B4     MOV W4, RPOR11
0028C2  370025     BRA 0x290E
46:                		case 23:	RPOR11bits.RP23R = periphOutput;	break;
0028C4  78021E     MOV [W14], W4
0028C6  784204     MOV.B W4, W4
0028C8  62427F     AND.B W4, #0x1F, W4
0028CA  FB8204     ZE W4, W4
0028CC  62027F     AND W4, #0x1F, W4
0028CE  DD2248     SL W4, #8, W4
0028D0  8036B6     MOV RPOR11, W6
0028D2  2E0FF5     MOV #0xE0FF, W5
0028D4  630285     AND W6, W5, W5
0028D6  728204     IOR W5, W4, W4
0028D8  8836B4     MOV W4, RPOR11
0028DA  370019     BRA 0x290E
47:                		case 24:	RPOR12bits.RP24R = periphOutput;	break;
0028DC  78021E     MOV [W14], W4
0028DE  784204     MOV.B W4, W4
0028E0  62427F     AND.B W4, #0x1F, W4
0028E2  FB8204     ZE W4, W4
0028E4  62027F     AND W4, #0x1F, W4
0028E6  8036C6     MOV RPOR12, W6
0028E8  2FFE05     MOV #0xFFE0, W5
0028EA  630285     AND W6, W5, W5
0028EC  728204     IOR W5, W4, W4
0028EE  8836C4     MOV W4, RPOR12
0028F0  37000E     BRA 0x290E
48:                		case 25:	RPOR12bits.RP25R = periphOutput;	break;
0028F2  78021E     MOV [W14], W4
0028F4  784204     MOV.B W4, W4
0028F6  62427F     AND.B W4, #0x1F, W4
0028F8  FB8204     ZE W4, W4
0028FA  62027F     AND W4, #0x1F, W4
0028FC  DD2248     SL W4, #8, W4
0028FE  8036C6     MOV RPOR12, W6
002900  2E0FF5     MOV #0xE0FF, W5
002902  630285     AND W6, W5, W5
002904  728204     IOR W5, W4, W4
002906  8836C4     MOV W4, RPOR12
002908  370002     BRA 0x290E
49:                #endif
50:                		default:
51:                			return PPS_PIN_ERROR;
00290A  200024     MOV #0x2, W4
00290C  370001     BRA 0x2910
52:                			break;
53:                	}
54:                	return PPS_SUCCESS;
00290E  EB0200     CLR W4
55:                }
002910  780004     MOV W4, W0
002912  FA8000     ULNK
002914  060000     RETURN
56:                
57:                
58:                ppsStatus ppsInConfig(ppsInput periphInput, int rpPin) {
002916  FA0004     LNK #0x4
002918  780F00     MOV W0, [W14]
00291A  980711     MOV W1, [W14+2]
59:                #if defined(__dsPIC33FJ128MC802__) ||defined(__dsPIC33FJ128GP802__)
60:                	if ((rpPin < 0) || (rpPin > 15)) {
61:                		return PPS_PIN_ERROR;
62:                	}
63:                #elif defined(__dsPIC33FJ128MC804__) ||defined(__dsPIC33FJ128GP804__)
64:                	if ((rpPin < 0) || (rpPin > 25)) {
00291C  90021E     MOV [W14+2], W4
00291E  520FE0     SUB W4, #0x0, [W15]
002920  350003     BRA LT, 0x2928
002922  90021E     MOV [W14+2], W4
002924  520FF9     SUB W4, #0x19, [W15]
002926  340002     BRA LE, 0x292C
65:                		return PPS_PIN_ERROR;
002928  200024     MOV #0x2, W4
00292A  3700C9     BRA 0x2ABE
66:                	}
67:                #endif
68:                	switch (periphInput) {
00292C  78021E     MOV [W14], W4
00292E  B82361     MUL.UU W4, #1, W6
002930  EB8200     SETM W4
002932  EB8280     SETM W5
002934  420206     ADD W4, W6, W4
002936  4A8287     ADDC W5, W7, W5
002938  2000E6     MOV #0xE, W6
00293A  200007     MOV #0x0, W7
00293C  520F86     SUB W4, W6, [W15]
00293E  5A8F87     SUBB W5, W7, [W15]
002940  3E00BB     BRA GTU, 0x2AB8
002942  016004     BRA W4
002944  37000E     BRA 0x2962
002946  370018     BRA 0x2978
002948  370023     BRA 0x2990
00294A  37002D     BRA 0x29A6
00294C  370038     BRA 0x29BE
00294E  370042     BRA 0x29D4
002950  37004D     BRA 0x29EC
002952  370057     BRA 0x2A02
002954  370061     BRA 0x2A18
002956  37006C     BRA 0x2A30
002958  370076     BRA 0x2A46
00295A  370080     BRA 0x2A5C
00295C  37008A     BRA 0x2A72
00295E  370095     BRA 0x2A8A
002960  37009F     BRA 0x2AA0
69:                		case PPS_U1RX		: RPINR18bits.U1RXR	 = rpPin;	break;	/* Assign UART1 Receive (U1RX) to the corresponding RPn pin*/
002962  90021E     MOV [W14+2], W4
002964  784204     MOV.B W4, W4
002966  62427F     AND.B W4, #0x1F, W4
002968  FB8204     ZE W4, W4
00296A  62027F     AND W4, #0x1F, W4
00296C  803526     MOV RPINR18, W6
00296E  2FFE05     MOV #0xFFE0, W5
002970  630285     AND W6, W5, W5
002972  728204     IOR W5, W4, W4
002974  883524     MOV W4, RPINR18
002976  3700A2     BRA 0x2ABC
70:                		case PPS_U1CTS		: RPINR18bits.U1CTSR = rpPin;	break;	/* Assign UART1 Clear to Send (U1CTS) to the corresponding RPn pin*/
002978  90021E     MOV [W14+2], W4
00297A  784204     MOV.B W4, W4
00297C  62427F     AND.B W4, #0x1F, W4
00297E  FB8204     ZE W4, W4
002980  62027F     AND W4, #0x1F, W4
002982  DD2248     SL W4, #8, W4
002984  803526     MOV RPINR18, W6
002986  2E0FF5     MOV #0xE0FF, W5
002988  630285     AND W6, W5, W5
00298A  728204     IOR W5, W4, W4
00298C  883524     MOV W4, RPINR18
00298E  370096     BRA 0x2ABC
71:                		case PPS_U2RX		: RPINR19bits.U2RXR  = rpPin;	break;	/* Assign UART2 Receive (U2RX) to the corresponding RPn pin*/
002990  90021E     MOV [W14+2], W4
002992  784204     MOV.B W4, W4
002994  62427F     AND.B W4, #0x1F, W4
002996  FB8204     ZE W4, W4
002998  62027F     AND W4, #0x1F, W4
00299A  803536     MOV RPINR19, W6
00299C  2FFE05     MOV #0xFFE0, W5
00299E  630285     AND W6, W5, W5
0029A0  728204     IOR W5, W4, W4
0029A2  883534     MOV W4, RPINR19
0029A4  37008B     BRA 0x2ABC
72:                		case PPS_U2CTS		: RPINR19bits.U2CTSR = rpPin;	break;	/* Assign UART2 Clear to Send (U2CTS) to the corresponding RPn pin*/
0029A6  90021E     MOV [W14+2], W4
0029A8  784204     MOV.B W4, W4
0029AA  62427F     AND.B W4, #0x1F, W4
0029AC  FB8204     ZE W4, W4
0029AE  62027F     AND W4, #0x1F, W4
0029B0  DD2248     SL W4, #8, W4
0029B2  803536     MOV RPINR19, W6
0029B4  2E0FF5     MOV #0xE0FF, W5
0029B6  630285     AND W6, W5, W5
0029B8  728204     IOR W5, W4, W4
0029BA  883534     MOV W4, RPINR19
0029BC  37007F     BRA 0x2ABC
73:                		case PPS_SDI1		: RPINR20bits.SDI1R  = rpPin;	break;	/* Assign SPI1 Data Input (SDI1) to the corresponding RPn pin*/
0029BE  90021E     MOV [W14+2], W4
0029C0  784204     MOV.B W4, W4
0029C2  62427F     AND.B W4, #0x1F, W4
0029C4  FB8204     ZE W4, W4
0029C6  62027F     AND W4, #0x1F, W4
0029C8  803546     MOV RPINR20, W6
0029CA  2FFE05     MOV #0xFFE0, W5
0029CC  630285     AND W6, W5, W5
0029CE  728204     IOR W5, W4, W4
0029D0  883544     MOV W4, RPINR20
0029D2  370074     BRA 0x2ABC
74:                		case PPS_IN_SCK1	: RPINR20bits.SCK1R  = rpPin;	break;	/* Assign SPI1 Clock Input (SCK1IN) to the corresponding RPn pin*/
0029D4  90021E     MOV [W14+2], W4
0029D6  784204     MOV.B W4, W4
0029D8  62427F     AND.B W4, #0x1F, W4
0029DA  FB8204     ZE W4, W4
0029DC  62027F     AND W4, #0x1F, W4
0029DE  DD2248     SL W4, #8, W4
0029E0  803546     MOV RPINR20, W6
0029E2  2E0FF5     MOV #0xE0FF, W5
0029E4  630285     AND W6, W5, W5
0029E6  728204     IOR W5, W4, W4
0029E8  883544     MOV W4, RPINR20
0029EA  370068     BRA 0x2ABC
75:                		case PPS_IN_SS1		: RPINR21bits.SS1R  = rpPin;	break;	/* Assign SPI1 Slave Select Input (SS1IN) to the corresponding RPn pin*/
0029EC  90021E     MOV [W14+2], W4
0029EE  784204     MOV.B W4, W4
0029F0  62427F     AND.B W4, #0x1F, W4
0029F2  FB8204     ZE W4, W4
0029F4  62027F     AND W4, #0x1F, W4
0029F6  803556     MOV RPINR21, W6
0029F8  2FFE05     MOV #0xFFE0, W5
0029FA  630285     AND W6, W5, W5
0029FC  728204     IOR W5, W4, W4
0029FE  883554     MOV W4, RPINR21
002A00  37005D     BRA 0x2ABC
76:                		case PPS_SDI2		: RPINR22bits.SDI2R = rpPin;	break;	/* Assign SPI2 Data Input (SDI2) to the corresponding RPn pin*/
002A02  90021E     MOV [W14+2], W4
002A04  784204     MOV.B W4, W4
002A06  62427F     AND.B W4, #0x1F, W4
002A08  FB8204     ZE W4, W4
002A0A  62027F     AND W4, #0x1F, W4
002A0C  803566     MOV RPINR22, W6
002A0E  2FFE05     MOV #0xFFE0, W5
002A10  630285     AND W6, W5, W5
002A12  728204     IOR W5, W4, W4
002A14  883564     MOV W4, RPINR22
002A16  370052     BRA 0x2ABC
77:                		case PPS_IN_SCK2	: RPINR22bits.SCK2R = rpPin;	break;	/* Assign SPI2 Clock Input (SCK2IN) to the corresponding RPn pin*/
002A18  90021E     MOV [W14+2], W4
002A1A  784204     MOV.B W4, W4
002A1C  62427F     AND.B W4, #0x1F, W4
002A1E  FB8204     ZE W4, W4
002A20  62027F     AND W4, #0x1F, W4
002A22  DD2248     SL W4, #8, W4
002A24  803566     MOV RPINR22, W6
002A26  2E0FF5     MOV #0xE0FF, W5
002A28  630285     AND W6, W5, W5
002A2A  728204     IOR W5, W4, W4
002A2C  883564     MOV W4, RPINR22
002A2E  370046     BRA 0x2ABC
78:                		case PPS_IN_SS2		: RPINR23bits.SS2R  = rpPin;	break;	/* Assign SPI2 Slave Select Input (SS2IN) to the corresponding RPn pin*/
002A30  90021E     MOV [W14+2], W4
002A32  784204     MOV.B W4, W4
002A34  62427F     AND.B W4, #0x1F, W4
002A36  FB8204     ZE W4, W4
002A38  62027F     AND W4, #0x1F, W4
002A3A  803576     MOV RPINR23, W6
002A3C  2FFE05     MOV #0xFFE0, W5
002A3E  630285     AND W6, W5, W5
002A40  728204     IOR W5, W4, W4
002A42  883574     MOV W4, RPINR23
002A44  37003B     BRA 0x2ABC
79:                		case PPS_IN_C1RX	: RPINR26bits.C1RXR = rpPin;	break;
002A46  90021E     MOV [W14+2], W4
002A48  784204     MOV.B W4, W4
002A4A  62427F     AND.B W4, #0x1F, W4
002A4C  FB8204     ZE W4, W4
002A4E  62027F     AND W4, #0x1F, W4
002A50  8035A6     MOV RPINR26, W6
002A52  2FFE05     MOV #0xFFE0, W5
002A54  630285     AND W6, W5, W5
002A56  728204     IOR W5, W4, W4
002A58  8835A4     MOV W4, RPINR26
002A5A  370030     BRA 0x2ABC
80:                #if defined(__dsPIC33FJ128MC802__) ||defined(__dsPIC33FJ128MC804__)
81:                		case PPS_QEA1		: RPINR14bits.QEA1R = rpPin;	break;	/* Assign A (QEA) to the corresponding pin*/
002A5C  90021E     MOV [W14+2], W4
002A5E  784204     MOV.B W4, W4
002A60  62427F     AND.B W4, #0x1F, W4
002A62  FB8204     ZE W4, W4
002A64  62027F     AND W4, #0x1F, W4
002A66  8034E6     MOV RPINR14, W6
002A68  2FFE05     MOV #0xFFE0, W5
002A6A  630285     AND W6, W5, W5
002A6C  728204     IOR W5, W4, W4
002A6E  8834E4     MOV W4, RPINR14
002A70  370025     BRA 0x2ABC
82:                		case PPS_QEB1		: RPINR14bits.QEB1R = rpPin;	break;	/* Assign B (QEB) to the corresponding pin*/
002A72  90021E     MOV [W14+2], W4
002A74  784204     MOV.B W4, W4
002A76  62427F     AND.B W4, #0x1F, W4
002A78  FB8204     ZE W4, W4
002A7A  62027F     AND W4, #0x1F, W4
002A7C  DD2248     SL W4, #8, W4
002A7E  8034E6     MOV RPINR14, W6
002A80  2E0FF5     MOV #0xE0FF, W5
002A82  630285     AND W6, W5, W5
002A84  728204     IOR W5, W4, W4
002A86  8834E4     MOV W4, RPINR14
002A88  370019     BRA 0x2ABC
83:                		case PPS_QEA2		: RPINR16bits.QEA2R = rpPin;	break;	/* Assign A (QEA) to the corresponding pin*/
002A8A  90021E     MOV [W14+2], W4
002A8C  784204     MOV.B W4, W4
002A8E  62427F     AND.B W4, #0x1F, W4
002A90  FB8204     ZE W4, W4
002A92  62027F     AND W4, #0x1F, W4
002A94  803506     MOV RPINR16, W6
002A96  2FFE05     MOV #0xFFE0, W5
002A98  630285     AND W6, W5, W5
002A9A  728204     IOR W5, W4, W4
002A9C  883504     MOV W4, RPINR16
002A9E  37000E     BRA 0x2ABC
84:                		case PPS_QEB2		: RPINR16bits.QEB2R = rpPin;	break;	/* Assign B (QEB) to the corresponding pin*/
002AA0  90021E     MOV [W14+2], W4
002AA2  784204     MOV.B W4, W4
002AA4  62427F     AND.B W4, #0x1F, W4
002AA6  FB8204     ZE W4, W4
002AA8  62027F     AND W4, #0x1F, W4
002AAA  DD2248     SL W4, #8, W4
002AAC  803506     MOV RPINR16, W6
002AAE  2E0FF5     MOV #0xE0FF, W5
002AB0  630285     AND W6, W5, W5
002AB2  728204     IOR W5, W4, W4
002AB4  883504     MOV W4, RPINR16
002AB6  370002     BRA 0x2ABC
85:                #endif
86:                		default:
87:                			return PPS_PERIPH_ERROR;
002AB8  200014     MOV #0x1, W4
002ABA  370001     BRA 0x2ABE
88:                			break;
89:                	}
90:                	return PPS_SUCCESS;
002ABC  EB0200     CLR W4
91:                }
002ABE  780004     MOV W4, W0
002AC0  FA8000     ULNK
002AC2  060000     RETURN
---  D:/Robotique/codes/mainRobot/CanLib/CanInterruptsDspic.c  ------------------------------------------
1:                 #include "CanDspic.h"
2:                 #include "xc.h"
3:                 
4:                 void __attribute__((interrupt, no_auto_psv))_C1Interrupt(void)  
5:                 {    
000298  781F80     MOV W0, [W15++]
00029A  BE9F84     MOV.D W4, [W15++]
00029C  FA0006     LNK #0x6
6:                 	unsigned char iCan;
7:                 	unsigned char *prtObjet;
8:                 	CAN_MSG *receivedMessage;
9:                 
10:                	CAN_INTERRUPT_FLAG = 0;        // clear interrupt flag
00029E  A96088     BCLR IFS2, #3
11:                 
12:                    if(CAN_RX_BUFFER_IF)
0002A0  802054     MOV C1INTF, W4
0002A2  620262     AND W4, #0x2, W4
0002A4  520FE0     SUB W4, #0x0, [W15]
0002A6  320054     BRA Z, 0x350
13:                    {   
14:                		CAN_RX_BUFFER_IF = 0;
0002A8  A9240A     BCLR C1INTF, #1
15:                		
16:                		if(CAN_RX_OBJECT_FLAG)
0002AA  802105     MOV C1RXFUL1, W5
0002AC  201004     MOV #0x100, W4
0002AE  628204     AND W5, W4, W4
0002B0  520FE0     SUB W4, #0x0, [W15]
0002B2  320021     BRA Z, 0x2F6
17:                		{
18:                			// On fait pointer receivedMessage vers le message CAN dans lequel doit être stocké
19:                			// le message en fonction du filtre qui a déclenché
20:                			receivedMessage = &consommation[receiveBufferObjects.FILHIT];
0002B4  820474     MOV 0x408E, W4
0002B6  DE2248     LSR W4, #8, W4
0002B8  62427F     AND.B W4, #0x1F, W4
0002BA  FB8204     ZE W4, W4
0002BC  B92266     MUL.SU W4, #6, W4
0002BE  780284     MOV W4, W5
0002C0  208304     MOV #0x830, W4
0002C2  428204     ADD W5, W4, W4
0002C4  980724     MOV W4, [W14+4]
21:                			
22:                			// Chargement du pointeur destination vers les données du message CAN à remplir
23:                			prtObjet = (unsigned char*)receivedMessage->ptrData;
0002C6  90022E     MOV [W14+4], W4
0002C8  900214     MOV [W4+2], W4
0002CA  980714     MOV W4, [W14+2]
24:                			
25:                			// Copie des données
26:                			for(iCan = 0; iCan < receivedMessage->len; iCan++)
0002CC  EB4200     CLR.B W4
0002CE  784F04     MOV.B W4, [W14]
0002D0  37000C     BRA 0x2EA
0002E8  E84F1E     INC.B [W14], [W14]
0002EA  90022E     MOV [W14+4], W4
0002EC  904244     MOV.B [W4+4], W4
0002EE  524F9E     SUB.B W4, [W14], [W15]
0002F0  3EFFF0     BRA GTU, 0x2D2
27:                				*(prtObjet++) = receiveBufferObjects.DATA[iCan];
0002D2  78401E     MOV.B [W14], W0
0002D4  FB8200     ZE W0, W4
0002D6  4202E6     ADD W4, #0x6, W5
0002D8  240804     MOV #0x4080, W4
0002DA  428204     ADD W5, W4, W4
0002DC  784214     MOV.B [W4], W4
0002DE  90029E     MOV [W14+2], W5
0002E0  784A84     MOV.B W4, [W5]
0002E2  90021E     MOV [W14+2], W4
0002E4  E80204     INC W4, W4
0002E6  980714     MOV W4, [W14+2]
28:                				
29:                			CAN_RX_OBJECT_FLAG = 0;			// Clears the flag so that new messages can be received
0002F2  A90421     BCLR 0x421, #0
0002F4  37002D     BRA 0x350
30:                		}
31:                		else if (CAN_RX_ORDER_FLAG)
0002F6  802105     MOV C1RXFUL1, W5
0002F8  202004     MOV #0x200, W4
0002FA  628204     AND W5, W4, W4
0002FC  520FE0     SUB W4, #0x0, [W15]
0002FE  320028     BRA Z, 0x350
32:                		{
33:                			if(!canReceivedOrderFlag)			// Aucun ordre n'est en cours de traitement : on peut accepter
000300  2089A4     MOV #0x89A, W4
000302  784214     MOV.B [W4], W4
000304  524FE0     SUB.B W4, #0x0, [W15]
000306  3A0023     BRA NZ, 0x34E
34:                			{
35:                				canReceivedCommand = receiveBufferOrders.DATA[0];	// Sauve l'ordre CAN
000308  240964     MOV #0x4096, W4
00030A  784214     MOV.B [W4], W4
00030C  784004     MOV.B W4, W0
00030E  B7E892     MOV.B WREG, canReceivedCommand
36:                				canReceivedData[0] = receiveBufferOrders.DATA[1];	// Sauve les données CAN
000310  240974     MOV #0x4097, W4
000312  784214     MOV.B [W4], W4
000314  784004     MOV.B W4, W0
000316  B7E893     MOV.B WREG, canReceivedData
37:                				canReceivedData[1] = receiveBufferOrders.DATA[2];
000318  240984     MOV #0x4098, W4
00031A  784214     MOV.B [W4], W4
00031C  784004     MOV.B W4, W0
00031E  B7E894     MOV.B WREG, 0x894
38:                				canReceivedData[2] = receiveBufferOrders.DATA[3];
000320  240994     MOV #0x4099, W4
000322  784214     MOV.B [W4], W4
000324  784004     MOV.B W4, W0
000326  B7E895     MOV.B WREG, 0x895
39:                				canReceivedData[3] = receiveBufferOrders.DATA[4];
000328  2409A4     MOV #0x409A, W4
00032A  784214     MOV.B [W4], W4
00032C  784004     MOV.B W4, W0
00032E  B7E896     MOV.B WREG, 0x896
40:                				canReceivedData[4] = receiveBufferOrders.DATA[5];
000330  2409B4     MOV #0x409B, W4
000332  784214     MOV.B [W4], W4
000334  784004     MOV.B W4, W0
000336  B7E897     MOV.B WREG, 0x897
41:                				canReceivedData[5] = receiveBufferOrders.DATA[6];
000338  2409C4     MOV #0x409C, W4
00033A  784214     MOV.B [W4], W4
00033C  784004     MOV.B W4, W0
00033E  B7E898     MOV.B WREG, 0x898
42:                				canReceivedData[6] = receiveBufferOrders.DATA[7];
000340  2409D4     MOV #0x409D, W4
000342  784214     MOV.B [W4], W4
000344  784004     MOV.B W4, W0
000346  B7E899     MOV.B WREG, 0x899
43:                				canReceivedOrderFlag = 1;		// Signifie au main qu'on a reçu un ordre et qu'il faut le traiter
000348  B3C014     MOV #0x1, W4
00034A  784004     MOV.B W4, W0
00034C  B7E89A     MOV.B WREG, canReceivedOrderFlag
44:                			}
45:                			CAN_RX_ORDER_FLAG = 0;				// Clears the flag so that new messages can be received
00034E  A92421     BCLR 0x421, #1
46:                		}
47:                	}
48:                }
000350  FA8000     ULNK
000352  BE024F     MOV.D [--W15], W4
000354  78004F     MOV [--W15], W0
000356  064000     RETFIE
---  D:/Robotique/codes/mainRobot/CanLib/CanDspic.c  ----------------------------------------------------
1:                 #include "CanDspic.h"
2:                 
3:                 /********************************************************
4:                 *						DEFINITIONS						*
5:                 ********************************************************/
6:                 
7:                 //! Macro permettant d'assigner la valeur d'un filtre CAN et de l'activer
8:                 #define _SetRXFnValue(f, val)   		\
9:                 	C1RXF##f##SID = val << 5L;			\
10:                	C1FEN1bits.FLTEN##f = 1		
11:                
12:                //! Macro permettant d'assigner la valeur d'un masque CAN
13:                #define _SetRXMnValue(m, val)           \
14:                	C1RXM##m##SID = val <<5L
15:                
16:                //! Macro permettant de calculer le mode opératoire courant du module CAN
17:                # define CanGetOperationMode() 			C1CTRL1bits.OPMODE	//!< Gets current operation mode of the ECAN module 
18:                
19:                /********************************************************
20:                *						DECLARATIONS					*
21:                ********************************************************/
22:                
23:                //! Vecteur contenant les objets qu'on produit
24:                //#pragma udata can_section=0x800
25:                CAN_MSG production[MAX_OBJETS_PRODUITS];
26:                
27:                //! Vecteur contenant les objets qu'on consomme
28:                CAN_MSG consommation[MAX_OBJETS_CONSOMMES];
29:                
30:                BUFFER_CAN transmitBuffers[8] __attribute__((space(dma),address(DMA_BASE_ADDRESS+0x0000)));
31:                BUFFER_CAN receiveBufferOrders __attribute__((space(dma),address(DMA_BASE_ADDRESS+0x0090)));
32:                BUFFER_CAN receiveBufferObjects __attribute__((space(dma),address(DMA_BASE_ADDRESS+0x0080)));
33:                
34:                //! Nombre d'objets produits
35:                unsigned char nombreObjetsProduits;
36:                
37:                //! Nombre d'objets consommes
38:                unsigned char nombreObjetsConsommes;
39:                
40:                //! ECAN Module baudrates
41:                typedef enum _CAN_BAUDRATE
42:                {
43:                	CAN_BAUDRATE_1M		= 1000000,		/*!< 1Mbps	*/
44:                    CAN_BAUDRATE_500k	= 500000,		/*!< 500kpbs */
45:                	CAN_BAUDRATE_250k	= 250000,		/*!< 250kbps */
46:                	CAN_BAUDRATE_125k	= 125000		/*!< 125kbps */
47:                } CAN_BAUDRATE;
48:                
49:                //! ECAN Module operation modes
50:                typedef enum _CAN_OP_MODE
51:                {
52:                    CAN_OP_MODE_NORMAL  	= 0x00,		/*!< Normal mode 				*/
53:                    CAN_OP_MODE_DISABLE 	= 0x01,		/*!< Disable mode 				*/
54:                    CAN_OP_MODE_LOOP    	= 0x02,		/*!< Loopback mode				*/ 
55:                    CAN_OP_MODE_LISTEN_ONLY = 0x03,		/*!< Listen-only mode			*/
56:                    CAN_OP_MODE_CONFIG  	= 0x04,		/*!< Configuration mode			*/
57:                    CAN_OP_MODE_LISTEN_ALL 	= 0x07		/*!< Listen all messages mode	*/
58:                } CAN_OP_MODE;
59:                
60:                //! Indices de boucles
61:                unsigned char jij;
62:                unsigned char kik;
63:                
64:                void dma0init(void);
65:                void dma1init(void);
66:                
67:                unsigned char *ptrSource, *ptrDest;
68:                
69:                unsigned char canReceivedCommand;   // Stocke l'ordre CAN reçu
70:                unsigned char canReceivedData[7];   // Stocke les data liées à l'ordre CAN reçu
71:                unsigned char canReceivedOrderFlag; // indique à la boucle infinie qu'on a reçu un ordre CAN à traiter
72:                
73:                /********************************************************
74:                *						PROTOTYPES						*
75:                ********************************************************/
76:                
77:                //! Function to change the Can Baudrate
78:                void CanSetBaudRate(CAN_BAUDRATE baudrate);
79:                
80:                //! Changes the operation mode of the ECAN Module
81:                void CanSetOperationMode(CAN_OP_MODE mode);
82:                
83:                //! Charge un filtre de réception
84:                void ChargerFiltre(unsigned char numero, unsigned char id);
85:                //void ChargerFiltre(unsigned int filter_no, unsigned int sid);
86:                
87:                //! Envoi CAN d'un CAN_MSG
88:                void EnvoiCanMsg(CAN_MSG *source);
89:                
90:                //! Envoi CAN d'un CAN_MSG (TxB dédicacés)
91:                void CanEnvoi(unsigned char productionId);
92:                
93:                /********************************************************
94:                *						FONCTIONS						*
95:                ********************************************************/
96:                
97:                /****************** DECLARATION PRODUCTION *******************/
98:                
99:                void CanDeclarationProduction(unsigned char id, void *ptrData, unsigned char len)
100:               {
001C1E  FA0006     LNK #0x6
001C20  784F00     MOV.B W0, [W14]
001C22  980711     MOV W1, [W14+2]
001C24  984742     MOV.B W2, [W14+4]
101:               	// Teste si on a pas dépassé la limite des objets produits
102:               	if(nombreObjetsProduits <= MAX_OBJETS_PRODUITS)				
001C26  2088A4     MOV #0x88A, W4
001C28  784214     MOV.B [W4], W4
001C2A  524FE8     SUB.B W4, #0x8, [W15]
001C2C  3E0042     BRA GTU, 0x1CB2
103:               	{
104:               		nombreObjetsProduits++;
001C2E  2088A4     MOV #0x88A, W4
001C30  784214     MOV.B [W4], W4
001C32  E84204     INC.B W4, W4
001C34  784004     MOV.B W4, W0
001C36  B7E88A     MOV.B WREG, nombreObjetsProduits
105:               		production[nombreObjetsProduits].id = id;
001C38  2088A4     MOV #0x88A, W4
001C3A  784214     MOV.B [W4], W4
001C3C  FB8204     ZE W4, W4
001C3E  B92266     MUL.SU W4, #6, W4
001C40  780284     MOV W4, W5
001C42  208004     MOV #0x800, W4
001C44  428204     ADD W5, W4, W4
001C46  784A1E     MOV.B [W14], [W4]
106:               		transmitBuffers[nombreObjetsProduits].SID = id;
001C48  2088A4     MOV #0x88A, W4
001C4A  784214     MOV.B [W4], W4
001C4C  FB8284     ZE W4, W5
001C4E  78431E     MOV.B [W14], W6
001C50  FB8206     ZE W6, W4
001C52  207FF6     MOV #0x7FF, W6
001C54  620206     AND W4, W6, W4
001C56  DD2B44     SL W5, #4, W6
001C58  240005     MOV #0x4000, W5
001C5A  430285     ADD W6, W5, W5
001C5C  207FF6     MOV #0x7FF, W6
001C5E  620206     AND W4, W6, W4
001C60  DD2242     SL W4, #2, W4
001C62  780395     MOV [W5], W7
001C64  2E0036     MOV #0xE003, W6
001C66  638306     AND W7, W6, W6
001C68  730204     IOR W6, W4, W4
001C6A  780A84     MOV W4, [W5]
107:               		production[nombreObjetsProduits].ptrData = ptrData;
001C6C  2088A4     MOV #0x88A, W4
001C6E  784214     MOV.B [W4], W4
001C70  FB8204     ZE W4, W4
001C72  B92266     MUL.SU W4, #6, W4
001C74  780284     MOV W4, W5
001C76  208024     MOV #0x802, W4
001C78  428204     ADD W5, W4, W4
001C7A  90001E     MOV [W14+2], W0
001C7C  780A00     MOV W0, [W4]
108:               		production[nombreObjetsProduits].len = len;
001C7E  2088A4     MOV #0x88A, W4
001C80  784214     MOV.B [W4], W4
001C82  FB8204     ZE W4, W4
001C84  B92266     MUL.SU W4, #6, W4
001C86  780284     MOV W4, W5
001C88  208044     MOV #0x804, W4
001C8A  428204     ADD W5, W4, W4
001C8C  9042CE     MOV.B [W14+4], W5
001C8E  784A05     MOV.B W5, [W4]
109:               		transmitBuffers[nombreObjetsProduits].DLC = len;
001C90  2088A4     MOV #0x88A, W4
001C92  784214     MOV.B [W4], W4
001C94  FB8284     ZE W4, W5
001C96  90424E     MOV.B [W14+4], W4
001C98  62426F     AND.B W4, #0xF, W4
001C9A  DD2B44     SL W5, #4, W6
001C9C  240045     MOV #0x4004, W5
001C9E  430285     ADD W6, W5, W5
001CA0  FB8204     ZE W4, W4
001CA2  62026F     AND W4, #0xF, W4
001CA4  780395     MOV [W5], W7
001CA6  2FFF06     MOV #0xFFF0, W6
001CA8  638306     AND W7, W6, W6
001CAA  730204     IOR W6, W4, W4
001CAC  780A84     MOV W4, [W5]
110:               		//TODO implémenter la verification du fait qu'on est le producteur declare dans CanNetwork.h
111:               	}
112:               	// ATTENTION, ON DEPASSE LE NOMBRE DE PRODUCTIONS AUTORISE
113:               	else
114:               		while(1);					
001CB2  37FFFF     BRA 0x1CB2
115:               }
001CAE  FA8000     ULNK
001CB0  060000     RETURN
116:               
117:               /****************** DECLARATION CONSOMMATION *****************/
118:               
119:               void CanDeclarationConsommation(unsigned char id, void *ptrData, unsigned char len)
120:               {
001CB4  FA0006     LNK #0x6
001CB6  784F00     MOV.B W0, [W14]
001CB8  980711     MOV W1, [W14+2]
001CBA  984742     MOV.B W2, [W14+4]
121:               	// Teste si on a pas dépassé la limite des objets consommés
122:               	if(nombreObjetsConsommes <= MAX_OBJETS_CONSOMMES)				
001CBC  2088B4     MOV #0x88B, W4
001CBE  784214     MOV.B [W4], W4
001CC0  524FEF     SUB.B W4, #0xF, [W15]
001CC2  3E0026     BRA GTU, 0x1D10
123:               	{
124:               		consommation[nombreObjetsConsommes].id = id;
001CC4  2088B4     MOV #0x88B, W4
001CC6  784214     MOV.B [W4], W4
001CC8  FB8204     ZE W4, W4
001CCA  B92266     MUL.SU W4, #6, W4
001CCC  780284     MOV W4, W5
001CCE  208304     MOV #0x830, W4
001CD0  428204     ADD W5, W4, W4
001CD2  784A1E     MOV.B [W14], [W4]
125:               		consommation[nombreObjetsConsommes].ptrData = ptrData;
001CD4  2088B4     MOV #0x88B, W4
001CD6  784214     MOV.B [W4], W4
001CD8  FB8204     ZE W4, W4
001CDA  B92266     MUL.SU W4, #6, W4
001CDC  780284     MOV W4, W5
001CDE  208324     MOV #0x832, W4
001CE0  428204     ADD W5, W4, W4
001CE2  90001E     MOV [W14+2], W0
001CE4  780A00     MOV W0, [W4]
126:               		consommation[nombreObjetsConsommes].len = len;
001CE6  2088B4     MOV #0x88B, W4
001CE8  784214     MOV.B [W4], W4
001CEA  FB8204     ZE W4, W4
001CEC  B92266     MUL.SU W4, #6, W4
001CEE  780284     MOV W4, W5
001CF0  208344     MOV #0x834, W4
001CF2  428204     ADD W5, W4, W4
001CF4  9042CE     MOV.B [W14+4], W5
001CF6  784A05     MOV.B W5, [W4]
127:               		ChargerFiltre(nombreObjetsConsommes, id);
001CF8  2088B4     MOV #0x88B, W4
001CFA  784214     MOV.B [W4], W4
001CFC  78409E     MOV.B [W14], W1
001CFE  784004     MOV.B W4, W0
001D00  07011B     RCALL ChargerFiltre
128:               		nombreObjetsConsommes++;				
001D02  2088B4     MOV #0x88B, W4
001D04  784214     MOV.B [W4], W4
001D06  E84204     INC.B W4, W4
001D08  784004     MOV.B W4, W0
001D0A  B7E88B     MOV.B WREG, nombreObjetsConsommes
129:               	}
130:               	// ATTENTION, ON DEPASSE LE NOMBRE DE CONSOMMATIONS AUTORISE
131:               	else
132:               		while(1);
001D10  37FFFF     BRA 0x1D10
133:               }
001D0C  FA8000     ULNK
001D0E  060000     RETURN
134:               /****************** ENVOI PRODUCTIONS ************************/
135:               
136:               void CanEnvoiProductions(void)
137:               {
001D12  FA0000     LNK #0x0
138:               	// Envoi de tous les messages CAN que l'on produit
139:               	for(kik=1; kik <= nombreObjetsProduits; kik++)
001D14  B3C014     MOV #0x1, W4
001D16  784004     MOV.B W4, W0
001D18  B7E88D     MOV.B WREG, kik
001D1A  370009     BRA 0x1D2E
001D24  2088D4     MOV #0x88D, W4
001D26  784214     MOV.B [W4], W4
001D28  E84204     INC.B W4, W4
001D2A  784004     MOV.B W4, W0
001D2C  B7E88D     MOV.B WREG, kik
001D2E  2088D5     MOV #0x88D, W5
001D30  784295     MOV.B [W5], W5
001D32  2088A4     MOV #0x88A, W4
001D34  784214     MOV.B [W4], W4
001D36  52CF84     SUB.B W5, W4, [W15]
001D38  36FFF1     BRA LEU, 0x1D1C
140:               		CanEnvoi(kik);
001D1C  2088D4     MOV #0x88D, W4
001D1E  784214     MOV.B [W4], W4
001D20  784004     MOV.B W4, W0
001D22  070194     RCALL CanEnvoi
141:               }
001D3A  FA8000     ULNK
001D3C  060000     RETURN
142:               
143:               /****************** ENVOI PRODUCTION *************************/
144:               
145:               void CanEnvoiProduction(void *ptrData)
146:               {
001D3E  FA0002     LNK #0x2
001D40  780F00     MOV W0, [W14]
147:               #ifndef DEBUG_CAN_DISABLE
148:               	//CAN_MSG *message;
149:               
150:               	// Recherche du message CAN produit en fonction du pointeur reçu
151:               	for(jij=1; jij <= nombreObjetsProduits; jij++)
001D42  B3C014     MOV #0x1, W4
001D44  784004     MOV.B W4, W0
001D46  B7E88C     MOV.B WREG, jij
001D48  370010     BRA 0x1D6A
001D60  2088C4     MOV #0x88C, W4
001D62  784214     MOV.B [W4], W4
001D64  E84204     INC.B W4, W4
001D66  784004     MOV.B W4, W0
001D68  B7E88C     MOV.B WREG, jij
001D6A  2088C5     MOV #0x88C, W5
001D6C  784295     MOV.B [W5], W5
001D6E  2088A4     MOV #0x88A, W4
001D70  784214     MOV.B [W4], W4
001D72  52CF84     SUB.B W5, W4, [W15]
001D74  36FFEA     BRA LEU, 0x1D4A
001D76  370001     BRA 0x1D7A
152:               		if(production[jij].ptrData == ptrData)
001D4A  2088C4     MOV #0x88C, W4
001D4C  784214     MOV.B [W4], W4
001D4E  FB8204     ZE W4, W4
001D50  B92266     MUL.SU W4, #6, W4
001D52  780204     MOV W4, W4
001D54  E88284     INC2 W4, W5
001D56  208004     MOV #0x800, W4
001D58  428204     ADD W5, W4, W4
001D5A  780214     MOV [W4], W4
001D5C  520F9E     SUB W4, [W14], [W15]
001D5E  32000C     BRA Z, 0x1D78
153:               			break;
001D78  000000     NOP
154:               
155:               	// Envoi impossible car incorrect
156:               	if(jij == nombreObjetsProduits+1)	
001D7A  2088C4     MOV #0x88C, W4
001D7C  784214     MOV.B [W4], W4
001D7E  FB8284     ZE W4, W5
001D80  2088A4     MOV #0x88A, W4
001D82  784214     MOV.B [W4], W4
001D84  FB8204     ZE W4, W4
001D86  E80204     INC W4, W4
001D88  528F84     SUB W5, W4, [W15]
001D8A  3A0001     BRA NZ, 0x1D8E
157:               		while(1);
001D8C  37FFFF     BRA 0x1D8C
158:               
159:               	CanEnvoi(jij);
001D8E  2088C4     MOV #0x88C, W4
001D90  784214     MOV.B [W4], W4
001D92  784004     MOV.B W4, W0
001D94  07015B     RCALL CanEnvoi
160:               #endif
161:               }
001D96  FA8000     ULNK
001D98  060000     RETURN
162:               
163:               /****************** ENVOI ************************************/
164:               
165:               void EnvoiCanMsg(CAN_MSG *source)
166:               {
001D9A  FA0008     LNK #0x8
001D9C  980730     MOV W0, [W14+6]
167:                   #ifndef DEBUG_CAN_DISABLE
168:               	unsigned char i;
169:               	unsigned char *ptrSource, *ptrDest;
170:               
171:               
172:                       // Attente de la libération du buffer de transmission
173:               	while(C1TR01CONbits.TXREQ0);
001D9E  000000     NOP
001DA0  802184     MOV C1TR01CON, W4
001DA2  620268     AND W4, #0x8, W4
001DA4  520FE0     SUB W4, #0x0, [W15]
001DA6  3AFFFC     BRA NZ, 0x1DA0
174:               
175:               	// Chargement des variables de travail
176:               	ptrSource = (unsigned char*)source->ptrData;
001DA8  90023E     MOV [W14+6], W4
001DAA  900214     MOV [W4+2], W4
001DAC  980714     MOV W4, [W14+2]
177:               	ptrDest = &transmitBuffers[0].DATA[0];	
001DAE  240064     MOV #0x4006, W4
001DB0  980724     MOV W4, [W14+4]
178:               
179:               	// Chargement de l'ID à envoyer
180:               	transmitBuffers[0].SID = source->id;
001DB2  90023E     MOV [W14+6], W4
001DB4  784214     MOV.B [W4], W4
001DB6  FB8204     ZE W4, W4
001DB8  207FF5     MOV #0x7FF, W5
001DBA  620205     AND W4, W5, W4
001DBC  207FF5     MOV #0x7FF, W5
001DBE  620205     AND W4, W5, W4
001DC0  DD2242     SL W4, #2, W4
001DC2  820006     MOV transmitBuffers, W6
001DC4  2E0035     MOV #0xE003, W5
001DC6  630285     AND W6, W5, W5
001DC8  728204     IOR W5, W4, W4
001DCA  8A0004     MOV W4, transmitBuffers
181:               
182:               	// Configuration de la longueur du message
183:               	transmitBuffers[0].DLC = source->len;
001DCC  90023E     MOV [W14+6], W4
001DCE  904244     MOV.B [W4+4], W4
001DD0  62426F     AND.B W4, #0xF, W4
001DD2  FB8204     ZE W4, W4
001DD4  62026F     AND W4, #0xF, W4
001DD6  820026     MOV 0x4004, W6
001DD8  2FFF05     MOV #0xFFF0, W5
001DDA  630285     AND W6, W5, W5
001DDC  728204     IOR W5, W4, W4
001DDE  8A0024     MOV W4, 0x4004
184:               
185:               	// Chargement des données
186:               	for(i = 0; i < source->len; i++)
001DE0  EB4200     CLR.B W4
001DE2  784F04     MOV.B W4, [W14]
001DE4  37000B     BRA 0x1DFC
001DFA  E84F1E     INC.B [W14], [W14]
001DFC  90023E     MOV [W14+6], W4
001DFE  904244     MOV.B [W4+4], W4
001E00  524F9E     SUB.B W4, [W14], [W15]
001E02  3EFFF1     BRA GTU, 0x1DE6
187:               		*(ptrDest++) = *(ptrSource++);
001DE6  90021E     MOV [W14+2], W4
001DE8  784214     MOV.B [W4], W4
001DEA  9002AE     MOV [W14+4], W5
001DEC  784A84     MOV.B W4, [W5]
001DEE  90022E     MOV [W14+4], W4
001DF0  E80204     INC W4, W4
001DF2  980724     MOV W4, [W14+4]
001DF4  90021E     MOV [W14+2], W4
001DF6  E80204     INC W4, W4
001DF8  980714     MOV W4, [W14+2]
188:               
189:               	// Demande d'envoi
190:               	C1TR01CONbits.TX0PRI1 = 1;
001E04  A82430     BSET C1TR01CON, #1
191:               	C1TR01CONbits.TX0PRI0 = 1;	
001E06  A80430     BSET C1TR01CON, #0
192:               	C1TR01CONbits.TXREQ0 = 1;
001E08  A86430     BSET C1TR01CON, #3
193:               #endif
194:               }
001E0A  FA8000     ULNK
001E0C  060000     RETURN
195:               
196:               /****************** INITIALIZE *******************************/
197:               
198:               void CanInitialisation(unsigned char CanID)
199:               {
001E0E  FA0002     LNK #0x2
001E10  784F00     MOV.B W0, [W14]
200:                   // Put module into configuration mode
201:                   CanSetOperationMode(CAN_OP_MODE_CONFIG);	
001E12  200040     MOV #0x4, W0
001E14  070039     RCALL CanSetOperationMode
202:               
203:               	// Set Bit rate values as 500k
204:               	CanSetBaudRate(CAN_BAUDRATE_500k);
001E16  2A1200     MOV #0xA120, W0
001E18  200071     MOV #0x7, W1
001E1A  07004D     RCALL CanSetBaudRate
205:               	
206:               	// Configure first 8 TxRx Buffers as Transmit Buffers, next 8 adressable buffers automatically receive buffers
207:               	C1TR01CON = 0x8080;
001E1C  280804     MOV #0x8080, W4
001E1E  882184     MOV W4, C1TR01CON
208:               	C1TR23CON = 0x8080;
001E20  280804     MOV #0x8080, W4
001E22  882194     MOV W4, C1TR23CON
209:               	C1TR45CON = 0x8080;
001E24  280804     MOV #0x8080, W4
001E26  8821A4     MOV W4, C1TR45CON
210:               	C1TR67CON = 0x8080;
001E28  280804     MOV #0x8080, W4
001E2A  8821B4     MOV W4, C1TR67CON
211:               	
212:               	// Configures the DMA buffer size to 12 buffers and makes FIFO start at buffer 16
213:               	C1FCTRLbits.DMABS 	= 0b011;
001E2C  802034     MOV C1FCTRL, W4
001E2E  A0D004     BSET W4, #13
001E30  A0E004     BSET W4, #14
001E32  A1F004     BCLR W4, #15
001E34  882034     MOV W4, C1FCTRL
214:               	C1FCTRLbits.FSA 	= 0b10000;
001E36  802035     MOV C1FCTRL, W5
001E38  2FFE04     MOV #0xFFE0, W4
001E3A  628204     AND W5, W4, W4
001E3C  A04004     BSET W4, #4
001E3E  882034     MOV W4, C1FCTRL
215:               
216:               	// Points the FIFO Write Buffer and Next FIFO Read Buffer to buffer 16
217:               	C1FIFO = 0x1010;
001E40  210104     MOV #0x1010, W4
001E42  882044     MOV W4, C1FIFO
218:               		
219:               	// Activates filter window to configure filter and mask registers
220:               	C1CTRL1bits.WIN = 1;
001E44  A80400     BSET C1CTRL1, #0
221:               	
222:               	// Associates filters 0 -> 14 to RX buffer 8 and 15 to RX buffer 9
223:               	C1BUFPNT1 = 0x8888;
001E46  288884     MOV #0x8888, W4
001E48  882104     MOV W4, C1RXFUL1
224:               	C1BUFPNT2 = 0x8888;
001E4A  288884     MOV #0x8888, W4
001E4C  882114     MOV W4, C1RXFUL2
225:               	C1BUFPNT3 = 0x8888;
001E4E  288884     MOV #0x8888, W4
001E50  882124     MOV W4, C1BUFPNT3
226:               	C1BUFPNT4 = 0x9888;
001E52  298884     MOV #0x9888, W4
001E54  882134     MOV W4, C1BUFPNT4
227:               
228:               	// Activates acceptance filter 15, disables all the others
229:               	C1FEN1 = 0x8000;
001E56  280004     MOV #0x8000, W4
001E58  8820A4     MOV W4, C1FEN1
230:               		
231:               	// Associates mask 0 to all filters
232:               	C1FMSKSEL1 = 0x0000;
001E5A  EB0200     CLR W4
001E5C  8820C4     MOV W4, C1FMSKSEL1
233:               	C1FMSKSEL2 = 0x0000;
001E5E  EB0200     CLR W4
001E60  8820D4     MOV W4, C1FMSKSEL2
234:               
235:               	// Sets maks 1 to check all bits
236:               	C1RXM0SID = 0b1111111111101000;
001E62  2FFE84     MOV #0xFFE8, W4
001E64  882184     MOV W4, C1TR01CON
237:               
238:               	// Set Filter 15 Value
239:               	ChargerFiltre(15, CanID);
001E66  78409E     MOV.B [W14], W1
001E68  B3C0F0     MOV #0xF, W0
001E6A  070066     RCALL ChargerFiltre
240:               
241:               	// Deactivates filter window
242:               	C1CTRL1bits.WIN = 0;
001E6C  A90400     BCLR C1CTRL1, #0
243:               
244:               	// Enable receive interrupt only
245:               	C1INTEbits.RBIE = 0x1;
001E6E  A8240C     BSET C1INTE, #1
246:               
247:               	// Initializes DMA channels to send and receive CAN messages
248:               	dma0init();
001E70  070177     RCALL dma0init
249:               	dma1init();
001E72  070191     RCALL dma1init
250:               
251:               	// Put module into normal mode
252:               	CanSetOperationMode(CAN_OP_MODE_NORMAL);
001E74  EB0000     CLR W0
001E76  070008     RCALL CanSetOperationMode
253:               
254:               	nombreObjetsProduits = 0;
001E78  EB4200     CLR.B W4
001E7A  784004     MOV.B W4, W0
001E7C  B7E88A     MOV.B WREG, nombreObjetsProduits
255:               	nombreObjetsConsommes = 0;
001E7E  EB4200     CLR.B W4
001E80  784004     MOV.B W4, W0
001E82  B7E88B     MOV.B WREG, nombreObjetsConsommes
256:               }
001E84  FA8000     ULNK
001E86  060000     RETURN
257:               
258:               /****************** SET OPERATION MODE ***********************/
259:               
260:               void CanSetOperationMode(CAN_OP_MODE mode)
261:               {
001E88  FA0002     LNK #0x2
001E8A  780F00     MOV W0, [W14]
262:               	// Clear all pending transmissions
263:                   C1CTRL1bits.ABAT = 1;    
001E8C  A88401     BSET 0x401, #4
264:               
265:               	// Request Configuration Mode
266:               	C1CTRL1bits.REQOP = mode;
001E8E  78021E     MOV [W14], W4
001E90  784204     MOV.B W4, W4
001E92  624267     AND.B W4, #0x7, W4
001E94  FB8204     ZE W4, W4
001E96  620267     AND W4, #0x7, W4
001E98  DD2248     SL W4, #8, W4
001E9A  802006     MOV C1CTRL1, W6
001E9C  2F8FF5     MOV #0xF8FF, W5
001E9E  630285     AND W6, W5, W5
001EA0  728204     IOR W5, W4, W4
001EA2  882004     MOV W4, C1CTRL1
267:               	                
268:               	// Wait till desired mode is set
269:               	while(C1CTRL1bits.OPMODE != mode);  
001EA4  000000     NOP
001EA6  802004     MOV C1CTRL1, W4
001EA8  DE2245     LSR W4, #5, W4
001EAA  624267     AND.B W4, #0x7, W4
001EAC  FB8204     ZE W4, W4
001EAE  520F9E     SUB W4, [W14], [W15]
001EB0  3AFFFA     BRA NZ, 0x1EA6
270:               }
001EB2  FA8000     ULNK
001EB4  060000     RETURN
271:               
272:               /****************** SET BAUDRATE *****************************/
273:               
274:               void CanSetBaudRate(CAN_BAUDRATE baudrate)
275:               {
001EB6  FA0006     LNK #0x6
001EB8  980710     MOV W0, [W14+2]
001EBA  980721     MOV W1, [W14+4]
276:               	// Saves the current operation mode
277:               	CAN_OP_MODE currentMode = CanGetOperationMode();	
001EBC  802004     MOV C1CTRL1, W4
001EBE  DE2245     LSR W4, #5, W4
001EC0  624267     AND.B W4, #0x7, W4
001EC2  FB8204     ZE W4, W4
001EC4  780F04     MOV W4, [W14]
278:               	
279:               	// Switch to configuration mode
280:               	CanSetOperationMode(CAN_OP_MODE_CONFIG);
001EC6  200040     MOV #0x4, W0
001EC8  07FFDF     RCALL CanSetOperationMode
281:               
282:               	// FCAN is selected to be FCY = 40MHz
283:               	C1CTRL1bits.CANCKS = 0x1;
001ECA  A86401     BSET 0x401, #3
284:               		
285:               	/*
286:               	Bit Time = (Sync Segment + Propagation Delay + Phase Segment 1 + Phase Segment 2)=20*TQ
287:               	Phase Segment 1 = 8TQ
288:               	Phase Segment 2 = 6Tq
289:               	Propagation Delay = 5Tq
290:               	Sync Segment = 1TQ
291:               	CiCFG1<BRP> =(FCAN /(2 ×N×FBAUD))? 1
292:               	*/
293:               		
294:               	/* Synchronization Jump Width set to 4 TQ */
295:               	C1CFG1bits.SJW = 0x3;
001ECC  802084     MOV C1CFG1, W4
001ECE  A06004     BSET W4, #6
001ED0  A07004     BSET W4, #7
001ED2  882084     MOV W4, C1CFG1
296:               	
297:               	/* Baud Rate Prescaler */
298:               	C1CFG1bits.BRP = ((FCAN/(2*NTQ*baudrate))-1);
001ED4  9002AE     MOV [W14+4], W5
001ED6  200284     MOV #0x28, W4
001ED8  B9AA04     MUL.SS W5, W4, W4
001EDA  780304     MOV W4, W6
001EDC  90021E     MOV [W14+2], W4
001EDE  B92260     MUL.SU W4, #0, W4
001EE0  780204     MOV W4, W4
001EE2  430304     ADD W6, W4, W6
001EE4  90029E     MOV [W14+2], W5
001EE6  200284     MOV #0x28, W4
001EE8  B82A04     MUL.UU W5, W4, W4
001EEA  430305     ADD W6, W5, W6
001EEC  780286     MOV W6, W5
001EEE  BE0104     MOV.D W4, W2
001EF0  25A000     MOV #0x5A00, W0
001EF2  202621     MOV #0x262, W1
001EF4  07F4C9     RCALL ___udivsi3x
001EF6  BE0200     MOV.D W0, W4
001EF8  784204     MOV.B W4, W4
001EFA  E94204     DEC.B W4, W4
001EFC  B243F4     AND.B #0x3F, W4
001EFE  FB8284     ZE W4, W5
001F00  2003F4     MOV #0x3F, W4
001F02  628204     AND W5, W4, W4
001F04  802086     MOV C1CFG1, W6
001F06  2FFC05     MOV #0xFFC0, W5
001F08  630285     AND W6, W5, W5
001F0A  728204     IOR W5, W4, W4
001F0C  882084     MOV W4, C1CFG1
299:               	
300:               	/* Phase Segment 1 time is 8 TQ */
301:               	C1CFG2bits.SEG1PH=0x7;
001F0E  802094     MOV C1CFG2, W4
001F10  A03004     BSET W4, #3
001F12  A04004     BSET W4, #4
001F14  A05004     BSET W4, #5
001F16  882094     MOV W4, C1CFG2
302:               	/* Phase Segment 2 time is set to be programmable */
303:               	C1CFG2bits.SEG2PHTS = 0x1;
001F18  A8E412     BSET C1CFG2, #7
304:               	/* Phase Segment 2 time is 6 TQ */
305:               	C1CFG2bits.SEG2PH = 0x5;
001F1A  802094     MOV C1CFG2, W4
001F1C  A08004     BSET W4, #8
001F1E  A19004     BCLR W4, #9
001F20  A0A004     BSET W4, #10
001F22  882094     MOV W4, C1CFG2
306:               	/* Propagation Segment time is 5 TQ */
307:               	C1CFG2bits.PRSEG = 0x4;
001F24  802094     MOV C1CFG2, W4
001F26  A10004     BCLR W4, #0
001F28  A11004     BCLR W4, #1
001F2A  A02004     BSET W4, #2
001F2C  882094     MOV W4, C1CFG2
308:               	/* Bus line is sampled three times at the sample point */
309:               	C1CFG2bits.SAM = 0x1;
001F2E  A8C412     BSET C1CFG2, #6
310:               
311:               	// Restores the previous operation mode
312:               	CanSetOperationMode(currentMode);					
001F30  78001E     MOV [W14], W0
001F32  07FFAA     RCALL CanSetOperationMode
313:               }
001F34  FA8000     ULNK
001F36  060000     RETURN
314:               
315:               /****************** CHARGER FILTRE ***************************/
316:               
317:               void ChargerFiltre(unsigned char numero, unsigned char id)
318:               {
001F38  FA0004     LNK #0x4
001F3A  984720     MOV.B W0, [W14+2]
001F3C  984731     MOV.B W1, [W14+3]
319:               	// Saves the current operation mode
320:               	CAN_OP_MODE currentMode = CanGetOperationMode();	
001F3E  802004     MOV C1CTRL1, W4
001F40  DE2245     LSR W4, #5, W4
001F42  624267     AND.B W4, #0x7, W4
001F44  FB8204     ZE W4, W4
001F46  780F04     MOV W4, [W14]
321:               	
322:               	// Switch to configuration mode
323:               	CanSetOperationMode(CAN_OP_MODE_CONFIG);
001F48  200040     MOV #0x4, W0
001F4A  07FF9E     RCALL CanSetOperationMode
324:               
325:               	// Activates filter window to configure filter and mask registers
326:               	C1CTRL1bits.WIN = 1;
001F4C  A80400     BSET C1CTRL1, #0
327:               
328:               	switch (numero)
001F4E  90422E     MOV.B [W14+2], W4
001F50  FB8204     ZE W4, W4
001F52  DEA2CF     ASR W4, #15, W5
001F54  2000F6     MOV #0xF, W6
001F56  200007     MOV #0x0, W7
001F58  520F86     SUB W4, W6, [W15]
001F5A  5A8F87     SUBB W5, W7, [W15]
001F5C  3E0071     BRA GTU, 0x2040
001F5E  016004     BRA W4
001F60  37000F     BRA 0x1F80
001F62  370014     BRA 0x1F8C
001F64  370019     BRA 0x1F98
001F66  37001E     BRA 0x1FA4
001F68  370023     BRA 0x1FB0
001F6A  370028     BRA 0x1FBC
001F6C  37002D     BRA 0x1FC8
001F6E  370032     BRA 0x1FD4
001F70  370037     BRA 0x1FE0
001F72  37003C     BRA 0x1FEC
001F74  370041     BRA 0x1FF8
001F76  370046     BRA 0x2004
001F78  37004B     BRA 0x2010
001F7A  370050     BRA 0x201C
001F7C  370055     BRA 0x2028
001F7E  37005A     BRA 0x2034
329:               	{
330:               		case 0 : _SetRXFnValue(0, id); break;
001F80  90423E     MOV.B [W14+3], W4
001F82  FB8204     ZE W4, W4
001F84  DD2245     SL W4, #5, W4
001F86  882204     MOV W4, C1RXD
001F88  A80414     BSET C1FEN1, #0
001F8A  37005B     BRA 0x2042
331:               		case 1 : _SetRXFnValue(1, id); break;
001F8C  90423E     MOV.B [W14+3], W4
001F8E  FB8204     ZE W4, W4
001F90  DD2245     SL W4, #5, W4
001F92  882224     MOV W4, C1RXF1SID
001F94  A82414     BSET C1FEN1, #1
001F96  370055     BRA 0x2042
332:               		case 2 : _SetRXFnValue(2, id); break;
001F98  90423E     MOV.B [W14+3], W4
001F9A  FB8204     ZE W4, W4
001F9C  DD2245     SL W4, #5, W4
001F9E  882244     MOV W4, C1RXF2SID
001FA0  A84414     BSET C1FEN1, #2
001FA2  37004F     BRA 0x2042
333:               		case 3 : _SetRXFnValue(3, id); break;
001FA4  90423E     MOV.B [W14+3], W4
001FA6  FB8204     ZE W4, W4
001FA8  DD2245     SL W4, #5, W4
001FAA  882264     MOV W4, C1RXF3SID
001FAC  A86414     BSET C1FEN1, #3
001FAE  370049     BRA 0x2042
334:               		case 4 : _SetRXFnValue(4, id); break;
001FB0  90423E     MOV.B [W14+3], W4
001FB2  FB8204     ZE W4, W4
001FB4  DD2245     SL W4, #5, W4
001FB6  882284     MOV W4, C1RXF4SID
001FB8  A88414     BSET C1FEN1, #4
001FBA  370043     BRA 0x2042
335:               		case 5 : _SetRXFnValue(5, id); break;
001FBC  90423E     MOV.B [W14+3], W4
001FBE  FB8204     ZE W4, W4
001FC0  DD2245     SL W4, #5, W4
001FC2  8822A4     MOV W4, C1RXF5SID
001FC4  A8A414     BSET C1FEN1, #5
001FC6  37003D     BRA 0x2042
336:               		case 6 : _SetRXFnValue(6, id); break;
001FC8  90423E     MOV.B [W14+3], W4
001FCA  FB8204     ZE W4, W4
001FCC  DD2245     SL W4, #5, W4
001FCE  8822C4     MOV W4, C1RXF6SID
001FD0  A8C414     BSET C1FEN1, #6
001FD2  370037     BRA 0x2042
337:               		case 7 : _SetRXFnValue(7, id); break;
001FD4  90423E     MOV.B [W14+3], W4
001FD6  FB8204     ZE W4, W4
001FD8  DD2245     SL W4, #5, W4
001FDA  8822E4     MOV W4, C1RXF7SID
001FDC  A8E414     BSET C1FEN1, #7
001FDE  370031     BRA 0x2042
338:               		case 8 : _SetRXFnValue(8, id); break;
001FE0  90423E     MOV.B [W14+3], W4
001FE2  FB8204     ZE W4, W4
001FE4  DD2245     SL W4, #5, W4
001FE6  882304     MOV W4, C1RXF8SID
001FE8  A80415     BSET 0x415, #0
001FEA  37002B     BRA 0x2042
339:               		case 9 : _SetRXFnValue(9, id); break;
001FEC  90423E     MOV.B [W14+3], W4
001FEE  FB8204     ZE W4, W4
001FF0  DD2245     SL W4, #5, W4
001FF2  882324     MOV W4, C1RXF9SID
001FF4  A82415     BSET 0x415, #1
001FF6  370025     BRA 0x2042
340:               		case 10 : _SetRXFnValue(10, id); break;
001FF8  90423E     MOV.B [W14+3], W4
001FFA  FB8204     ZE W4, W4
001FFC  DD2245     SL W4, #5, W4
001FFE  882344     MOV W4, C1RXF10SID
002000  A84415     BSET 0x415, #2
002002  37001F     BRA 0x2042
341:               		case 11 : _SetRXFnValue(11, id); break;
002004  90423E     MOV.B [W14+3], W4
002006  FB8204     ZE W4, W4
002008  DD2245     SL W4, #5, W4
00200A  882364     MOV W4, C1RXF11SID
00200C  A86415     BSET 0x415, #3
00200E  370019     BRA 0x2042
342:               		case 12 : _SetRXFnValue(12, id); break;
002010  90423E     MOV.B [W14+3], W4
002012  FB8204     ZE W4, W4
002014  DD2245     SL W4, #5, W4
002016  882384     MOV W4, C1RXF12SID
002018  A88415     BSET 0x415, #4
00201A  370013     BRA 0x2042
343:               		case 13 : _SetRXFnValue(13, id); break;
00201C  90423E     MOV.B [W14+3], W4
00201E  FB8204     ZE W4, W4
002020  DD2245     SL W4, #5, W4
002022  8823A4     MOV W4, C1RXF13SID
002024  A8A415     BSET 0x415, #5
002026  37000D     BRA 0x2042
344:               		case 14 : _SetRXFnValue(14, id); break;			
002028  90423E     MOV.B [W14+3], W4
00202A  FB8204     ZE W4, W4
00202C  DD2245     SL W4, #5, W4
00202E  8823C4     MOV W4, C1RXF14SID
002030  A8C415     BSET 0x415, #6
002032  370007     BRA 0x2042
345:               		case 15 : _SetRXFnValue(15, id); break;
002034  90423E     MOV.B [W14+3], W4
002036  FB8204     ZE W4, W4
002038  DD2245     SL W4, #5, W4
00203A  8823E4     MOV W4, C1RXF15SID
00203C  A8E415     BSET 0x415, #7
00203E  370001     BRA 0x2042
346:               		default : break;
002040  000000     NOP
347:               	}
348:               	
349:               	// Deactivates filter window
350:               	C1CTRL1bits.WIN = 0;
002042  A90400     BCLR C1CTRL1, #0
351:               
352:               	// Restores the previous operation mode
353:               	CanSetOperationMode(currentMode);	
002044  78001E     MOV [W14], W0
002046  07FF20     RCALL CanSetOperationMode
354:               }
002048  FA8000     ULNK
00204A  060000     RETURN
355:               
356:               /****************** ENVOI ************************************/
357:               
358:               void CanEnvoi(unsigned char productionId)
359:               {
00204C  FA0008     LNK #0x8
00204E  984760     MOV.B W0, [W14+6]
360:               	unsigned char i;
361:               	unsigned char *ptrSource, *ptrDest;
362:               	//CAN_MSG *message;
363:               
364:               	// Chargement des variables de travail
365:               	ptrSource = production[productionId].ptrData;
002050  90426E     MOV.B [W14+6], W4
002052  FB8204     ZE W4, W4
002054  B92266     MUL.SU W4, #6, W4
002056  780204     MOV W4, W4
002058  E88284     INC2 W4, W5
00205A  208004     MOV #0x800, W4
00205C  428204     ADD W5, W4, W4
00205E  780214     MOV [W4], W4
002060  980714     MOV W4, [W14+2]
366:               
367:               	ptrDest = &transmitBuffers[productionId].DATA[0];
002062  90426E     MOV.B [W14+6], W4
002064  FB8204     ZE W4, W4
002066  DD2244     SL W4, #4, W4
002068  4202E6     ADD W4, #0x6, W5
00206A  240004     MOV #0x4000, W4
00206C  428204     ADD W5, W4, W4
00206E  980724     MOV W4, [W14+4]
368:               	
369:               	// Chargement des données
370:               	for(i = 0; i < production[productionId].len; i++)
002070  EB4200     CLR.B W4
002072  784F04     MOV.B W4, [W14]
002074  37000B     BRA 0x208C
00208A  E84F1E     INC.B [W14], [W14]
00208C  90426E     MOV.B [W14+6], W4
00208E  FB8204     ZE W4, W4
002090  B92266     MUL.SU W4, #6, W4
002092  780204     MOV W4, W4
002094  4202E4     ADD W4, #0x4, W5
002096  208004     MOV #0x800, W4
002098  428204     ADD W5, W4, W4
00209A  784214     MOV.B [W4], W4
00209C  524F9E     SUB.B W4, [W14], [W15]
00209E  3EFFEB     BRA GTU, 0x2076
371:               		*(ptrDest++) = *(ptrSource++);
002076  90021E     MOV [W14+2], W4
002078  784214     MOV.B [W4], W4
00207A  9002AE     MOV [W14+4], W5
00207C  784A84     MOV.B W4, [W5]
00207E  90022E     MOV [W14+4], W4
002080  E80204     INC W4, W4
002082  980724     MOV W4, [W14+4]
002084  90021E     MOV [W14+2], W4
002086  E80204     INC W4, W4
002088  980714     MOV W4, [W14+2]
372:               
373:               	switch(productionId)
0020A0  90426E     MOV.B [W14+6], W4
0020A2  FB8204     ZE W4, W4
0020A4  DEA2CF     ASR W4, #15, W5
0020A6  200076     MOV #0x7, W6
0020A8  200007     MOV #0x0, W7
0020AA  520F86     SUB W4, W6, [W15]
0020AC  5A8F87     SUBB W5, W7, [W15]
0020AE  3E0055     BRA GTU, 0x215A
0020B0  016004     BRA W4
0020B2  370007     BRA 0x20C2
0020B4  37000F     BRA 0x20D4
0020B6  370018     BRA 0x20E8
0020B8  370020     BRA 0x20FA
0020BA  370029     BRA 0x210E
0020BC  370031     BRA 0x2120
0020BE  37003A     BRA 0x2134
0020C0  370042     BRA 0x2146
374:               	{
375:               		case 0:
376:               
377:               			// Attente de la libération du buffer de transmission	
378:               			while(C1TR01CONbits.TXREQ0);
0020C2  000000     NOP
0020C4  802184     MOV C1TR01CON, W4
0020C6  620268     AND W4, #0x8, W4
0020C8  520FE0     SUB W4, #0x0, [W15]
0020CA  3AFFFC     BRA NZ, 0x20C4
379:               
380:               			// Demande d'envoi
381:               			C1TR01CONbits.TX0PRI1 = 1;
0020CC  A82430     BSET C1TR01CON, #1
382:               			C1TR01CONbits.TX0PRI0 = 1;	
0020CE  A80430     BSET C1TR01CON, #0
383:               			C1TR01CONbits.TXREQ0 = 1;		
0020D0  A86430     BSET C1TR01CON, #3
384:               		break;
0020D2  370044     BRA 0x215C
385:               
386:               		case 1:
387:               
388:               			// Attente de la libération du buffer de transmission	
389:               			while(C1TR01CONbits.TXREQ1);
0020D4  000000     NOP
0020D6  802185     MOV C1TR01CON, W5
0020D8  208004     MOV #0x800, W4
0020DA  628204     AND W5, W4, W4
0020DC  520FE0     SUB W4, #0x0, [W15]
0020DE  3AFFFB     BRA NZ, 0x20D6
390:               
391:               			// Demande d'envoi
392:               			C1TR01CONbits.TX1PRI1 = 1;
0020E0  A82431     BSET 0x431, #1
393:               			C1TR01CONbits.TX1PRI0 = 1;	
0020E2  A80431     BSET 0x431, #0
394:               			C1TR01CONbits.TXREQ1 = 1;	
0020E4  A86431     BSET 0x431, #3
395:               		break;
0020E6  37003A     BRA 0x215C
396:               
397:               		case 2:
398:               			// Attente de la libération du buffer de transmission	
399:               			while(C1TR23CONbits.TXREQ2);
0020E8  000000     NOP
0020EA  802194     MOV C1TR23CON, W4
0020EC  620268     AND W4, #0x8, W4
0020EE  520FE0     SUB W4, #0x0, [W15]
0020F0  3AFFFC     BRA NZ, 0x20EA
400:               
401:               			// Demande d'envoi
402:               			C1TR23CONbits.TX2PRI1 = 1;
0020F2  A82432     BSET C1TR23CON, #1
403:               			C1TR23CONbits.TX2PRI0 = 1;	
0020F4  A80432     BSET C1TR23CON, #0
404:               			C1TR23CONbits.TXREQ2 = 1;	
0020F6  A86432     BSET C1TR23CON, #3
405:               		break;
0020F8  370031     BRA 0x215C
406:               
407:               		case 3:
408:               			// Attente de la libération du buffer de transmission	
409:               			while(C1TR23CONbits.TXREQ3);
0020FA  000000     NOP
0020FC  802195     MOV C1TR23CON, W5
0020FE  208004     MOV #0x800, W4
002100  628204     AND W5, W4, W4
002102  520FE0     SUB W4, #0x0, [W15]
002104  3AFFFB     BRA NZ, 0x20FC
410:               
411:               			// Demande d'envoi
412:               			C1TR23CONbits.TX3PRI1 = 1;
002106  A82433     BSET 0x433, #1
413:               			C1TR23CONbits.TX3PRI0 = 1;	
002108  A80433     BSET 0x433, #0
414:               			C1TR23CONbits.TXREQ3 = 1;
00210A  A86433     BSET 0x433, #3
415:               		break;
00210C  370027     BRA 0x215C
416:               
417:               		case 4:
418:               			// Attente de la libération du buffer de transmission	
419:               			while(C1TR45CONbits.TXREQ4);
00210E  000000     NOP
002110  8021A4     MOV C1TR45CON, W4
002112  620268     AND W4, #0x8, W4
002114  520FE0     SUB W4, #0x0, [W15]
002116  3AFFFC     BRA NZ, 0x2110
420:               
421:               			// Demande d'envoi
422:               			C1TR45CONbits.TX4PRI1 = 1;
002118  A82434     BSET C1TR45CON, #1
423:               			C1TR45CONbits.TX4PRI0 = 1;	
00211A  A80434     BSET C1TR45CON, #0
424:               			C1TR45CONbits.TXREQ4 = 1;
00211C  A86434     BSET C1TR45CON, #3
425:               		break;
00211E  37001E     BRA 0x215C
426:               
427:               		case 5:
428:               			// Attente de la libération du buffer de transmission	
429:               			while(C1TR45CONbits.TXREQ5);
002120  000000     NOP
002122  8021A5     MOV C1TR45CON, W5
002124  208004     MOV #0x800, W4
002126  628204     AND W5, W4, W4
002128  520FE0     SUB W4, #0x0, [W15]
00212A  3AFFFB     BRA NZ, 0x2122
430:               
431:               			// Demande d'envoi
432:               			C1TR45CONbits.TX5PRI1 = 1;
00212C  A82435     BSET 0x435, #1
433:               			C1TR45CONbits.TX5PRI0 = 1;	
00212E  A80435     BSET 0x435, #0
434:               			C1TR45CONbits.TXREQ5 = 1;
002130  A86435     BSET 0x435, #3
435:               		break;
002132  370014     BRA 0x215C
436:               
437:               		case 6:
438:               			// Attente de la libération du buffer de transmission	
439:               			while(C1TR67CONbits.TXREQ6);
002134  000000     NOP
002136  8021B4     MOV C1TR67CON, W4
002138  620268     AND W4, #0x8, W4
00213A  520FE0     SUB W4, #0x0, [W15]
00213C  3AFFFC     BRA NZ, 0x2136
440:               
441:               			// Demande d'envoi
442:               			C1TR67CONbits.TX6PRI1 = 1;
00213E  A82436     BSET C1TR67CON, #1
443:               			C1TR67CONbits.TX6PRI0 = 1;	
002140  A80436     BSET C1TR67CON, #0
444:               			C1TR67CONbits.TXREQ6 = 1;
002142  A86436     BSET C1TR67CON, #3
445:               		break;
002144  37000B     BRA 0x215C
446:               
447:               		case 7:
448:               			// Attente de la libération du buffer de transmission	
449:               			while(C1TR67CONbits.TXREQ7);
002146  000000     NOP
002148  8021B5     MOV C1TR67CON, W5
00214A  208004     MOV #0x800, W4
00214C  628204     AND W5, W4, W4
00214E  520FE0     SUB W4, #0x0, [W15]
002150  3AFFFB     BRA NZ, 0x2148
450:               
451:               			// Demande d'envoi
452:               			C1TR67CONbits.TX7PRI1 = 1;
002152  A82437     BSET 0x437, #1
453:               			C1TR67CONbits.TX7PRI0 = 1;	
002154  A80437     BSET 0x437, #0
454:               			C1TR67CONbits.TXREQ7 = 1;
002156  A86437     BSET 0x437, #3
455:               		break;
002158  370001     BRA 0x215C
456:               		
457:               		default:
458:               		break;
00215A  000000     NOP
459:               	}
460:               }
00215C  FA8000     ULNK
00215E  060000     RETURN
461:               
462:               /****************** Dma Initialization for TX ****************/
463:               
464:               void dma0init(void){
002160  FA0000     LNK #0x0
465:               
466:               	DMACS0=0;						// Clear DMA Status
002162  EB0200     CLR W4
002164  881F04     MOV W4, DMACS0
467:                   
468:               	DMA0CONbits.SIZE = 0x0; 		// Data Transfer Size: Word Transfer Mode
002166  A9C381     BCLR 0x381, #6
469:               	DMA0CONbits.DIR = 0x1; 			// Data Transfer Direction: DMA RAM to Peripheral  
002168  A8A381     BSET 0x381, #5
470:               	DMA0CONbits.HALF = 0x0;			// Initiate interrupt when all data has been transfered	 
00216A  A98381     BCLR 0x381, #4
471:               	DMA0CONbits.NULLW = 0x0;		// Normal operation (no NULL data write)
00216C  A96381     BCLR 0x381, #3
472:               	DMA0CONbits.AMODE = 0x2; 		// DMA Addressing Mode: Peripheral Indirect Addressing mode
00216E  801C04     MOV DMA0CON, W4
002170  A14004     BCLR W4, #4
002172  A05004     BSET W4, #5
002174  881C04     MOV W4, DMA0CON
473:               	DMA0CONbits.MODE = 0x0; 		// Operating Mode: Continuous, Ping-Pong modes disabled
002176  801C04     MOV DMA0CON, W4
002178  A10004     BCLR W4, #0
00217A  A11004     BCLR W4, #1
00217C  881C04     MOV W4, DMA0CON
474:               	
475:               	DMA0REQ = 70; 					// Assign ECAN1 Transmit event for DMA Channel 0 
00217E  200464     MOV #0x46, W4
002180  881C14     MOV W4, DMA0REQ
476:               	
477:               	DMA0PAD = (unsigned int)&C1TXD; 				// Peripheral Address: ECAN1 Transmit Register 
002182  204424     MOV #0x442, W4
002184  881C44     MOV W4, DMA0PAD
478:               	
479:               	DMA0CNT = 7; 					// Set Number of DMA Transfer per ECAN message to 8 words  
002186  200074     MOV #0x7, W4
002188  881C54     MOV W4, DMA0CNT
480:                	 
481:                	DMA0STA = 0x0000;  				// Start Address Offset for ECAN1 Message Buffer 0x0000 
00218A  EB0200     CLR W4
00218C  881C24     MOV W4, DMA0STA
482:               	//DMA0STA=  __builtin_dmaoffset(ecan1msgBuf);	
483:               	
484:               	DMA0CONbits.CHEN = 0x1; 		// Channel Enable: Enable DMA Channel 0 
00218E  A8E381     BSET 0x381, #7
485:               	IEC0bits.DMA0IE = 1;			// Channel Interrupt Enable: Enable DMA Channel 0 Interrupt  
002190  A88094     BSET IEC0, #4
486:               
487:               }
002192  FA8000     ULNK
002194  060000     RETURN
488:               
489:               
490:               /****************** Dma Initialization for RX ****************/
491:               
492:               void dma1init(void){
002196  FA0000     LNK #0x0
493:               
494:               	DMACS1=0;						// Clear DMA Status
002198  EB0200     CLR W4
00219A  881F14     MOV W4, DMACS1
495:                   
496:               	DMA1CONbits.SIZE = 0x0; 		// Data Transfer Size: Word Transfer Mode
00219C  A9C38D     BCLR 0x38D, #6
497:               	DMA1CONbits.DIR = 0x0; 			// Data Transfer Direction: Peripheral to DMA RAM
00219E  A9A38D     BCLR 0x38D, #5
498:               	DMA1CONbits.HALF = 0x0;			// Initiate interrupt when all data has been transfered	 
0021A0  A9838D     BCLR 0x38D, #4
499:               	DMA1CONbits.NULLW = 0x0;		// Normal operation (no NULL data write)
0021A2  A9638D     BCLR 0x38D, #3
500:               	DMA1CONbits.AMODE = 0x2; 		// DMA Addressing Mode: Peripheral Indirect Addressing mode
0021A4  801C64     MOV DMA1CON, W4
0021A6  A14004     BCLR W4, #4
0021A8  A05004     BSET W4, #5
0021AA  881C64     MOV W4, DMA1CON
501:               	DMA1CONbits.MODE = 0x0; 		// Operating Mode: Continuous, Ping-Pong modes disabled
0021AC  801C64     MOV DMA1CON, W4
0021AE  A10004     BCLR W4, #0
0021B0  A11004     BCLR W4, #1
0021B2  881C64     MOV W4, DMA1CON
502:               	
503:               	DMA1REQ = 34; 					// Assign ECAN1 Receive event for DMA Channel 1 
0021B4  200224     MOV #0x22, W4
0021B6  881C74     MOV W4, DMA1REQ
504:               	
505:               	DMA1PAD = (unsigned int)&C1RXD; 				// Peripheral Address: ECAN1 Transmit Register 
0021B8  204404     MOV #0x440, W4
0021BA  881CA4     MOV W4, DMA1PAD
506:               	
507:               	DMA1CNT = 7; 					// Set Number of DMA Transfer per ECAN message to 8 words  
0021BC  200074     MOV #0x7, W4
0021BE  881CB4     MOV W4, DMA1CNT
508:                	 
509:                	DMA1STA = 0x0000;  				// Start Address Offset for ECAN1 Message Buffer 0x0000 
0021C0  EB0200     CLR W4
0021C2  881C84     MOV W4, DMA1STA
510:               	// ATTENTION 80 ???
511:               	//DMA0STA=  __builtin_dmaoffset(ecan1msgBuf);	
512:               	
513:               	DMA1CONbits.CHEN = 0x1; 		// Channel Enable: Enable DMA Channel 0 
0021C4  A8E38D     BSET 0x38D, #7
514:               	IEC0bits.DMA1IE = 1;			// Channel Interrupt Enable: Enable DMA Channel 0 Interrupt  
0021C6  A8C095     BSET 0x95, #6
515:               
516:               }
0021C8  FA8000     ULNK
0021CA  060000     RETURN
517:               
518:               /****************** Dma Interrupt handlers *******************/
519:               
520:               void __attribute__((interrupt, no_auto_psv)) _DMA0Interrupt(void)
521:               {
0021CC  FA0000     LNK #0x0
522:                  IFS0bits.DMA0IF = 0;          // Clear the DMA0 Interrupt Flag;
0021CE  A98084     BCLR IFS0, #4
523:               }
0021D0  FA8000     ULNK
0021D2  064000     RETFIE
524:               
525:               void __attribute__((interrupt, no_auto_psv)) _DMA1Interrupt(void)
526:               {
0021D4  FA0000     LNK #0x0
527:                  IFS0bits.DMA1IF = 0;          // Clear the DMA1 Interrupt Flag;
0021D6  A9C085     BCLR 0x85, #6
528:               }
0021D8  FA8000     ULNK
0021DA  064000     RETFIE
